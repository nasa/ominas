/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("./cas_cirs_example.html", "cas_cirs_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "cas_cirs_example.pro", "", "", " CIRS EXAMPLE     This script demonstrates reading a Cassini CIRS cube and projecting it    onto an orthographical map for display with a Cassini ISS image of Mimas.     Setup: The instrument detectors, translators and transforms must contain the    CIRS and ISS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab.     This example requires SPICE/Icy to have been setup. It can be run by doing: <code class= source > .run cas_cirs_example</code>    From within an OMINAS IDL session.   Extract CIRS files     The cubes from PDS are too large to include in the OMINAS repository uncompressed,    so we will uncompress the tar files included with OMINAS: <code class= source > ;Extract the CIRS files, if needed</code> <code class= source > ldir='~/ominas_data/cirs'</code> <code class= source > spawn,'eval echo '+ldir,res</code> <code class= source > ldir=res</code> <code class= source > imgs=ldir[0]+path_sep()+['126MI_FP3DAYMAP001_CI006_601_F3_039E.DAT','126MI_FP3DAYMAP001_CI004_601_F3_039E.DAT']</code> <code class= source > foreach img,imgs do if ~file_test(img,/read) then begin</code> <code class= source >   print,'CIRS DAT file needed for the demo not found. Extracting it from the tar.gz file provided with OMINAS...'</code> <code class= source >   file_untar,getenv('OMINAS_DEMO')+path_sep()+'data'+path_sep()+file_basename(img,'.DAT')+'.tar.gz',ldir,/verbose</code> <code class= source > endif</code>     Display CIRS files     Since the cubes have many wavelenghts, create a single-band product for    visualization, by adding the flux on all bands: <code class= source > for i=0,1 do begin</code> <code class= source >   da=dat_data(dd[i])</code> <code class= source >   dat_set_data,dd[i],reverse(total(da.core,3),2)</code> <code class= source >   tvim,dat_data(dd[i]),/order,/new</code> <code class= source > endfor</code>             Map CIRS and ISS files     CIRS cube data are provided in PDS as a map on the target, in a rectangular projection, shown above.    To use them, first we need to obtain the proper map descriptor from the data object:    Create the new map descriptor: <code class= source > map_xsize = 1000</code> <code class= source > map_ysize = 1000</code>  <code class= source > mdp= pg_get_maps(/over,  $</code> <code class= source >   name='MIMAS',$</code> <code class= source >   projection='ORTHOGRAPHIC', $</code> <code class= source >   size=[map_xsize,map_ysize], $</code> <code class= source >   origin=[map_xsize,map_ysize]/2, $</code> <code class= source >   center=[0d0,-0.7d0*!dpi])</code>    Now, read the ISS image and put it into an array with the CIRS cubes: <code class= source > dd=[(dat_read(getenv('OMINAS_DIR')+'/demo/data/N1644787857_1.IMG'))[0],dd]</code>    Get the necessary camera, map, planet descriptors: <code class= source > nv=3</code> <code class= source > mdr=objarr(nv) & cd=objarr(nv) & pd=objarr(nv) & ltd=objarr(nv) & dd_map=objarr(nv)</code> <code class= source > gd = replicate({cd:obj_new(), gbx:obj_new(), dkx:obj_new(), ltd:obj_new()}, nv)</code> <code class= source > for i=0,nv-1 do begin</code> <code class= source >   gd[i].cd = pg_get_cameras(dd[i])</code> <code class= source >   gd[i].gbx = pg_get_planets(dd[i], od=cd[i],name='MIMAS')</code> <code class= source >   gd[i].ltd = pg_get_stars(dd[i], od=cd[i], name='SUN')</code> <code class= source >   if i gt 0 then begin</code> <code class= source >     mdr[i]=pg_get_maps(dd[i])</code> <code class= source >     dd_map[i]=pg_map(dd[i],md=mdp,cd=mdr[i],pc_xsize=500,pc_ysize=500)</code> <code class= source >   endif else begin</code> <code class= source >     dd_map[i]=pg_map(dd[i], md=mdp, gd=gd[i],aux=['EMM'])</code> <code class= source >   endelse</code> <code class= source >   ;Scale the data in all bands to the same range (0-1)</code> <code class= source >   da=dat_data(dd_map[i])</code> <code class= source >   r=minmax(da)</code> <code class= source >   dat_set_data,dd_map[i],(da-r[0])/(r[1]-r[0])</code> <code class= source > endfor</code>    Visualize the result, now with grim: <code class= source > grim,dd_map,cd=replicate(mdp,3),od=gd.cd,ltd=gd.ltd,pd=gd.gbx,channel=[1b,2b,2b],overlays=['planet_grid'],/new,vis=1</code>         Create composite images     Combine the channels, as a grayscale ISS image, with a transparent color CIRS overlay: <code class= source > im0=image(dat_data(dd_map[0]),dimensions=[map_xsize,map_ysize],/no_toolbar,margin=0)</code> <code class= source > im1=image(dat_data(dd_map[1])&gt;dat_data(dd_map[2]),/current,transparency=60,rgb_table=13)</code>          Now, combine using ISS as the intensity, CIRS as the hue for the image: <code class= source > s=dblarr(map_xsize,map_ysize) & l=s & h=s</code> <code class= source > s[*]=(dat_data(dd_map[1])) gt 0d0</code> <code class= source > l[*]=dat_data(dd_map[0])</code> <code class= source > h[*]=(dat_data(dd_map[1]))*240d0</code> <code class= source > color_convert,h,l,s,r,g,b,/hls_rgb</code> <code class= source > im2=image([[[r]],[[g]],[[b]]],dimensions=[map_xsize,map_ysize],/no_toolbar,margin=0)</code>        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./cas_radar_example.html", "cas_radar_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "cas_radar_example.pro", "", "", " RADAR EXAMPLE     This script demonstrates reading a Cassini RADAR SAR image and projecting it    onto an orthographical map for display.     The data file used, BIFQI22N068_D045_T003S01_V02.IMG, is too large (202 MB)    to include with the OMINAS distribution. This script will look for the file    under ~/ominas_data/sar/, and if not found, will download it from    PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,    then unzip it.     Setup: The instrument detectors, translators and transforms must contain the    RADAR definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab. Since the RADAR    data is in PDS format, the PDS detector and io functions must also be set up    in the corresponding tables, as is in config/tab/filetype_detectors.tab    and config/tab/io.tab.     There is no need for SPICE/Icy for this example. It can be run by doing: <code class= source > .run cas_radar_example</code>    From within an OMINAS IDL session.   Read SAR file     Cassini RADAR SAR image to read must be set in the variable img, otherwise    this default location is used: <code class= source > ;Download the file, if needed</code> <code class= source > ldir='~/ominas_data/sar'</code> <code class= source > spawn,'eval echo '+ldir,res</code> <code class= source > ldir=res</code> <code class= source > img=ldir+path_sep()+'BIFQI22N068_D045_T003S01_V02.IMG'</code> <code class= source > if ~file_test(img,/read) then begin</code> <code class= source >   print,'SAR file needed for the demo not found. Downloading it from PDS...'</code> <code class= source >   p=pp_wget('http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',localdir=ldir)</code> <code class= source >   p.geturl</code> <code class= source >   print,'ZIP file downloaded, decompressing it...'</code> <code class= source >   file_unzip,ldir+path_sep()+'CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',/verbose</code> <code class= source > endif</code>  <code class= source > ;Read the file</code> <code class= source > dd=dat_read(img)</code>   Display SAR file     Saturate the data to make the image better looking, since this is just for display    purposes: <code class= source > da=dat_data(dd)</code> <code class= source > dat_set_data,dd,da&lt;4.5d0</code>    Show it a 1/20 resolution: <code class= source > tvim,da&lt;4.5,zoom=0.05,/order,/new</code>         Map SAR file     SAR data is provided in PDS as a map on the target, in an oblique rectangular projection, shown above.    To use it, first we need to obtain the proper map descriptor from the data object: <code class= source > mdr=pg_get_maps(dd)</code>    Now we will display it in an orthogonal projection. First we define it: <code class= source > map_xsize = 4000</code> <code class= source > map_ysize = 4000</code>    Create the new map descriptor: <code class= source > mdp= pg_get_maps(/over,  $</code> <code class= source >   name='TITAN',$</code> <code class= source >   projection='ORTHOGRAPHIC', $</code> <code class= source >   size=[map_xsize,map_ysize], $</code> <code class= source >   origin=[map_xsize,map_ysize]/2, $</code> <code class= source >   center=[0d0,-0.4d0*!dpi])</code>    Now, do the projection: <code class= source > dd_map=pg_map(dd,md=mdp,cd=mdr,pc_xsize=800,pc_ysize=800)</code>    Visualize the result, now with grim: <code class= source > cd = pg_get_cameras(dd)</code> <code class= source > pd = pg_get_planets(dd, od=cd)</code> <code class= source > ltd = pg_get_stars(dd, od=cd, name='SUN')</code> <code class= source > grim,dd_map,cd=mdp,od=cd,ltd=ltd,pd=pd[0],overlays=['planet_grid'],order=0</code>        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./cas_vims_example.html", "cas_vims_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "cas_vims_example.pro", "", "", " VIMS EXAMPLE     This script demonstrates reading Cassini RADAR VIMS cubes and projecting them    onto an equirectangular mosaic.     The data files are provided in the demo/data directory.     Setup: The instrument detectors, translators and transforms must contain the    VIMS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab.     This example requires SPICE/Icy to have been setup. It can be run by doing: <code class= source > .run cas_vims_example</code>    from within an OMINAS IDL session.   Read VIMS files       Set up a hash containing the file names and precomputed pointing offsets: <code class= source > hdxy=hash()</code> <code class= source > hdxy['CM_1559100372_1_ir_eg.cub']=[-2d0,-2d0]</code> <code class= source > hdxy['CM_1503358311_1_ir_eg.cub']=[5d0,-1d0]</code> <code class= source > hdxy['CM_1477456632_1_ir_eg.cub']=[2d0,-3d0]</code> <code class= source > hdxy['CM_1504754217_1_ir_eg.cub']=[1d0,-2d0]</code>  <code class= source > files=getenv('OMINAS_DIR')+'/demo/data/'+((hdxy.keys()).toarray())</code> <code class= source > n = n_elements(files)</code> <code class= source > dd = dat_read(files)</code> <code class= source > foreach ddd,dd do dat_set_data,ddd,0.&gt;dat_data(ddd)&lt;0.1</code>   Set up descriptors needed to make the grids and mosaic       Create an array of global descriptors and populate it: <code class= source > gd = replicate({cd:obj_new(),cds:objarr(256), gbx:obj_new(), dkx:obj_new(), ltd:obj_new()}, n)</code> <code class= source > for i=0, n-1 do gd[i].cds = pg_get_cameras(dd[i])</code> <code class= source > for i=0, n-1 do gd[i].cd=gd[i].cds[0]</code> <code class= source > for i=0, n-1 do gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, name='TITAN')</code> <code class= source > for i=0, n-1 do gd[i].ltd = pg_get_stars(dd[i], od=gd[i].cd, name='SUN')</code>      Apply the pointing shifts and compute the limbs: <code class= source > limb_ps = objarr(n)</code> <code class= source > dxy = dblarr(2,n)</code> <code class= source > for i=0, n-1 do dxy[*,i] = hdxy[file_basename(files[i])]</code> <code class= source > for i=0, n-1 do for j=0,255 do pg_repoint, dxy[*,i], 0d, cd=gd[i].cds[j]</code> <code class= source > for i=0, n-1 do gd[i].cd=gd[i].cds[0]</code> <code class= source > for i=0, n-1 do limb_ps[i] = pg_limb(gd=gd[i]);</code>   Display an image of one of the bands with a limb and grid on top       Create an array of global descriptors and populate it: <code class= source > xsize=800</code> <code class= source > ysize=800</code> <code class= source > zoom=8</code> <code class= source > offset=[-20,-20]</code> <code class= source > for i=0, n-1 do begin</code> <code class= source >   tvim, (dat_data(dd[i]))[*,*,70], $</code> <code class= source >     zoom=zoom,/order, /new,offset=offset,$</code> <code class= source >     xsize=xsize,ysize=ysize</code> <code class= source >   pg_draw, limb_ps[i]</code> <code class= source >   write_png,tvrd()</code> <code class= source > endfor</code> <code class= source > tvim, /list, wnum=ww</code>      Create and draw the lat/lon grid and labels: <code class= source > imc=0</code> <code class= source > for i=0,n-1 do begin</code> <code class= source >   grid_ps = pg_grid(gd=gd[i], lat=lat, lon=lon)</code> <code class= source >   pg_hide, grid_ps, cd=gd[i].cd, gbx=gd[i].gbx</code> <code class= source >   pg_hide, grid_ps, cd=gd[i].cd, gbx=gd[i].gbx,$</code> <code class= source >     od=gd[i].ltd</code> <code class= source >   pg_draw, grid_ps, color=ctblue(),wnum=ww[i]</code> <code class= source >   plat_ps = pg_grid(gd=gd[i],slon=!dpi/2d,lat=lat,nlon=0)</code> <code class= source >   pg_hide, plat_ps[0], cd=gd[i].cd, gbx=gd[0].gbx</code> <code class= source >   pg_draw, plat_ps[0], psym=3, $</code> <code class= source >     plabel=strtrim(round(lat*180d/!dpi),2),$</code> <code class= source >     /label_p,wnum=ww[i]</code> <code class= source >   plon_ps = pg_grid(gd=gd[i], slat=0d, lon=lon, nlat=0)</code> <code class= source >   pg_hide, plon_ps[0], cd=gd[i].cd, gbx=gd[i].gbx</code> <code class= source >   pg_draw, plon_ps[0], psym=3, $</code> <code class= source >     plabel=strtrim(round(lon*180d/!dpi),2),$</code> <code class= source >     /label_p,wnum=ww[i]</code> <code class= source > endfor</code>      These 4 images would look like                                Create a 3-band mosaic       Correct the illumination with a Lambertian function: <code class= source > dd_pht = objarr(n)</code> <code class= source > for i=0, n-1 do dd_pht[i] = pg_photom(dd[i], gd=gd[i],</code> <code class= source >   refl_fn='pht_lamb', refl_parm=[0.9d], outline=limb_ps[i])</code> <code class= source > phtdata=list()</code> <code class= source > for i=0,n-1 do phtdata.add,(dat_data(dd_pht[i]))</code>      Set up the mosaic: <code class= source > bands=[70,104,106]</code> <code class= source > map_xsize = 1600</code> <code class= source > map_ysize = 800</code> <code class= source > moslim=[[0d0,0.2d0],[0d0,0.01d0],[0d0,0.1d0]]</code> <code class= source > mosaics=list()</code>      Loop over bands, projecting and displaying each image: <code class= source > foreach band,bands,iband do begin</code> <code class= source >   for i=0,n-1 do dat_set_data,dd_pht[i],phtdata[i,*,*,band]</code> <code class= source >   md = pg_get_maps(/over, gbx = pd1, name='TITAN',$</code> <code class= source >    projection='RECTANGULAR',fn_data=ptr_new(),$</code> <code class= source >    size=[map_xsize,map_ysize],origin=[map_xsize,map_ysize]/2)</code> <code class= source >   dd_map = objarr(n)</code> <code class= source >   for i=0, n-1 do begin</code> <code class= source >    dd_map[i]=pg_map(dd_pht[i],md=md,gd=gd[i],aux=['EMM'])</code> <code class= source >    tvim,dat_data(dd_map[i])&lt;max((dat_data(dd[i]))[*,*,band]),/new</code> <code class= source >   endfor</code>      These projected images would look like:                                   Combine the images in a mosaic and display it: <code class= source >   dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $</code> <code class= source >     wt='emm', comb='sum', data={x:1, emm0:cos(90d*!dpi/180d)})</code> <code class= source >   tvim,moslim[0,iband]&gt;mosaic&lt;moslim[1,iband],/new</code>      Add a grid on top: <code class= source >   pd = pg_get_planets(dd[0], od=gd[0].cd)</code> <code class= source >   gdm={cd:md,od:(gd[0].cd)[0],gbx:cor_select(pd,'TITAN'),$</code> <code class= source >    dkx:gd[0].dkx}</code> <code class= source >   map_grid_ps=pg_grid(gd=gdm, lat=lat, lon=lon)</code> <code class= source >   plat_ps=pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</code> <code class= source >   plon_ps=pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</code> <code class= source >   pg_draw, map_grid_ps, col=ctgreen()</code> <code class= source >   pg_draw,plat_ps,psym=7,$</code> <code class= source >    plabel=strmid(strtrim(lat*180d/!dpi,2),0,3),/label_p</code> <code class= source >   pg_draw,plon_ps,psym=7,$</code> <code class= source >     plabel=strmid(strtrim(lon*180d/!dpi,2),0,3),/label_p</code> <code class= source >   mosaics.add,mosaic</code> <code class= source > endforeach</code>      The mosaics would look like, for each band:                       ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./eclipse_example-batch.html", "eclipse_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "eclipse_example-batch.pro", "", "", "                            ECLIPSE EXAMPLE    Created by Joe Spitale    This example script demonstrates  OMINAS' rendering functionality using the   2017 total Solar eclipse as an example.    This example file can be executed from the shell prompt in the ominas/demo   directory using:   	ominas eclipse_example-batch    or from within IDL using:   	@eclipse_example-batch  OBSERVATION PARAMETERS    Here we set basic parameters of the observation: start and stop times,   number of time steps, name of instrument.  Note that the times could also   be given numerically; UTC times are used for readability.  The   interpretation of the times is performed by the translators (see next step): <code class= source > instrument = 'CAS_ISS_NA'</code> <code class= source > times = ['2017-08-21T19:00:00','2017-08-21T20:00:00']</code> <code class= source > nt = 2</code>   CONVERT TIMES    Times could be converted by directly calling procedures within the SPICE   translator package, but we would like to avoid such explicitly application-   specific code here.  Instead, we use PG_GET_PLANETS and assume (hope?)   there is a translator that can interpret UTC times.  Once the start and   stop times are converted to ET, the full time array is obtained using   interpolation : <code class= source >  pds = pg_get_planets(time=times, name=['EARTH'])</code> <code class= source >  t_start = bod_time(pds[0])</code> <code class= source >  t_stop = bod_time(pds[1])</code>  <code class= source >  t = t_start</code> <code class= source >  if(nt GT 1) then t = (dindgen(nt)/(nt-1) * (t_stop - t_start)) + t_start</code>   CAMERA PARAMETERS    Camera descriptors are obtained for all times.  Note that, because there   is no data descriptor, this call to PG_GET_CAMERAS creates one and returns   it in the first argument. the position and pointing of the cameras will be   changed in the next step: <code class= source >  cd = pg_get_cameras(instrument=instrument, time=times)</code>   SET CAMERA POSITIONS AND POINTING    If left alone, the camera pointing and positions will be whatever was   returned by the translators (in this case, wherever Cassini was and   where it was pointed at the specified times).  Here we force the cameras to   point at the center of the Earth (with the Y vector pointed to celestial   north), and we place the camera along the Earth-Moon line at 8 times the   Earth-Moon distance.  Note the use of the data descriptor created by   PG_GET_CAMERAS: <code class= source >  pd0 = pg_get_planets(dd, od=cd, name='EARTH')</code> <code class= source >  pd1 = pg_get_planets(dd, od=cd, name='MOON')</code> <code class= source >  pg_reposition, bx=cd, bod_pos(pd0) + (bod_pos(pd1)-bod_pos(pd0))*, /absolute</code> <code class= source >  pg_repoint, cd=cd, bod_pos(pd0)-bod_pos(cd), /north</code>   VIEW RENDERED SCENES WITH GRIM    We input the camera descriptors to GRIM, but let it compute all other   descriptors.  Planets are computed within 1 AU of the camera.  Note that   the ordering of the initial overlays is intentional, causing the shadow   to be computed for only the Moon's terminator before other overlays are   computed.  /RENDER_AUTO causes all planes to be rendered intially, and   upon any descriptor events, for example, as a result of using GRIM's   NAVIGATE mode: <code class= source >  grim, dd, cd=cd, order=0, xsize=768, ysize=768, /activate, $</code> <code class= source >         plt_distmax=const_get('AU'), $</code> <code class= source >         over=['terminator:MOON', $</code> <code class= source >               'shadow:MOON', $</code> <code class= source >               'center', $</code> <code class= source >               'limb:EARTH,MOON', $</code> <code class= source >               'planet_grid:EARTH,MOON'], frame='limb', /render_auto</code>   Note that various renderng settings may be changed using options under   View-&gt;Render.  A more realistic shadow may be obtained by modifying   the NUMBRA value, though it will sow down the rendering significantly.              ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./geotiff_example.html", "geotiff_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "geotiff_example.pro", "", "", " GEOTIFF EXAMPLE     This script demonstrates reading a Mars MOLA DEM geotiff and projecting it    onto an orthographical map for display. The geotiff provided in the demo    directory was downsampled by a factor of 20 from the original MOLA DEM from    https://astrogeology.usgs.gov/search/map/Mars/GlobalSurveyor/MOLA/Mars_MGS_MOLA_ClrShade_merge_global_463m     There is no need for SPICE/Icy for this example. It can be run by doing: <code class= source > .run geotiff_example</code>    From within an OMINAS IDL session.   Read geotiff file       dd=dat_read(getenv('OMINAS_DEMO')+path_sep()+'data'+path_sep()+'Mars_MGS_MOLA_DEM_mosaic_global_9260m.tif')    Display geotiff on grim     Get a map descriptor and use it to show the DEM on grim with a map grid: <code class= source > md=pg_get_maps(dd)</code> <code class= source > ;subtract the minimum elevation, so that the data range starts at 0, for visualization</code> <code class= source > da=double(dat_data(dd))</code> <code class= source > damin=min(da)</code> <code class= source > da-=damin</code> <code class= source > dat_set_data,dd,da</code> <code class= source > grim,dd,cd=md,order=0,overlay=['planet_grid']</code>         Map into orthographic projection     Now we will display it in an orthogonal projection. First we define it: <code class= source > map_xsize = 4000</code> <code class= source > map_ysize = 4000</code>    Create the new map descriptor: <code class= source > mdp= pg_get_maps(/over,  $</code> <code class= source >   name='MARS',$</code> <code class= source >   projection='ORTHOGRAPHIC', $</code> <code class= source >   size=[map_xsize,map_ysize], $</code> <code class= source >   origin=[map_xsize,map_ysize]/2, $</code> <code class= source >   center=[0d0,-60d0*!dpi/180d0])</code>    Now, do the projection: <code class= source > dd_map=pg_map(dd,md=mdp,cd=md,pc_xsize=800,pc_ysize=800)</code>    Visualize the result, now with grim: <code class= source > grim,dd_map,cd=mdp,overlays=['planet_grid'],order=0,/new</code>         Save geotiffs from OMINAS maps     Put map descriptors in data descriptors: <code class= source > cor_set_udata,dd_map,'md',mdp</code> <code class= source > cor_set_udata,dd,'md',md</code> <code class= source > ;scale data for geotiff</code> <code class= source > ndd=nv_clone(dd)</code> <code class= source > ndd_map=nv_clone(dd_map)</code> <code class= source > dat_set_data,ndd,bytscl(dat_data(ndd))</code> <code class= source > dat_set_data,ndd_map,bytscl(dat_data(ndd_map))</code> <code class= source > dat_write,'geotiff_ex1.tif',ndd,filetype='GEOTIFF'</code> <code class= source > ;dat_write,'geotiff_ex2.tif',ndd_map,filetype='GEOTIFF'</code>     This is how the image looks like on GoogleEarth Pro          For comparison, this is GoogleEarth Pro's base layer, with the same perspective        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./graft_example-batch.html", "graft_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "graft_example-batch.pro", "", "", "                            GRAFT EXAMPLE    Created by Joe Spitale    This example file demonstrates the use the GRIM interface programs   GRIFT and GRAFT.  While GRIFT cheats GRIM out of its object references,   GRAFT corruptly inserts (or grafts) data arrays into a GRIM instance.    The usage demonstrated here is a bit contrived, as one could accomplish   a better result by specifying the desired overlays in the call to GRIM,   as in grim_example, but let's live a little.    This example file can be executed from the shell prompt in the ominas/demo   directory using:   	ominas graft_example-batch    or from within IDL using:   	@graft_example-batch    You can also just paste line-by-line if you want to inspect the variables   at each step.    After the example stops, later code samples in this file may be executed by   pasting them onto the IDL command line.  READ AND DISPLAY IMAGE    Use GRIM to open and display an image: <code class= source > grim, './data/n1350122987.2', zoom=0.75, /order</code>   GRIFT    First, GRIFT the data descriptor out of poor old GRIM.  Note that the   returned object is a reference to the same object as GRIM is using: <code class= source > grift, dd=dd</code>   Be warned that GRIM jealously watches over its objects and updates whenever   it detects any changes, so you can simultaneously operate on objects from   within GRIM and from the command line.  For example, try: 	dat_set_data, dd, rotate(dat_data(dd),7)    GRIM resigns itself to having its data descriptor tampered with and   updates the display accordingly.  Run the same command again if you   want flip the image back.   OBTAIN GEOMETRY    Now compute geometry for this dd.  This is the same business you have   seen in all of the other demos, cd, pd, etc.  Of course, you could have   just had GRIM do this: <code class= source > cd = pg_get_cameras(dd, 'ck_in=auto')</code> <code class= source > pd = pg_get_planets(dd, od=cd, $</code> <code class= source >        name=['JUPITER', 'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO'])</code> <code class= source > rd = pg_get_rings(dd, pd=pd, od=cd)</code> <code class= source > ltd = pg_get_stars(dd, od=cd, name='SUN')</code>   MAKE A GENERIC DESCRIPTOR    And of course we shove everything into a generic descriptor because it   makes everything so much easier: <code class= source > gd = {cd:cd, gbx:pd, dkx:rd, ltd:ltd}</code>   COMPUTE OVERLAY ARRAYS    Same old story;  PG_LIMB, PG_DISK, PG_HIDE, etc.  GRIM would have been   happy to do this for you: <code class= source > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, /rm, bx=rd</code> <code class= source >           pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=ltd</code> <code class= source > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</code> <code class= source > term_ptd = pg_limb(gd=gd, od=gd.ltd) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</code> <code class= source > center_ptd = pg_center(gd=gd, bx=pd)</code>   DISPLAY OVERLAYS    Ok, now let's draw those overlays, just like in the PG example.  This   is going to be great: <code class= source > pg_draw, center_ptd, col=ctwhite(), psym=1, plabel=cor_name(pd)</code> <code class= source > pg_draw, limb_ptd, col=ctyellow()</code> <code class= source > pg_draw, term_ptd, col=ctred()</code> <code class= source > pg_draw, ring_ptd, col=ctorange()</code>   Now let's zoom in and take a look at things.  You can use the mouse wheel   with Ctrl depressed, or you can use one of the Zoom cursor modes, or you   can use the View-&gt;Zoom menu, or the associated keyboard shortcuts if   have your Xdefaults-grim installed; basically just throw a flip-flop at   your computer and you should be able to make this happen.    But wait, where did my overlays go?  Did they ever even exist?  If you   are older than two years of age and have mastered object permanence,   then you probably have this one figured out.  We need a way to draw   these things permanently; some way of GRAFTing them into GRIM...   GRAFT    GRAFT  grafts  the POINT objects into GRIM.  Note that these are entered   as user arrays in GRIM, so they're pretty much second class as far as   GRIM is concerned.  This would have been way better if you had just   specified these as overlays in your call to GRIM.  Now you have wasted   your time and GRIM's.      graft, center_ptd, col=ctwhite(), psym=1;, plabel=cor_name(pd)     graft, limb_ptd, col=ctyellow()     graft, term_ptd, col=ctred()     graft, ring_ptd, col=ctorange()       ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./grift_example-batch.html", "grift_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "grift_example-batch.pro", "", "", "                            GRIFT EXAMPLE    Created by Joe Spitale    This example script demonstrates the usage of the GRIM interface program   GRIFT.  GRIFT swindles GRIM into giving up references to its descriptor set   so they can be used against it by some foreign agent.    This example file can be executed from the shell prompt in the ominas/demo   directory using:   	ominas grim_example-batch    or from within IDL using:   	@grim_example-batch  OPEN IMAGE IN GRIM    This is basically it.  GRIM opens the specified image or images, and   computes whatever overlays you specify.  NHIST specifies the number   how far back the data descriptor history should go for the purpose   of undoing.  So now you're finished.  Have fun!   : <code class= source >  grim, '~/casIss/1350/N1350122987_2.IMG', $</code> <code class= source >             over=['center','limb','terminator','ring'], nhist=5</code>        RE-POINT FROM COMMAND LINE    Actually there is one more thing just for kicks.  GRIM could do this   from the menu, but you can also do it from the command line.  Just   GRIFT the descriptors out of GRIM, scan for edges and do a farfit.   GRIM sees the update to the camera descriptor and takes the liberty of   recomputing everything that depends on that descriptor.  Neato!   : <code class= source > grift, cd=cd, dd=dd, limb_ptd=limb_ptd</code>  <code class= source > edge_ptd = pg_edges(dd, edge=10, np=4000)</code> <code class= source > pg_draw, edge_ptd</code>  <code class= source > dxy = pg_farfit(dd, edge_ptd, limb_ptd[0])</code> <code class= source > pg_repoint, dxy, cd=cd</code>      ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./grim_example-batch.html", "grim_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "grim_example-batch.pro", "", "", "                            GRIM EXAMPLE    Created by Joe Spitale    This example script demonstrates various basic ways to run GRIM, the   graphical interface to OMINAS.  GRIM is kind of like a fancier TVIM,   where you can do all the standard stuff like zooming, panning, and   all manner of other acts that TVIM would never consent to.  You could   just use it exactly like TVIM, using PG_DRAW/PLOTS to draw overlays,   etc., but then none of your overlays would be permanent.  GRIM   maintains arrays internally, so they hang around as you zoom and pan   all over the place.  GRIM also maintains object descriptors and monitors   them very closely; you can barely sneeze around a descriptor without   GRIM refreshing itself several times.  See GRIM.PRO for information   on usage, or just play around with it.    This example file can be executed from the shell prompt in the ominas/demo   directory using:   	ominas grim_examples-batch    or from within IDL using:   	@grim_examples-batch  EXAMPLE 1:    Read a data descriptor and give it to GRIM.  Also specify some overlays: <code class= source > dd = dat_read(file)</code> <code class= source > grim, dd, zoom=0.75, /order, $</code> <code class= source >               overlay=['center', 'limb', 'terminator', 'ring']</code>        EXAMPLE 2:    Example 1 was kind of dumb, because you could have just done this.  Note   the /new.  Without it, GRIM will try to update the existing instance.   If you zoom out, you may notice many objects far from the field of view: <code class= source > grim, /new, file, zoom=0.75, /order, $</code> <code class= source >             overlay=['center', 'limb', 'terminator', 'ring']</code>        EXAMPLE 3:    Try specifying some explicit planet names.  This will likely be faster   because the above examples may have returned many more planets, depending   on your translator setup: <code class= source > grim, /new, file, zoom=0.75, /order, $</code> <code class= source >     overlay=['center:JUPITER,IO,EUROPA,GANYMEDE,CALLISTO', $</code> <code class= source >                                             'limb', 'terminator', 'ring']</code>        EXAMPLE 4:    Let's get rid of the explicit planet names and just select them based   on geometric criteria.  FOV=-1 selects overlays within 1 field of view   of the viewport: <code class= source > grim, /new, file, zoom=0.75, /order, $</code> <code class= source >     overlay=['center', 'limb', 'terminator', 'ring'], fov=-1</code>        EXAMPLE 5:    Same as above, except FOV=-1 selects overlays within 1 field of view   of the *image*: <code class= source > grim, /new, file, zoom=0.75, /order, $</code> <code class= source >     overlay=['center', 'limb', 'terminator', 'ring'], fov=1</code>         You have too many GRIM windows open.  Let's take care of that: <code class= source >grim, /exit, grn=lindgen(100)</code>    Speaking of way too many GRIMs, let's just open a bunch of images in   *one* GRIM.  Each image is opened in a separate plane.  You can change   planes using the left/right arrows in the top left corner.  If you have   Xdefaults-grim set up, you can use the left/right arrow keys: <code class= source > grim, /new, './data/n*.2', /order, overlay='center'</code>                         Did you know GRIM also handles plots?  Well it does!   : <code class= source > grim, /new, './data/GamAra037_2_bin50_031108.vic'</code>         And cubes!  Here's an rgb image cube with some overlays: <code class= source > grim, /new, './data/' + ['N1460072434_1.IMG', $</code> <code class= source >                          'N1460072401_1.IMG', $</code> <code class= source >                          'N1460072467_1.IMG'], $</code> <code class= source >       ext='.cal', visibility=1, channel=[1b,2b,4b], $</code> <code class= source >       over=['center', $</code> <code class= source >             'limb:SATURN', $</code> <code class= source >             'terminator:SATURN', $</code> <code class= source >             'planet_grid:SATURN', $</code> <code class= source >             'ring']</code>        Here's a spectral cube.  You'll need to stretch the levels to see   anything: <code class= source > grim, /new, './data/CM_1503358311_1_ir_eg.cub'</code>       ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./mosaic_example-batch.html", "mosaic_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "mosaic_example-batch.pro", "", "", " MOSAIC EXAMPLE    Created by Joe Spitale   Edited for manual by Mark Moretto    This example file demonstrates how to construct a mosaic using OMINAS.   This example file can be executed from the shell prompt in the ominas/demo   directory using:   	  ominas mosaic_example-batch     or from within an OMINAS IDL session using:   	  @mosaic_example-batch     After the example stops, later code samples in this file may be executed    by pasting them onto the IDL command line. ;    This first section uses DAT_READ to read in the image and then displays    the image using tvim.   Read and display image     DAT_READ reads the image portion (im) and the label (label) and returns a    data descriptor (dd) containing the image and label and information obtained    through OMINAS' configuration tables.  If a file exists in the same directory    and with the same name as the image, except with the extension  .dh ,    then it is assumed to be a detached header and it is read as well.     The files w1352097259.1 and n1352037683.2 are Cassini wide- and narrow-    angle frames of Jupiter.  2000r.img and 2100r.img are Galileo SSI    images of Ganymede.     TVIM is called to display the image (im) in a new window with the y    coordinate as top-down: <code class= source > files = getenv('OMINAS_DIR')+'/demo/data/'+['n1350122987.2','/n1351469359.2']</code>  <code class= source > dd = dat_read(files, count=n)</code>  <code class= source > zoom = 0.3</code> <code class= source > for i=0, n-1 do tvim, dat_data(dd[i]), zoom=zoom, /order, /new</code> <code class= source > tvim, /list, wnum=ww</code>              Get camera, planets, rings and sun objects: <code class= source > _gd = {cd:obj_new(), gbx:obj_new(), dkx:obj_new(), ltd:obj_new()}</code> <code class= source > gd = replicate(_gd, n)</code>  <code class= source > for i=0, n-1 do gd[i].cd = pg_get_cameras(dd[i])</code> <code class= source > for i=0, n-1 do gd[i].gbx = pg_get_planets(dd[i], od=gd[i].cd, name='JUPITER')</code> <code class= source > for i=0, n-1 do gd[i].dkx = pg_get_rings(dd[i], pd=gd[i].gbx, od=gd[i].cd)</code> <code class= source > for i=0, n-1 do gd[i].ltd = pg_get_stars(dd[i], od=gd[i].cd, name='SUN')</code>    Compute limb: <code class= source > limb_ptd = objarr(n)</code> <code class= source > for i=0, n-1 do limb_ptd[i] = pg_limb(gd=gd[i])</code>   Navigate on limbs automatically     PG_FARFIT finds the limb to within a few pixels.  In reality, you would    want to refine the pointing by scanning for the limb and performing a    least-squares fit, but for the purposes of clarity in this example, the    inital fit will do: <code class= source > edge_ptd = objarr(n)</code> <code class= source > for i=0, n-1 do edge_ptd[i] = pg_edges(dd[i], edge=10)</code>    Run PG_FARFIT to obtain the offsets between the computed points (limb_ptd)    and the image edges (edge_ptd) and apply the offsets with pg_repoint: <code class= source > dxy = dblarr(2,n)</code> <code class= source > for i=0, n-1 do dxy[*,i] = pg_farfit(dd[i], edge_ptd[i], [limb_ptd[i]], ns=[5,5])</code> <code class= source > for i=0, n-1 do pg_repoint, dxy[*,i], 0d, gd=gd[i]</code>    Recompute the geometry now that the pointing was corrected: <code class= source > for i=0, n-1 do limb_ptd[i] = pg_limb(gd=gd[i])</code> <code class= source > for i=0, n-1 do  pg_draw, limb_ptd[i], wnum=ww[i]</code>              See the PG example for examples of least-squares fits to image features    Correct photometry     Here, a crude photometric correction is performed for the purposes    of this example.     In addition to the corrected images, the output descriptors, dd_pht,    will contain the photometric angles in their user data arrays with    the names 'EMM', 'INC' and 'PHASE': <code class= source > dd_pht = objarr(n)</code> <code class= source > for i=0, n-1 do dd_pht[i] = pg_photom(dd[i], gd=gd[i], $</code> <code class= source >   refl_fn='pht_refl_minneart',refl_parm=[0.9d], outline=limb_ptd[i])</code>  <code class= source > for i=0, n-1 do tvim, dat_data(dd_pht[i]), ww[i]</code>             Project maps     Note that all map projections use the same map descriptor.     Also, aux=['EMM'] is used with pg_map to direct it to reproject    the emmision angle array that was produced and stored in the data descriptor    by pg_photom.  That array will be needed by pg_mosaic: <code class= source > map_xsize = 800</code> <code class= source > map_ysize = 400</code>    Create the map descriptor to use for the projections: <code class= source > md = pg_get_maps(/over, gbx = pd1, $</code> <code class= source >   name='JUPITER',$</code> <code class= source >   projection='RECTANGULAR', $</code> <code class= source >   fn_data=ptr_new(), $</code> <code class= source >   size=[map_xsize,map_ysize], $</code> <code class= source >   origin=[map_xsize,map_ysize]/2 )</code>  <code class= source > Do the map projections, frmo objects dd_pht, using map descriptor md:</code>      dd_map = objarr(n)      for i=0, n-1 do dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'])     Display the results: <code class= source > for i=0, n-1 do tvim, dat_data(dd_map[i]), /new</code>             Introducing wind profiles   Use the commented commands instead to include a zonal wind profile in  the projection: <code class= source > for i=0, n-1 do $</code> <code class= source >   dd_map[i] = pg_map(dd_pht[i], md=md, gd=gd[i], aux=['EMM'], $</code> <code class= source >   shear_fn='pm_shear_zonal', $</code> <code class= source >   shear_data={vel:cos((dindgen(181)-90)*!dpi/180d) * 100d, $</code> <code class= source >   dt:bod_time(gd[i].cd)-bod_time(gd[0].cd)})</code>   Construct the mosaic     The combination function 'emm' combines the maps    using wighting proprtional to emm^x, where emm is the emmision    cosine.  It also imposes a minimum emmision cosine, emm0.  Note    that the emission angles were computed by pg_photom and    reprojected by pg_map, as directed by the 'aux' keyword: <code class= source > dd_mosaic = pg_mosaic(dd_map, mosaic=mosaic, $</code> <code class= source >   wt='emm', comb='sum', data={x:5, emm0:cos(85d*!dpi/180d)})</code> <code class= source > tvim, mosaic, /new</code>        Save the mosaic and map info     To read the mosaic and projection info: <code class= source > dd = dat_read('./data/test.msc', mosaic, label)</code> <code class= source > md = pg_get_maps(dd)</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./multiinstrument_example.html", "multiinstrument_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "multiinstrument_example.pro", "", "", " MULTI-INSTRUMENT EXAMPLE     This script demonstrates reading Cassini RADAR SAR, VIMS, and ISS images and    projecting them onto an orthographical map for display as a RGB composite.     The SAR data file used, BIFQI22N068_D045_T003S01_V02.IMG, is too large (202 MB)    to include with the OMINAS distribution. This script will look for the file    under ~/ominas_data/sar/, and if not found, will download it from    PDS&lt;http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP&gt;,    then unzip it.     Setup: The instrument detectors, translators and transforms must contain the    RADAR, ISS and VIMS definitions, as is included in demo/data/instrument_detectors.tab,    demo/data/translators.tab, and demo/data/transforms.tab. The PDS detector    and io functions must also be set up    in the corresponding tables, as is in config/tab/filetype_detectors.tab    and config/tab/io.tab.    This example file can be executed from the shell prompt in the ominas/demo   directory using: <code class= source >  .run multiinstrument_example</code>  <code class= source >From within an OMINAS IDL session.</code>  <code class= source >Troubleshooting: This example uses ISS, VIMS and RADAR data, so each of these</code> <code class= source >3 might independently fail. If this example fails, it may be helpful to try first</code> <code class= source >running the 3 individual instrument's example scripts first: jupiter_example.pro (ISS),</code> <code class= source >vims_example.pro and radar_example.pro, to see which instruments work in your</code> <code class= source >setup and which do not.</code>  Read and display SAR file     Download the Cassini RADAR SAR image and unzip it, if needed: <code class= source > ;Download the SAR file, if needed</code> <code class= source > ldir='~/ominas_data/sar'</code> <code class= source > spawn,'eval echo '+ldir,res</code> <code class= source > ldir=res</code> <code class= source > img=ldir+path_sep()+'BIFQI22N068_D045_T003S01_V02.IMG'</code> <code class= source > if ~file_test(img,/read) then begin</code> <code class= source >   print,'SAR file needed for the demo not found. Downloading it from PDS...'</code> <code class= source >   p=pp_wget('http://pds-imaging.jpl.nasa.gov/data/cassini/cassini_orbiter/CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',localdir=ldir)</code> <code class= source >   p.geturl</code> <code class= source >   print,'ZIP file downloaded, decompressing it...'</code> <code class= source >   file_unzip,ldir+path_sep()+'CORADR_0045/DATA/BIDR/BIFQI22N068_D045_T003S01_V02.ZIP',/verbose</code> <code class= source > endif</code> <code class= source > ;Read the file</code> <code class= source > dd=dat_read(img)</code>    Saturate the data to make the image better looking, since this is just for display    purposes: <code class= source > da=dat_data(dd)</code> <code class= source > dat_set_data,dd,0&gt;da&lt;1d0</code>    Show it a 1/20 resolution: <code class= source > tvim,da,zoom=0.05,/order,/new</code>         Read and display VIMS and ISS files       Set up a hash containing the file names and precomputed pointing offsets: <code class= source > hdxy=hash()</code> <code class= source > hdxy['data/CM_1503358311_1_ir_eg.cub']=[5d0,-1d0]</code> <code class= source > hdxy['data/W1477456695_6.IMG']=[0d0,0d0]</code> <code class= source > files=getenv('OMINAS_DIR')+'/demo/data/'+(hdxy.keys()).toarray()</code> <code class= source > nv = n_elements(files)</code> <code class= source > ddv = dat_read(files)</code> <code class= source > sb=bytarr(nv)</code> <code class= source > for i=0,nv-1 do sb[i]=strmatch(files[i],'*.IMG')</code>      Create an array of global descriptors and populate it: <code class= source > gdv = replicate({cd:obj_new(), gbx:obj_new(), dkx:obj_new(), ltd:obj_new()}, nv)</code> <code class= source > for i=0, nv-1 do gdv[i].cd = pg_get_cameras(ddv[i])</code> <code class= source > for i=0, nv-1 do gdv[i].gbx = pg_get_planets(ddv[i], od=gdv[i].cd, name='TITAN')</code> <code class= source > for i=0, nv-1 do gdv[i].ltd = pg_get_stars(ddv[i], od=gdv[i].cd, name='SUN')</code>      Apply the pointing shifts and compute the limbs: <code class= source > dxy = dblarr(2,nv)</code> <code class= source > limb_psv=objarr(nv)</code> <code class= source > for i=0, nv-1 do dxy[*,i] = hdxy[file_basename(files[i])]</code> <code class= source > for i=0, nv-1 do pg_repoint, dxy[*,i], 0d, gd=gdv[i]</code> <code class= source > for i=0, nv-1 do limb_psv[i] = pg_limb(gd=gdv[i])</code>      Display the VIMS and ISS images: <code class= source > band=70</code> <code class= source > for i=0,1 do begin</code> <code class= source >   zoom=sb[i] ? 1 : 8</code> <code class= source >   offset=sb[i] ? [200d0,200d0] : [-15,-10]</code> <code class= source >   sband=sb[i] ? 0 : band</code> <code class= source >   tvim, (dat_data(ddv[i]))[*,*,sband], $</code> <code class= source >     zoom=zoom,/order, /new,offset=offset,$</code> <code class= source >     xsize=600,ysize=600</code> <code class= source >   pg_draw, limb_psv[i]</code> <code class= source > endfor</code>                     Correct the illumination with a Lambertian function: <code class= source > dd_phtv = objarr(nv)</code> <code class= source > for i=0, nv-1 do dd_phtv[i] = pg_photom(ddv[i], gd=gdv[i], refl_fn='pht_lamb', $</code> <code class= source >   refl_parm=[0.9d], outline=limb_psv[i])</code>    Map images     SAR data is provided in PDS as a map on the target, in an oblique rectangular projection, shown above.    To use it, first we need to obtain the proper map descriptor from the data object: <code class= source > mdr=pg_get_maps(dd)</code>    Now we will display it in an orthogonal projection. First we define it: <code class= source > map_xsize = 1000</code> <code class= source > map_ysize = 1000</code>    Create the new map descriptor: <code class= source > mdp= pg_get_maps(/over,  $</code> <code class= source >   name='TITAN',$</code> <code class= source >   projection='ORTHOGRAPHIC', $</code> <code class= source >   size=[map_xsize,map_ysize], $</code> <code class= source >   origin=[map_xsize,map_ysize]/2, $</code> <code class= source >   center=[0d0,-0.6d0*!dpi])</code>    Now, do the projection of all 3 images: <code class= source > for i=0,nv-1 do dat_set_data,dd_phtv[i],(dat_data(dd_phtv[i]))[*,*,sb[i] ? 0 : band]</code> <code class= source > dd_mapv = objarr(nv)</code> <code class= source > for i=0, nv-1 do dd_mapv[i] = pg_map(dd_phtv[i], md=mdp, gd=gdv[i], aux=['EMM'])</code> <code class= source > dd_map=pg_map(dd,md=mdp,cd=mdr,pc_xsize=500,pc_ysize=500)</code>    Renormalize the data for display, so that all 3 are in the 0-1 range: <code class= source > mds=[dd_map,dd_mapv]</code> <code class= source > for i=0,2 do begin</code> <code class= source >   mdd=dat_data(mds[i])</code> <code class= source >   mddr=minmax(mdd)</code> <code class= source >   dat_set_data,mds[i],(mdd-mddr[0])/(mddr[1]-mddr[0])</code> <code class= source > endfor</code>    Visualize the result as 3 planes in grim: <code class= source > grim,mds,cd=replicate(mdp,3),/new;,overlays=['planet_grid']</code>        ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./multimission_example-batch.html", "multimission_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "multimission_example-batch.pro", "", "", " MULTI-MISSION EXAMPLE    Created by Joe Spitale      This example file loads images from various missions onto planes of a     GRIM window and computes the centers of all available planets for each     image to demonstrates OMINAS' multi-mission capabilities.      This example file can be executed from the shell prompt in the ominas/demo     directory using: <code class= source >ominas multimission_example.pro</code>     or from within an OMINAS IDL session using: <code class= source >@multimission_example.pro</code>    Load the 3 images into grim, with planet centers as overlays: <code class= source > grim, over='center', dat_read(getenv('OMINAS_DIR')+'/demo/data/'+ $</code> <code class= source > ['N1350122987_2.IMG','2100r.img','c3440346.gem'])</code>    The Jupiter observation (from Cassini, the first one displayed in grim)    looks like:         And the Ganymede observation (from Galileo) looks like:         (that image is in the second plane in grim: use the Plane-&gt;next menu     option, or click the black double right-arrow button on the left side     of the top toolbar to switch planes)     And the Saturn observation (from Voyager) looks like:         (that image is in the third plane in grim: use the     Plane-&gt;next menu option, or click the black double right-arrow button on the left     side of the top toolbar to switch planes)  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./override_example-batch.html", "override_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "override_example-batch.pro", "", "", "                            OVERRIDE EXAMPLE    Created by Joe Spitale    This example demonstrates the use of OMINAS with no translators.  All   geometric values are manually entered.  I don't know why you would   want to do this, but it's a useful way to test OMINAS without needing   any translator packages installed.    This example file can be executed from the shell prompt in the ominas/demo   directory using:   	ominas override_example-batch    or from within IDL using:   	@override_example-batch    After the example stops, later code samples in this file may be executed by   pasting them at the IDL command prompt.  READ AND DISPLAY IMAGE  	    DAT_READ is OMINAS' program for reading data files.  It figures out   file readers, sorts out translators (or lack thereof), etc.  It returns   a data descriptor (dd) -- an object containing the data array and a whole   bunch of other stuff, most of which you'll probably never use: <code class= source > dd = dat_read('./data/c3440346.gem', im, label)</code>   TVIM is OMINAS' basic image display program.  It's like WINDOW, except   it sets up the data coordinate system so that all of your points will   display properly: <code class= source > tvim, im, zoom=0.5, /order, /new</code>   OBTAIN GEOMETRY    Here we obtain the objects that describe the geometry of the data set   contained in the data descriptor.  The camera descriptor (cd) contains   the camera position, orientation, and relevant constant parameters.  The   other objects -- planet descriptor (pd) and ring descriptor (rd) --   describe the states of those bodies, as seen from the camera at the   time of the observation.  /OVERRIDE tells the PG_GET_* programs not to   call the translators.  Instead all values are entered manually, like   in the good old days.     Camera descriptor: <code class= source >cd = pg_get_cameras(dd, /override, $</code> <code class= source >       name='VGR1_ISS_NA', $</code> <code class= source >       orient= $</code> <code class= source >            [ [-0.177287575, -0.966450211, -0.185857758 ], $</code> <code class= source >              [ 0.507898045, -0.251604865,  0.823853487 ], $</code> <code class= source >              [ 0.842976092, -0.051662194, -0.535464589 ] ], $</code> <code class= source >       avel=tr([0.0, 0.0, 0.0]), $</code> <code class= source >       pos=tr([0.0, 0.0, 0.0]), $</code> <code class= source >       vel=tr([0.0, 0.0, 0.0]), $</code> <code class= source >       time=972603249.d, $</code> <code class= source >       scale=[7.858656e-06,7.858656e-06], $</code> <code class= source >       oaxis=[499.0,499.0], $</code> <code class= source >       size=[1000,1000], $</code> <code class= source >       fn_focal_to_image='cam_focal_to_image_linear', $</code> <code class= source >       fn_image_to_focal='cam_image_to_focal_linear', $</code> <code class= source >       fi_data=ptr_new() $</code> <code class= source >  )</code>    Planet descriptor: <code class= source >pd = pg_get_planets(dd, od=cd, /override, $</code> <code class= source >       name='SATURN', $</code> <code class= source >       orient= $</code> <code class= source >            [ [-0.254669368,  0.963251789,  0.085378596], $</code> <code class= source >              [-0.962535206, -0.260997177,  0.073528563], $</code> <code class= source >              [ 0.093110093, -0.063454432,  0.993631746] ], $</code> <code class= source >       avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</code> <code class= source >       pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</code> <code class= source >       vel=[ tr([9500.0, 0.0, 0.0]), $</code> <code class= source >             tr([0.0, 0.1, 0.0]) ], $</code> <code class= source >       time=972603249.d, $</code> <code class= source >       radii=[60268000.,60268000.,54364000.], $</code> <code class= source >       lora=0.0 $</code> <code class= source > )</code>    Ring descriptor: <code class= source >rd = pg_get_rings(dd, pd=pd, od=cd, /override, $</code> <code class= source >       name='MAIN_RING_SYSTEM', $</code> <code class= source >       gd={bx0:pd}, $</code> <code class= source >       orient= $</code> <code class= source >            [ [-0.254669368,  0.963251789,  0.085378596], $</code> <code class= source >              [-0.962535206, -0.260997177,  0.073528563], $</code> <code class= source >              [ 0.093110093, -0.063454432,  0.993631746] ], $</code> <code class= source >       avel=tr([0.0854, 0.0732, 0.9937])*1.74e-4, $</code> <code class= source >       pos=tr([-23433172000.0, -6105736000.0, -1223129375.0]), $</code> <code class= source >       vel=[tr([9500.0, 0.0, 0.0]), $</code> <code class= source >            tr([0.0, 0.1, 0.0]) ] , $</code> <code class= source >       time=972603249.d, $</code> <code class= source >       sma=tr([75000000.0,136800000.0]), $</code> <code class= source >       ecc=tr([0.0, 0.0]) $</code> <code class= source > )</code>    Star descriptor: <code class= source >ltd = pg_get_stars(dd, od=cd, /override, $</code> <code class= source >       name='SUN', $</code> <code class= source >       pos=tr([1.421392d12,4.3105676d10,-4.3613585d10]) $</code> <code class= source >  )</code>  -   MAKE A GENERIC DESCRIPTOR    At this level, a generic descriptor is just a convenient shorthand   to keep all of your object descriptors together.  All PG programs   accept individual descriptor as well as generic descriptors as   arguments.  GBX means any subclass of GLOBE, DKX means any SUBCLASS   of DSK.  These are arguments to the PG programs that we'll be working   with: <code class= source > gd = {cd:cd, gbx:pd, dkx:rd, ltd:ltd}</code>   Here are a couple of tips regarding generic descriptors:     1) I never use them like this.     2) They are nevertheless a handy way to keep the full geometry of a       scene in one place, and they're used all over the place way down in       the core.   COMPUTE OVERLAY ARRAYS    Here we compute various overlays using some PG programs.  The overlay   arrays are contained in POINT objects; limb_ptd, ring_ptd, etc.  Note   that the generic descriptor does not always contain enough information   to get the job done.  PG_CENTER requires an explicit bx (arbitrary body)   argument to tell it which of the bodies in gd are intended.  PG_HIDE   hide the given points with respect to whatever bodies you give it: <code class= source > limb_ptd = pg_limb(gd=gd, count=nlimb) & pg_hide, limb_ptd, gd=gd</code> <code class= source > ring_ptd = pg_disk(gd=gd, count=nring) & pg_hide, ring_ptd, gd=gd</code> <code class= source > shadow_ptd = pg_shadow_globe(gd=gd, ring_ptd)</code> <code class= source > center_ptd = pg_center(gd=gd, bx=pd)</code>   PUT THE OVERLAYS IN ONE ARRAY    I seriously never do things this way, but I guess it illustrates various   ways to use the software.  We're putting all of the POINT objects into   one array, and making corresponding arrays for the colors, plotting   symbols, etc.    The CT programs are used to get color indices for some basic colors   without having to know what type of visual class you're using: <code class= source > object_ptd = [center_ptd,limb_ptd,ring_ptd,shadow_ptd]</code> <code class= source > colors = [!p.color,ctyellow(),ctred(),ctred(),ctblue()]</code> <code class= source > psyms=[1,3,3,3,3]</code> <code class= source > psizes=[0.5]</code> <code class= source > plabels = [cor_name(pd), '', '']</code>   DRAW EVERYTHING  	    PG_DRAW is the basic program for drawing overlays in OMINAS.  It does   the same thing as PLOTS (which you could use instead), but it accepts   POINT objects are arguments and allows you to use specify multiple colors   symbols, etc.  PG_DRAW also accepts raw points arrays (i.e. 2 x np): <code class= source > pg_draw, object_ptd, $</code> <code class= source >             colors=colors, psyms=psyms, psizes=psizes, plabel=plabels</code>   MAKE IT OFFICIAL BY ADDING GRIDS  	    PG_GRID will put a grid on just about anything.  At least anything   with a surface described by two angle-like coordinates: a planet, a map,   the sky, a disk (in that case, the radius is one of the coordinates), etc.   Those kinds of coordinate systems are referred to as surface coordinate   systems in OMINAS.  Because their representations are analogous, their   corresponding objects can be pretty much interchanged all over the place.   This is such a place.  On that topic, coordinate systems using image   points (i.e., CAMERA and MAP image systems) are similarly interchangeable: <code class= source > grid_ptd = pg_grid(gd=gd, bx=pd)</code> <code class= source >    pg_hide, grid_ptd, gd=gd, bx=pd, /assoc</code> <code class= source >    pg_hide, grid_ptd, gd=gd, bx=rd</code> <code class= source > pg_draw, grid_ptd, color=ctblue()</code>  <code class= source >dgrid_ptd = pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</code> <code class= source >pg_draw, dgrid_ptd, color=ctpurple()</code>   DEFINE A RING SECTOR    Let's define a sector so we can make a plot of intensity vs. radius   or longitude.  First, we'll specify the longitude and radius limits   explicitly.  Note that we're working in meters here because all of our   inputs for the descriptors were in meters.  Units in OMINAS are   determined by the translators.  Of course, all angles are in radians: <code class= source > lon = [175,177] * !dpi/180d</code> <code class= source > rad = [65000,138000] * 1000d</code> <code class= source > tvim,im</code> <code class= source > outline_ptd = pg_ring_sector(gd=gd, rad=rad, lon=lon)</code> <code class= source > pg_draw, outline_ptd, col=ctgreen()</code>   MANUALLY DEFINE A RING SECTOR    You can also define the ring sector using the mouse.  Just leave out   the bounds in the call to PG_RING_SECTOR.  Have we fixed that thing   where the sector wraps around wrong?  You'd think so by now: <code class= source > tvim,im</code> <code class= source > outline_ptd = pg_ring_sector(gd=gd)</code> <code class= source > pg_draw, outline_ptd, col=ctgreen()</code>        PLOT INTENSITY VS. RADIUS AND LONGITUDE    The POINT object returned by PG_RING_SECTOR can be used as an input   to PG_PROFILE_RING to produce radial and azimuthal profiles.   PG_PROFILE_RING returns a data descriptor containing the plot.  It   also outputs the profile itself and the disk coordinates of each point   in the profile so you don't have to dereference the data descriptor.    Radial scan: <code class= source > dd_prof = pg_profile_ring(dd, gd=gd, outline_ptd, $</code> <code class= source >  dsk_pts=dsk_pts, profile=profile)</code> <code class= source > window, /free, xs=500, ys=300</code> <code class= source > plot, dsk_pts[*,0], profile</code>        Azimuthal scan: <code class= source > dd_prof = pg_profile_ring(dd, gd=gd, outline_ptd, /azimuthal, $</code> <code class= source >  dsk_pts=dsk_pts, profile=profile)</code> <code class= source > window, /free, xs=500, ys=300</code> <code class= source > plot, dsk_pts[*,1], profile, /yno</code>       ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./pg_example-batch.html", "pg_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "pg_example-batch.pro", "", "", "                              PG EXAMPLE    Created by Joe Spitale   Edited by Mark Moretto for manual     This example demonstrates various capabilities of the PG programming    interface, OMINAS' command-line API.     This example file can be executed from the shell prompt in the ominas/demo    directory using: <code class= source > ominas pg_example-batch</code>  <code class= source >or from within an OMINAS IDL session using:</code> <code class= source >@pg_example-batch</code>     After the example stops, later code samples in this file may be executed by     pasting them onto the IDL command line.   READ AND DISPLAY IMAGE        Use DAT_READ to read the image and then display the image using TVIM.    With DAT_READ, it is not necessary to specify the file format.  DAT_READ    uses your file type detectors to determine the format, and gets the    appropriate reader from your I/O table.  DAT_READ returns a data    descriptor (dd), which contains all of the data associated with the file.    For convenience, it also returns the data array (im) and header (label)    in its second and third arguments.     TVIM is called to display the image (im) in a new window with the y    coordinate as top-down: <code class= source > dd = dat_read('./demo/data/N1350122987_2.IMG', im, label)</code> <code class= source > tvim, im, zoom=0.75, /order, /new</code>   OBTAIN GEOMETRY     This section obtains the geometric information describing the scene.    Note that there is no reference to the source of the this information.    That is handled by the translator system, which is controlled by    a series of translators tables telling OMINAS which translators to use    for a given instrument.  The translators tables are parsed by DAT_READ,    which stores the list of translators in the data descriptor.     If you are using the default demo configuration, then the geometry    data are obtained via the NAIF/SPICE translator package and the detached    header package.  The NAIF/SPICE translators use database files    provided by NAIF or by individual projects.  The detached header    translators read and write geometry descriptors in a text-based file    that resides in the same directory as the data file and has the    extension '.dh'.  Because the detached header translator dh_std_input    appears before the Cassini Spice input translator in the default    translators table, the descriptors are taken from the detached header    if it exists, and if the relevant descriptors are present.  Otherwise,    they are obtained from the SPICE kernels: <code class= source > cd = pg_get_cameras(dd)                        ; CAMERA descriptor</code> <code class= source > pd = pg_get_planets(dd, od=cd, count=npd)      ; PLANET descriptor(s)</code> <code class= source > rd = pg_get_rings(dd, pd=pd, od=cd, count=nrd) ; RING descriptor(s)</code> <code class= source > ltd = pg_get_stars(dd, od=cd, name='SUN')     ; STAR descriptor for Sun</code>    The calls to PG_GET_PLANETS, PG_GET_RINGS, and PG_GET_STARS include    an observer descriptor, od.  Without this, it would not be possible    to perform aberration corrections on the returned objects.  In that    case, the returned descriptors would represent the real states of the    bodies at the time of observation at their respective positions rather    than from the point of view of the observer:    Note the 'name' keyword in the call to PG_GET_STARS. This is a CORE    attribute, so it may be applied to any body.  For example, if you are    only interested in Jupiter and the Galilean satellites, you could    write: <code class= source > pd = pg_get_planets(dd, od=cd, $</code> <code class= source >          name=['JUPITER', 'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO'])</code>    Instead, we just search the returned descriptors for the on named    'JUPITER': <code class= source > ii = where(cor_name(pd) EQ 'JUPITER')</code>   INSTRUMENT-SPECIFIC USAGE     It is possible to communicate directly with the translators from the    PG API via the use of translator keywords.  Translator keywords are    keyword=value strings that are passed directly to the translator system    with no interpretation by OMINAS.  They may be permanently coded in    the translators table to be passed to a specific translator, or    transient inputs may be provided to the PG_GET_* programs as a string    argument.  In the latter case, they are accessible to all translators    pertaining to that PG_GET_* program and they precede translator keywords    from the translators table.     Here are some examples of controlling the NAIF/SPICE interface in a    call to PG_GET_CAMERAS: <code class= source > cd = pg_get_cameras(dd, 'klist=my_klist.txt')     ; Use personal kernel</code> <code class= source >                                                   ; list file.</code>  <code class= source > cd = pg_get_cameras(dd, 'ck_in=./test.bc')        ; Use a specified C kernel.</code>  <code class= source > cd = pg_get_cameras(dd, 'ck_in=./auto')           ; Use the C-kernel auto-</code> <code class= source >                                                   ; detect function.</code>  <code class= source > cd = pg_get_cameras(dd, 'klist=my_klist.txt, $    ; Multiple arguments</code> <code class= source >                          ck_in=test.bc;test1.bc') ; separated by commas;</code> <code class= source >                                                   ; multiple elements</code> <code class= source >                                                   ; separated by semicolons.</code>   MAKE A GENERIC DESCRIPTOR     Here we go with the generic descriptors again.  The story with these    things is that long ago before GRIM was summoned from the lowest levels    of heck, OMINAS (or MINAS, or NV) was purely command-based.  That's    what you want because you can always build a GUI on top of it, but    it doesn't really work to start with a graphical tool and try to    build a command-based system out of that.  Therefore, I decided to have    mercy on the poor jerks (mostly me up to now) who had to type (really    paste) all of this nonsense in.  The generic descriptor was therefore    spawned as a way to cut down on all the cd=this, pd=that, bx=whatever    that tends to go on.  So we just shove it all into one structure and    all of the PG programs know to look in there if one is given.  Any    explicit descriptor arguments take precedence, though.  So if these    things make you happy, then you're welcome.  I rarely use them in this    way.  They live on because it turns out they have amazing utility in    other ways.  So anyway, it's like this: <code class= source > gd = {cd:cd, gbx:pd, dkx:rd, ltd:ltd}</code>   COMPUTE OVERLAY ARRAYS     These commands compute the center, limb, and terminator of each planet,    as well as the edges of the rings.  Note that the terminator is computed    using PG_LIMB with the Sun as the observer: <code class= source > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</code> <code class= source >           pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=ltd</code> <code class= source > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</code> <code class= source > term_ptd = pg_limb(gd=gd, od=gd.ltd) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</code> <code class= source > center_ptd = pg_center(gd=gd, bx=pd)</code>   SET UP FOR PLOTTING    This just makes the calls to PG_DRAW a little easier, since they will   need to be repeated every time we change things and recompute.  We put   all of the POINT descriptors in one array and then make corresponding   arrays for the plot parameters: <code class= source > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</code> <code class= source > colors=[make_array(npd,value=!p.color), $</code> <code class= source >         make_array(npd,value=ctyellow()), $</code> <code class= source >         make_array(2*nrd,value=ctred()), $</code> <code class= source >         make_array(npd,value=ctgreen())]</code> <code class= source > psyms=[make_array(npd,value=1), $</code> <code class= source >        make_array(npd,value=3), $</code> <code class= source >        make_array(2*nrd,value=3), $</code> <code class= source >        make_array(npd,value=3)]</code> <code class= source > psizes=1.0</code> <code class= source > csizes=0.75</code> <code class= source > plabels=[cor_name(pd), $</code> <code class= source >         make_array(npd,value=''), $</code> <code class= source >         make_array(2*nrd,value=''), $</code> <code class= source >         make_array(npd,value='')]</code>   DRAW EVERYTHING      Now we can do a nice simple call to PG_DRAW to draw everything: <code class= source >   pg_draw, object_ptd, $</code> <code class= source >             col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</code>   FIRST-CUT AUTOMATIC REPOINTING     Refine the pointing of the spacecraft by using PG_FARFIT, which searches    the image for a pattern matching the edges calculated using the    geometry descriptors.  First scan the images for edges, ignoring the    a 10-pixel zone at the edge of the image: <code class= source > edge_ptd = pg_edges(dd, edge=10)</code> <code class= source > pg_draw, edge_ptd</code>          Next, use PG_FARFIT to find the x/y offset that best matches the limb of    Jupiter (planet index ii): <code class= source > dxy = pg_farfit(dd, edge_ptd, [limb_ptd[ii]])</code>    BTW, you have been duped.  PG_FARFIT fails a lot because the search    is pretty sparse.  I cherry-picked an image that usually works pretty    well.  The sparse search makes PG_FARFIT pretty fast, though.  Ok,    now repoint using the farfit solution: <code class= source > pg_repoint, dxy, gd=gd</code>    Now that the camera pointing has changed, everything has to be recomputed,    just like before:  <code class= source >limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</code> <code class= source >       pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=ltd</code> <code class= source >ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</code> <code class= source >center_ptd = pg_center(gd=gd, bx=pd)</code> <code class= source >term_ptd = pg_limb(gd=gd, od=gd.ltd) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</code> <code class= source >object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</code>    And now we can see the result:      tvim, im     pg_draw, object_ptd, $                 colors=colors, psyms=psyms, psizes=psizes, plabel=plabels         MANUALLY REPOINT THE GEOMETRY     If you have a little time, you can just drag the pointing around    by hand.  We just need to get it close enough to really nail down in    the next section.  There's a good chance PG_FARFIT really dropped    the ball on the last step anyway.  Just paste this in and follow    the directions: <code class= source >tvim, im</code> <code class= source >dxy = pg_drag(object_ptd, dtheta=dtheta, axis=center_ptd[ii])</code>    Like PG_FARFIT, PG_DRAG returns an x/y offset that can be input to    PG_REPOINT, but it also returns a twist offset, so we need to input    that and an axis to PG_REPOINT: <code class= source >pg_repoint, dxy, dtheta, axis=center_ptd[ii], gd=gd</code>    And now you have to recompute and redraw again.  It's the same as    above.  Please don't make me write it out.   PRECISE EDGE SCAN     Not satisfied with PG_FARFIT?  I wouldn't be, it's just not a sub-pixel    kind of thing.  Sometimes its results can be very super-pixel.  However,    once we get within a few tens of pixels of the correct pointing, we can    use PG_CVSCAN to pick up the edges with a more rigorous algorithm.    PG_CVSCAN scans around a predicted edge (in this case Jupiter's limb)    comparing the brightness profile with a model profile.  In this case,    we use the limb edge model developed by Gary Yagi and used in the old    VICAR NAV program (Ugh, remember VICAR?  That's kind of the whole reason    we're doing any of this).  Indeed this whole CVSCAN business is the same    exact algorithm that Andy Ingersoll scribbled down on a piece of paper    sometime in the 1980s, just gussied up and vectorized with a bunch of    pg_this and gd_that and all manner of other whatnot.     Anyway, here we are staying 30 pixels from the image edge, and scanning    with a width of 80 pixels.  lzero and mzero are coordinating the    zero pointing of the model: <code class= source >cvscan_ptd=pg_cvscan(dd, gd=gd, limb_ptd[ii], edge=30, width=80, $</code> <code class= source >   model=[make_array(npd,val=ptr_new(edge_model_nav_limb(zero=lzero)))], $</code> <code class= source >   mzero=[make_array(npd,val=lzero)] )</code>    And then we draw the points: <code class= source >tvim, im</code> <code class= source >pg_draw, cvscan_ptd</code>         THRESHOLD ON CORRELATION COEFFICIENT     This section calls pg_threshold to remove points with unacceptable    correlation coefficients.  The /relative flag means that the minimum    and maximum thresholds are taken as a fraction of the maximum    correlation coefficient for each set of points. In this case we use    a minimum correlation coefficient of 0.81 and a maximum of 1.0: <code class= source > pg_threshold, cvscan_ptd, min=0.81, max=1.0, /rel</code> <code class= source > tvim, im</code> <code class= source > pg_draw, cvscan_ptd</code>   MANUALLY EDIT THE SCANNED POINTS     PG_SELECT is used to manually remove points within a polygonal region    defined by the cursor.  PG_TRIM removes the points in the defined    region: <code class= source > region = pg_select(dd)</code> <code class= source > pg_trim, dd, cvscan_ptd, region</code> <code class= source > tvim, im</code> <code class= source > pg_draw, cvscan_ptd</code>   SUB-PIXEL POINTING CORRECTION     PG_CVSCAN_COEFF determines the linear least-squares coefficients for a    fit to the image coordinate translation and rotation that matches the    computed curve to the scanned curve.  PG_FIT uses the resulting    coefficients to calculate the corrections.  In this case, we fix    the rotation offset (fix=2) because the limb gives little leverage on    that parameter: <code class= source >cvscan_cf = pg_cvscan_coeff(cvscan_ptd, fix=2)</code> <code class= source >dxy = pg_fit(cvscan_cf)</code>    The reason that these two programs are separate is that a simultaneous    fit can be performed by simply adding all of the linear coefficients.    If PG_FIT is given an array of coefficient structures, it will add them    before performing the fit, so, for example, you could compute coefficients    to fit stars in the image (using PG_PTSCAN), and include them in the    call to PG_FIT to get a simultaneous fit to the stars and the limb.     Once again, you need to recompute and redraw to see the new pointing:        FIT STATISTICS     You can get the statistics using PG_CHISQ and PG_COVARIANCE: <code class= source >chisq = pg_chisq(dxy, 0, cvscan_ptd, fix=2)</code> <code class= source >covar = pg_covariance(cvscan_cf)</code> <code class= source >print, dxy, dtheta*180./!pi, chisq, covar</code>   PLANET AND RING LATITUDE/LONGITUDE GRID        This section calculates a latitude/longitude grid for each planet and a    radius/longitude grid for the rings.  By default it draws 12 latitude    and 12 longitude grid lines.  The longitude grid lines circle the body    and so on a map they will appear as 24 grid lines.  The ring radius grid    uses four grid lines by default between the inner and outer ring radius.    It uses PG_HIDE to set as not visible the points on the grid behind the    planet and ring for both objects.  It then uses PG_DRAW to draw the    grid points in blue (ctblue): <code class= source > grid_ptd = pg_grid(gd=gd, lat=lat, lon=lon)</code> <code class= source > pg_hide, grid_ptd, cd=cd, bx=pd, /assoc</code> <code class= source > pg_hide, grid_ptd, cd=cd, bx=pd, od=ltd, /assoc</code> <code class= source > pg_hide, grid_ptd, gd=gd, bx=rd</code> <code class= source > pg_draw, grid_ptd, color=ctblue()</code>  <code class= source > plat_ptd = pg_grid(gd=gd, slon=!dpi/2d, lat=lat, nlon=0)</code> <code class= source > pg_hide, plat_ptd[ii], cd=cd, bx=pd[ii], /, bx=pd</code> <code class= source > pg_draw, plat_ptd[ii], psym=3, plabel=strtrim(round(lat*180d/!dpi),2), /label_p</code>  <code class= source > plon_ptd = pg_grid(gd=gd, slat=0d, lon=lon, nlat=0)</code> <code class= source > pg_hide, plon_ptd[ii], cd=cd, bx=pd[ii], /assoc</code> <code class= source > pg_draw, plon_ptd[ii], psym=3, plabel=strtrim(round(lon*180d/!dpi),2), /label_p</code>  <code class= source > dgrid_ptd=pg_grid(gd=gd, bx=rd) & pg_hide, dgrid_ptd, gd=gd, bx=pd</code> <code class= source > pg_draw, dgrid_ptd, color=ctpurple()</code>   MAP DESCRIPTORS     PG_GET_MAPS is used to define map descriptors for various projections.    Paste the one you want:  <code class= source >Rectangular:</code> <code class= source > md = pg_get_maps(/over, bx=pd[ii], $</code> <code class= source >        projection='RECTANGULAR', $</code> <code class= source >        /map_graphic,</code> <code class= source >        size=[400,200])</code>            Orthographic: <code class= source >  md = pg_get_maps(/over, bx=pd[ii], $</code> <code class= source >        projection='ORTHOGRAPHIC', $</code> <code class= source >        size=[400,400], $</code> <code class= source >        center=[!dpi/6d,!dpi])</code>            Stereographic: <code class= source >  md = pg_get_maps(/over, bx=pd[ii], $</code> <code class= source >         projection='STEREOGRAPHIC', $</code> <code class= source >         scale=0.5, $</code> <code class= source >         size=[400,400], center=[!dpi/2d,0d])</code>            Mercator: <code class= source >  md = pg_get_maps(/over, bx=pd[ii], $</code> <code class= source >        projection='MERCATOR', $</code> <code class= source >         size=[400,200])</code>          MAP PROJECTIONS     PG_MAP creates a map projection and returns it in a data descriptor.    The map is also returned a a keyword for convenience: <code class= source > dd_map = pg_map(dd, md=md, gd=gd, bx=pd[ii], map=map)</code> <code class= source > tvim, /new, map</code>      You could bound the map like this: <code class= source > dd_map = pg_map(dd, md=md, gd=gd, bx=pd[ii], map=map, $</code> <code class= source >                  bounds=bounds = [-30,30,-180,180]*!dpi/180d)</code>     Or exclude the areas covered by the rings: <code class= source > dd_map = pg_map(dd, md=md, gd=gd, bx=pd[ii], gbx=pd[ii], $</code> <code class= source >                    hide_fn='pm_hide_ring', hide_bx=rd, map=map)</code>   PUT A GRID ON IT     PG_GRID computes a latitude/longitude grid.  This is the same program    used in other examples to draw grids on other things; here we're    using a map descriptor instead of a camera descriptor.     First, define a new generic descriptor.  : <code class= source > gdm={cd:md, od:cd, gbx:pd[ii], dkx:rd}</code>  <code class= source > map_grid_ptd = pg_grid(gd=gdm, lat=lat, lon=lon)</code> <code class= source > plat_ptd = pg_grid(gd=gdm, slon=!dpi/2d, lat=lat, nlon=0)</code> <code class= source > plon_ptd = pg_grid(gd=gdm, slat=0d, lon=lon, nlat=0)</code>  <code class= source > pg_draw, map_grid_ptd, col=ctgreen()</code> <code class= source > pg_draw, plat_ptd, psym=7, plabel=strmid(strtrim(lat*180d/!dpi,2),0,3), /label_p</code> <code class= source > pg_draw, plon_ptd, psym=7, plabel=strmid(strtrim(lon*180d/!dpi,2),0,3), /label_p</code>   OBSERVATION-SPECIFIC OVERLAYS     Use PG_LIMB to compute a limb and a terminator by specifying an    observer descriptor: <code class= source >map_limb_ptd = pg_limb(gd=gdm, od=cd)</code> <code class= source >map_term_ptd = pg_limb(gd=gdm, od=ltd)</code>  <code class= source >pg_draw, map_limb_ptd, col=ctred()</code> <code class= source >pg_draw, map_term_ptd, col=ctyellow()</code>   MAP-TO-MAP PROJECTION     A map can be reprojected using a second map descriptor with the    original map descriptor in place of the camera descriptor: <code class= source > md1 = pg_get_maps(/over, bx=pd[ii], $</code> <code class= source >    projection='ORTHOGRAPHIC', $</code> <code class= source >    size=[400,400], $</code> <code class= source >    center=[!dpi/6d,!dpi])</code>  <code class= source > dd_map1 = pg_map(dd_map, md=md1, cd=md, map=map1)</code> <code class= source > tvim, /new, map1</code>       OUTPUT DESCRIPTORS     These commands write the descriptor information out through the    translators.  The exact behavior is translator-dependent.  In the default    configuration, the detached header translator modifies the detached header    stored in the data descriptor.  It is not written until DAT_WRITE is called: <code class= source > pg_put_rings, dd, od=cd, rd=rd</code> <code class= source > pg_put_planets, dd, od=cd, pd=pd[0]</code> <code class= source > pg_put_cameras, dd, cd=cd</code> <code class= source > pg_put_stars, dd, sd=ltd, od=cd</code>     The detached head may be viewed using: <code class= source > print, transpose(dat_dh(dd))</code>    If using the NAIF/SPICE translator, a C kernel may be written by    specifying a file name using the ck_out translator keyword.  A comment    can be included in the output kernel by making a user data value    named  CK_COMMENT : <code class= source > cor_set_udata, cd, 'CK_COMMENT', 'This is a comment.'</code> <code class= source > pg_put_cameras, dd, cd=cd, 'ck_out=./outputs/test.bc'</code>   WRITE DATA FILE     DAT_WRITE writes the data array in the data descriptor using whatever    output function was given in the I/O table.  The detached header is    is also written into a file with the same name as the image file except    with the extension '.dh'.  If this file does not already exist, it is    created: <code class= source > dat_write, './outputs/' + cor_name(dd), dd</code>   WRITE MAP FILE     PG_PUT_MAPS causes the detached header translator to generate a new    detached header and write the map descriptor into it.     As above, DAT_WRITE writes the map image file and the detached header.    Notice that the file type is given explicitly because the data descriptor    was not created by DAT_READ, which would have detected the file type: <code class= source > pg_put_maps, dd_map, md=md</code> <code class= source > dat_write, './outputs/' + cor_name(dd) + '.map', dd_map, filetype = 'VICAR'</code>    To read the new map file, use DAT_READ just as the image file was read at    the beginning of this example script.  To read the map descriptor from the    detached header, use PG_GET_MAPS: <code class= source > dd_map = dat_read(./outputs/&lt;nme&gt;.map', map)</code> <code class= source > md = pg_get_maps(dd_map)</code> <code class= source > tvim, /new, map</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./predict_example-batch.html", "predict_example-batch.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "predict_example-batch.pro", "", "", "                            PREDICT EXAMPLE    Created by Joe Spitale    This example script demonstrates the usage of OMINAS with no data.  Instead   of reading a data file using DAT_READ, the geometry is tied to a set of   observation times.    This example file can be executed from the shell prompt in the ominas/demo   directory using:   	ominas predict_example-batch    or from within IDL using:   	@predict_example-batch  OBSERVATION PARAMETERS    Here we set basic parameters of the observation; start and stop times,   number of time steps, name of instrument.  Note that the times could also   be given numerically.  The interpretation of the times is performed by   the translators (see next step): <code class= source >  instrument = 'CAS_ISS_NA'</code> <code class= source >  times = ['2016-028T03:42:00','2016-028T15:37:00']</code> <code class= source >  nt = 5</code>   GET CAMERA POSITIONS    Camera descriptors are obtained for the start and stop times in order   to convert the time strings in to numeric times.  The full set of camera   descriptors is then obtained by interpolating the numeric start and   stop times.  We could also just give all the times, either as strings, or   numerically.  Note that, because there is no data descriptor, the second   call to PG_GET_CAMERAS creates one and returns it in the first argument: <code class= source >  cds = pg_get_cameras(instrument=instrument, time=times)</code> <code class= source >  t_start = bod_time(cds[0])</code> <code class= source >  t_stop = bod_time(cds[1])</code>  <code class= source >  t = (dindgen(nt)/(nt-1) * (t_stop - t_start)) + t_start</code> <code class= source >  cd = pg_get_cameras(dd, instrument=instrument, time=t)</code>   SET CAMERA POINTING    If left alone, the camera pointing will be whatever was returned by the   translators.  Here we force the cameras to point at the center of Saturn   (with the camera Y vector pointed to celestial north) by inputting the   S/C -- Saturn vectors to PG_REPOINT.  Note the use of the data descriptor   created by PG_GET_CAMERAS: <code class= source >  pd0 = pg_get_planets(dd, od=cd, name='SATURN')</code> <code class= source >  pg_repoint, cd=cd, bod_pos(pd0)-bod_pos(cd), /north</code>   VIEW PREDICT SCENES WITH GRIM    We input the camera descriptors to GRIM, but let it compute all other   descriptors.  Planets are computed within 1 AU of the camera.  The   initial view is set to encompass the rings: <code class= source >  grim, dd, cd=cd, order=1, /activate, plt_distmax=const_get('AU'), $</code> <code class= source >         over=['center', $</code> <code class= source >               'limb:SATURN', $</code> <code class= source >               'terminator:SATURN', $</code> <code class= source >               'planet_grid:SATURN', $</code> <code class= source >               'ring'], frame='ring'</code>                        COMPUTE FOOTPRINTS    Here is some code to compute a footprint for the current camera   pointing and graft it into GRIM.  To compute additional footprints, use   GRIM's navigate mode to change the pointing and then paste the lines   again: <code class= source >  grift, cd=cd, pd=pd, rd=rd</code> <code class= source >  footprint_ptd = pg_footprint(cd=cd, bx=[pd,rd])</code> <code class= source >  graft, footprint_ptd, name='FP-'+strtrim(counter(),2)</code>       ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("./w10n_pds_example.html", "w10n_pds_example.pro", '.pro file in <a href="./dir-overview.html">./ directory</a>', "w10n_pds_example.pro", "", "", "                              W10N_PDS EXAMPLE    Created by Vance Haemmerle from PG example     This example demonstrates various capabilities of W10N_PDS reading    it gets the same image as the PG example but gets it from the PDS imaging website     This example file can be executed from the shell prompt in the ominas/demo    directory using: <code class= source > ominas w10n_pds_example.pro &lt;--cas&gt; &lt;--vgr&gt; &lt;--gll&gt; &lt;mission=={cas|vgr|gll}&gt;</code>  <code class= source >or from within an OMINAS IDL session using:</code> <code class= source >@w10n_pds_example</code>  READ AND DISPLAY IMAGE     Missions supported CASSINI ISS, VGR ISS, GLL SSI     Use DAT_READ to read the image and then display the image using TVIM.    With DAT_READ, it is not necessary to specify the file format.  DAT_READ    uses your file type detectors to determine the format, and gets the    appropriate reader from your I/O table.  DAT_READ returns a data    descriptor (dd), which contains all of the data associated with the file.    For convenience, it also returns the data array (im) and header (label)    in its second and third arguments.     TVIM is called to display the image (im) in a new window with the y    coordinate as top-down: <code class= source > url = 'https://pds-imaging.jpl.nasa.gov/w10n/cassini/cassini_orbiter/coiss_1001/data/1350045294_1350147054/N1350122987_2.IMG'</code> <code class= source > dd = dat_read(url, im, label)</code> <code class= source > tvim, im, zoom=0.75, /order, /new</code>   OBTAIN GEOMETRY     This section obtains the geometric information describing the scene.    Note that there is no reference to the source of the this information.    That is handled by the translator system, which is controlled by    a series of translators tables telling OMINAS which translators to use    for a given instrument.  The translators tables are parsed by DAT_READ,    which stores the list of translators in the data descriptor.     If you are using the default demo configuration, then the geometry    data are obtained via the NAIF/SPICE translator package and the detached    header package.  The NAIF/SPICE translators use database files    provided by NAIF or by individual projects.  The detached header    translators read and write geometry descriptors in a text-based file    that resides in the same directory as the data file and has the    extension '.dh'.  Because the detached header translator dh_std_input    appears before the Cassini Spice input translator in the default    translators table, the descriptors are taken from the detached header    if it exists, and if the relevant descriptors are present.  Otherwise,    they are obtained from the SPICE kernels: <code class= source > cd = pg_get_cameras(dd)                        ; CAMERA descriptor</code> <code class= source > pd = pg_get_planets(dd, od=cd, count=npd)      ; PLANET descriptor(s)</code> <code class= source > rd = pg_get_rings(dd, pd=pd, od=cd, count=nrd) ; RING descriptor(s)</code> <code class= source > ltd = pg_get_stars(dd, od=cd, name='SUN')     ; STAR descriptor for Sun</code>    The calls to PG_GET_PLANETS, PG_GET_RINGS, and PG_GET_STARS include    an observer descriptor, od.  Without this, it would not be possible    to perform aberration corrections on the returned objects.  In that    case, the returned descriptors would represent the real states of the    bodies at the time of observation at their respective positions rather    than from the point of view of the observer:    Note the 'name' keyword in the call to PG_GET_STARS. This is a CORE    attribute, so it may be applied to any body.  For example, if you are    only interested in Jupiter and the Galilean satellites, you could    write: <code class= source > pd = pg_get_planets(dd, od=cd, $</code> <code class= source >          name=['JUPITER', 'IO', 'EUROPA', 'GANYMEDE', 'CALLISTO'])</code>    Instead, we just search the returned descriptors for the on named    'JUPITER': <code class= source > ii = where(cor_name(pd) EQ 'JUPITER')</code>   MAKE A GENERIC DESCRIPTOR     Here we go with the generic descriptors again.  The story with these    things is that long ago before GRIM was summoned from the lowest levels    of heck, OMINAS (or MINAS, or NV) was purely command-based.  That's    what you want because you can always build a GUI on top of it, but    it doesn't really work to start with a graphical tool and try to    build a command-based system out of that.  Therefore, I decided to have    mercy on the poor jerks (mostly me up to now) who had to type (really    paste) all of this nonsense in.  The generic descriptor was therefore    spawned as a way to cut down on all the cd=this, pd=that, bx=whatever    that tends to go on.  So we just shove it all into one structure and    all of the PG programs know to look in there if one is given.  Any    explicit descriptor arguments take precedence, though.  So if these    things make you happy, then you're welcome.  I rarely use them in this    way.  They live on because it turns out they have amazing utility in    other ways.  So anyway, it's like this: <code class= source > gd = {cd:cd, gbx:pd, dkx:rd, ltd:ltd}</code>   COMPUTE OVERLAY ARRAYS     These commands compute the center, limb, and terminator of each planet,    as well as the edges of the rings.  Note that the terminator is computed    using PG_LIMB with the Sun as the observer: <code class= source > limb_ptd = pg_limb(gd=gd) & pg_hide, limb_ptd, gd=gd, bx=rd, /rm</code> <code class= source >           pg_hide, limb_ptd, /assoc, gd=gd, bx=pd, od=ltd</code> <code class= source > ring_ptd = pg_disk(gd=gd) & pg_hide, ring_ptd, gd=gd, bx=pd</code> <code class= source > term_ptd = pg_limb(gd=gd, od=gd.ltd) & pg_hide, term_ptd, gd=gd, bx=pd, /assoc</code> <code class= source > center_ptd = pg_center(gd=gd, bx=pd)</code>   SET UP FOR PLOTTING    This just makes the calls to PG_DRAW a little easier, since they will   need to be repeated every time we change things and recompute.  We put   all of the POINT descriptors in one array and then make corresponding   arrays for the plot parameters: <code class= source > object_ptd = [center_ptd,limb_ptd,ring_ptd,term_ptd]</code> <code class= source > colors=[make_array(npd,value=!p.color), $</code> <code class= source >         make_array(npd,value=ctyellow()), $</code> <code class= source >         make_array(2*nrd,value=ctred()), $</code> <code class= source >         make_array(npd,value=ctgreen())]</code> <code class= source > psyms=[make_array(npd,value=1), $</code> <code class= source >        make_array(npd,value=3), $</code> <code class= source >        make_array(2*nrd,value=3), $</code> <code class= source >        make_array(npd,value=3)]</code> <code class= source > psizes=1.0</code> <code class= source > csizes=0.75</code> <code class= source > plabels=[cor_name(pd), $</code> <code class= source >         make_array(npd,value=''), $</code> <code class= source >         make_array(2*nrd,value=''), $</code> <code class= source >         make_array(npd,value='')]</code>   DRAW EVERYTHING   Cassini result:      Now we can do a nice simple call to PG_DRAW to draw everything: <code class= source >   pg_draw, object_ptd, $</code> <code class= source >             col=colors, psy=psyms, psi=psizes, csi=csizes, pl=plabels</code>  Voyager image:      Galileo result:      ", "", "          -1", "");
  

