/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "OMINAS Documentation";
subtitle = "Generated by IDLdoc";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("obj/tools/abcorr.html", "abcorr.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "abcorr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/abcorr.html#abcorr", "abcorr", 'routine in <a href="obj/tools/abcorr.html">abcorr.pro</a>', "abcorr.pro", "", "abcorr", "<code class= source >	Performs stellar aberration and light-travel-time corrections.</code>  ", "citerateepsilonfastinvertobs_bx<code class= source >  Any subclass of BODY describing the observer.</code>  targ_bx<code class= source > Array(nt) of any subclass of BODY describing the targets.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_assign.html", "arr_assign.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_assign.html#arr_assign", "arr_assign", 'routine in <a href="obj/arr/arr_assign.html">arr_assign.pro</a>', "arr_assign.pro", "", "arr_assign", "<code class= source >	Replaces fields in a ARRAY object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@arr__keywords_tree.include", "NV/OBJ/ARR", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_create_descriptors.html", "arr_create_descriptors.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_create_descriptors.html#arr_create_descriptors", "arr_create_descriptors", 'routine in <a href="obj/arr/arr_create_descriptors.html">arr_create_descriptors.pro</a>', "arr_create_descriptors.pro", "", "arr_create_descriptors", "<code class= source >	Init method for the ARRAY class.</code>  ", "crd<code class= source >Core descriptor(s) to pass to cor_create_descriptors.</code>  ard<code class= source >Station descriptor(s) to initialize, instead of creating new</code> <code class= source >		ones.</code>  n<code class= source >     Number of array descriptors.</code>  @arr__keywords_tree.include", "NV/LIB/arr", "<code class= source >       Written by:     Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (n) of array descriptors.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_query.html", "arr_query.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_query.html#arr_query", "arr_query", 'routine in <a href="obj/arr/arr_query.html">arr_query.pro</a>', "arr_query.pro", "", "arr_query", "<code class= source >	Returns the fields associated with a ARRAY object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@arr__keywords_tree.include", "NV/OBJ/ARR", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_replicate.html", "arr_replicate.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_replicate.html#arr_replicate", "arr_replicate", 'routine in <a href="obj/arr/arr_replicate.html">arr_replicate.pro</a>', "arr_replicate.pro", "", "arr_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "ard<code class= source > Station descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/arr", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_set_surface_pts.html", "arr_set_surface_pts.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_set_surface_pts.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_set_surface_pts.html#arr_set_surface_pts", "arr_set_surface_pts", 'routine in <a href="obj/arr/arr_set_surface_pts.html">arr_set_surface_pts.pro</a>', "arr_set_surface_pts.pro", "", "arr_set_surface_pts", "<code class= source >	Replaces the surface_pts vector in each given array descriptor.</code>  ", "noeventard<code class= source >	Array (nt) of ARRAY descriptors.</code>  surface_pts<code class= source >Array (nv,3,nt) of surface_pts vectors.</code>  ", "NV/LIB/arr", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/arr_surface_pts.html", "arr_surface_pts.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "arr_surface_pts.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/arr_surface_pts.html#arr_surface_pts", "arr_surface_pts", 'routine in <a href="obj/arr/arr_surface_pts.html">arr_surface_pts.pro</a>', "arr_surface_pts.pro", "", "arr_surface_pts", "<code class= source >	Returns the surface_pts vector for each given array descriptor.</code>  ", "noeventard<code class= source > Array (nt) of ARRAY descriptors.</code>  ", "NV/LIB/arr", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) of surface_pts vectors associated with each given</code> <code class= source >	array descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_aberration.html", "bod_aberration.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_aberration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_aberration.html#bod_aberration", "bod_aberration", 'routine in <a href="obj/bod/bod_aberration.html">bod_aberration.pro</a>', "bod_aberration.pro", "", "bod_aberration", "<code class= source >	Returns the aberration flags for each given body descriptor.</code>  ", "noeventbdname", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 7/2017</code>  <code class= source >	Aberration flag associated with the given name for each given body</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_assign.html", "bod_assign.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_assign.html#bod_assign", "bod_assign", 'routine in <a href="obj/bod/bod_assign.html">bod_assign.pro</a>', "bod_assign.pro", "", "bod_assign", "<code class= source >	Replaces fields in a BODY object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@bod__keywords_tree.include", "NV/OBJ/BOD", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_avel.html", "bod_avel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_avel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_avel.html#bod_avel", "bod_avel", 'routine in <a href="obj/bod/bod_avel.html">bod_avel.pro</a>', "bod_avel.pro", "", "bod_avel", "<code class= source >	Returns the angular velocity for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Angular velocity value associated with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial.html", "bod_body_to_inertial.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial.html#bod_body_to_inertial", "bod_body_to_inertial", 'routine in <a href="obj/bod/bod_body_to_inertial.html">bod_body_to_inertial.pro</a>', "bod_body_to_inertial.pro", "", "bod_body_to_inertial", "<code class= source >	Transforms the given column vectors from the body coordinate</code> <code class= source >	system to the inertial coordinate system.</code>  ", "_subbdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (nv,3,nt) of column vectors in the bx inertial frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_default.html", "bod_body_to_inertial_default.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_default.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_default.html#bod_body_to_inertial_default", "bod_body_to_inertial_default", 'routine in <a href="obj/bod/bod_body_to_inertial_default.html">bod_body_to_inertial_default.pro</a>', "bod_body_to_inertial_default.pro", "", "bod_body_to_inertial_default", "<code class= source >	Transforms the given column vectors from the body coordinate</code> <code class= source >	system to the inertial coordinate system.</code>  ", "_subbdvp", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (nv,3,nt) of column vectors in the bx inertial frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_pos.html", "bod_body_to_inertial_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_pos.html#bod_body_to_inertial_pos", "bod_body_to_inertial_pos", 'routine in <a href="obj/bod/bod_body_to_inertial_pos.html">bod_body_to_inertial_pos.pro</a>', "bod_body_to_inertial_pos.pro", "", "bod_body_to_inertial_pos", "<code class= source >       Transforms the given column position vectors from the body</code> <code class= source >       coordinate system to the inertial coordinate system.</code>  ", "bdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >       Array (nv,3,nt) of column position vectors in the inertial</code> <code class= source >       frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_vel.html", "bod_body_to_inertial_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_inertial_vel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_inertial_vel.html#bod_body_to_inertial_vel", "bod_body_to_inertial_vel", 'routine in <a href="obj/bod/bod_body_to_inertial_vel.html">bod_body_to_inertial_vel.pro</a>', "bod_body_to_inertial_vel.pro", "", "bod_body_to_inertial_vel", "<code class= source >       Transforms the given column velocity vectors from the body</code> <code class= source >       coordinate system to the inertial coordinate system.</code>  ", "bdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >       Array (nv,3,nt) of column velocity vectors in the inertial</code> <code class= source >       frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec.html", "bod_body_to_radec.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_radec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec.html#bod_body_to_radec", "bod_body_to_radec", 'routine in <a href="obj/bod/bod_body_to_radec.html">bod_body_to_radec.pro</a>', "bod_body_to_radec.pro", "", "bod_body_to_radec", "<code class= source >       Transforms the given column vectors from the body coordinate</code> <code class= source >       system to the RA/DEC coordinate system associated to that</code> <code class= source >       body.</code>  ", "bdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >       Array (nv,3,nt) of column vectors in the bx radec frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec_vel.html", "bod_body_to_radec_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_body_to_radec_vel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_body_to_radec_vel.html#bod_body_to_radec_vel", "bod_body_to_radec_vel", 'routine in <a href="obj/bod/bod_body_to_radec_vel.html">bod_body_to_radec_vel.pro</a>', "bod_body_to_radec_vel.pro", "", "bod_body_to_radec_vel", "<code class= source >       Transforms the given column velocity vectors from the body coordinate</code> <code class= source >       system to the RA/DEC coordinate system associated with that body.</code>  ", "bdrv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 7/2015</code>  <code class= source >       Array (nv,3,nt) of column vectors in the bx radec frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_create_descriptors.html", "bod_create_descriptors.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_create_descriptors.html#bod_create_descriptors", "bod_create_descriptors", 'routine in <a href="obj/bod/bod_create_descriptors.html">bod_create_descriptors.pro</a>', "bod_create_descriptors.pro", "", "bod_create_descriptors", "<code class= source >	Init method for the BODY class.</code>  ", "crdbdn<code class= source >Number of descriptors to create.</code>  @bod__keywords_tree.include", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created or or freshly initialized body descriptors, depending</code> <code class= source >	on the presence of the bd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_dlibdt.html", "bod_dlibdt.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_dlibdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_dlibdt.html#bod_dlibdt", "bod_dlibdt", 'routine in <a href="obj/bod/bod_dlibdt.html">bod_dlibdt.pro</a>', "bod_dlibdt.pro", "", "bod_dlibdt", "<code class= source >       Returns the frequency of each libration vector for each given</code> <code class= source >       body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >       Values of the frequency of each libration vector associated</code> <code class= source >       with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_evolve.html", "bod_evolve.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_evolve.html#bod_evolve", "bod_evolve", 'routine in <a href="obj/bod/bod_evolve.html">bod_evolve.pro</a>', "bod_evolve.pro", "", "bod_evolve", "<code class= source >	Computes new body descriptors at the given time offsets from the</code> <code class= source >	given body descriptors using the taylor series expansion</code> <code class= source >	corresponding to the derivatives contained in the given body</code> <code class= source >	descriptor.</code>  ", "nodv<code class= source >If set, derivatives will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  bddt<code class= source > Time offset.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (nbd,ndt) of newly allocated descriptors, of class BODY,</code> <code class= source >	evolved by time dt, where nbd is the number of bx, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_get_radec_ranges.html", "bod_get_radec_ranges.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_get_radec_ranges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_get_radec_ranges.html#bod_get_radec_ranges", "bod_get_radec_ranges", 'routine in <a href="obj/bod/bod_get_radec_ranges.html">bod_get_radec_ranges.pro</a>', "bod_get_radec_ranges.pro", "", "bod_get_radec_ranges", "<code class= source >	Returns ranges of valid  radec coordinates for the given BODY object.</code>  ", "bd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Array (2 x 3) giving the ranges in radius, RA and DEC.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_ib_data.html", "bod_ib_data.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_ib_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_ib_data.html#bod_ib_data", "bod_ib_data", 'routine in <a href="obj/bod/bod_ib_data.html">bod_ib_data.pro</a>', "bod_ib_data.pro", "", "bod_ib_data", "<code class= source >	Returns the function data for a body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Adapted by:	Spitale, 7/2016</code>  <code class= source >	Function data associated with the given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial.html", "bod_inertial.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial.html#bod_inertial", "bod_inertial", 'routine in <a href="obj/bod/bod_inertial.html">bod_inertial.pro</a>', "bod_inertial.pro", "", "bod_inertial", "<code class= source >	Returns body descriptors defining te inertial coordinate system.</code>  ", "nt", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Body descriptor defining the inertial frame.  Note this descriptor is</code> <code class= source >	not allocated on the heap, so it should not be freed by the caller.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body.html", "bod_inertial_to_body.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body.html#bod_inertial_to_body", "bod_inertial_to_body", 'routine in <a href="obj/bod/bod_inertial_to_body.html">bod_inertial_to_body.pro</a>', "bod_inertial_to_body.pro", "", "bod_inertial_to_body", "<code class= source >	Transforms the given column vectors from the inertial coordinate</code> <code class= source >	system to the body coordinate system.</code>  ", "_subbdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) of column vectors in the bx body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_default.html", "bod_inertial_to_body_default.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_default.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_default.html#bod_inertial_to_body_default", "bod_inertial_to_body_default", 'routine in <a href="obj/bod/bod_inertial_to_body_default.html">bod_inertial_to_body_default.pro</a>', "bod_inertial_to_body_default.pro", "", "bod_inertial_to_body_default", "<code class= source >	Transforms the given column vectors from the inertial coordinate</code> <code class= source >	system to the body coordinate system.</code>  ", "_subbdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) of column vectors in the bx body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_pos.html", "bod_inertial_to_body_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_pos.html#bod_inertial_to_body_pos", "bod_inertial_to_body_pos", 'routine in <a href="obj/bod/bod_inertial_to_body_pos.html">bod_inertial_to_body_pos.pro</a>', "bod_inertial_to_body_pos.pro", "", "bod_inertial_to_body_pos", "<code class= source >       Transforms the given column position vectors from the inertial</code> <code class= source >       coordinate system to the body coordinate system.</code>  ", "bdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column position vectors in the bx body</code> <code class= source >       frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_vel.html", "bod_inertial_to_body_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_inertial_to_body_vel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_inertial_to_body_vel.html#bod_inertial_to_body_vel", "bod_inertial_to_body_vel", 'routine in <a href="obj/bod/bod_inertial_to_body_vel.html">bod_inertial_to_body_vel.pro</a>', "bod_inertial_to_body_vel.pro", "", "bod_inertial_to_body_vel", "<code class= source >       Transforms the given column velocity vectors from the inertial</code> <code class= source >       coordinate system to the body coordinate system.</code>  ", "bdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column velocity vectors in the bx body</code> <code class= source >       frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_lib.html", "bod_lib.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_lib.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_lib.html#bod_lib", "bod_lib", 'routine in <a href="obj/bod/bod_lib.html">bod_lib.pro</a>', "bod_lib.pro", "", "bod_lib", "<code class= source >       Returns the phase of the libration vector at body time for</code> <code class= source >       each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Phase of the libraton vectors at body time associated with</code> <code class= source >       each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_libv.html", "bod_libv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_libv.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_libv.html#bod_libv", "bod_libv", 'routine in <a href="obj/bod/bod_libv.html">bod_libv.pro</a>', "bod_libv.pro", "", "bod_libv", "<code class= source >	Returns the libration vector for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Libration vector associated with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_ndv.html", "bod_ndv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_ndv.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_ndv.html#bod_ndv", "bod_ndv", 'routine in <a href="obj/bod/bod_ndv.html">bod_ndv.pro</a>', "bod_ndv.pro", "", "bod_ndv", "<code class= source >	Returns an integer indicating the maximum number of time derivatives</code> <code class= source >	allowed in the vel and avel fields of the body descriptor.  This number</code> <code class= source >	can be adjusted using the environment variable 'BOD_NDV'.  The default</code> <code class= source >	is 4.</code>  <code class= source >Environment variables: </code> <code class= source >	BOD_NDV:	Sets the ndv value.</code>  ", "", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Current ndv value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_opaque.html", "bod_opaque.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_opaque.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_opaque.html#bod_opaque", "bod_opaque", 'routine in <a href="obj/bod/bod_opaque.html">bod_opaque.pro</a>', "bod_opaque.pro", "", "bod_opaque", "<code class= source >	Returns the opaque value for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Opaque value associated with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_orient.html", "bod_orient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_orient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_orient.html#bod_orient", "bod_orient", 'routine in <a href="obj/bod/bod_orient.html">bod_orient.pro</a>', "bod_orient.pro", "", "bod_orient", "<code class= source >	Returns the orientation matrix for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Orientation matrix associated with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_pos.html", "bod_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_pos.html#bod_pos", "bod_pos", 'routine in <a href="obj/bod/bod_pos.html">bod_pos.pro</a>', "bod_pos.pro", "", "bod_pos", "<code class= source >       Returns the position of body center (in the inertial frame)</code> <code class= source >       for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Position of body center (in the inertial frame) associated</code> <code class= source >       with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_query.html", "bod_query.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_query.html#bod_query", "bod_query", 'routine in <a href="obj/bod/bod_query.html">bod_query.pro</a>', "bod_query.pro", "", "bod_query", "<code class= source >	Returns the fields associated with a BODY object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@bod__keywords_tree.include", "NV/OBJ/BOD", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body.html", "bod_radec_to_body.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_radec_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body.html#bod_radec_to_body", "bod_radec_to_body", 'routine in <a href="obj/bod/bod_radec_to_body.html">bod_radec_to_body.pro</a>', "bod_radec_to_body.pro", "", "bod_radec_to_body", "<code class= source >	Transforms the given column vectors from the RA/DEC coordinate</code> <code class= source >       system associated to the body to the body coordinate system.</code>  ", "bdv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) of column vectors in the bx body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body_vel.html", "bod_radec_to_body_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_radec_to_body_vel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_radec_to_body_vel.html#bod_radec_to_body_vel", "bod_radec_to_body_vel", 'routine in <a href="obj/bod/bod_radec_to_body_vel.html">bod_radec_to_body_vel.pro</a>', "bod_radec_to_body_vel.pro", "", "bod_radec_to_body_vel", "<code class= source >	Transforms the given column velocity vectors from the RA/DEC coordinate</code> <code class= source >       system associated to the body to the body coordinate system.</code>  ", "bdrv", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) of column velocity vectors in the bx body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_recenter.html", "bod_recenter.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_recenter.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_recenter.html#bod_recenter", "bod_recenter", 'routine in <a href="obj/bod/bod_recenter.html">bod_recenter.pro</a>', "bod_recenter.pro", "", "bod_recenter", "<code class= source >	Transforms a body descriptor into another body frame.</code>  ", "bx<code class= source >Descriptor to transform, array (nt) of any subclass of BODY.</code>  bx0<code class= source >Frame to transform into, array (nt) of any subclass of BODY.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_reorient.html", "bod_reorient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_reorient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_reorient.html#bod_reorient", "bod_reorient", 'routine in <a href="obj/bod/bod_reorient.html">bod_reorient.pro</a>', "bod_reorient.pro", "", "bod_reorient", "<code class= source >	Rotates the orientation matrix of each body such that the specified</code> <code class= source >	axis vector is parallel to the given vector.</code>  ", "bx<code class= source >Array (nt) of any subclass of BODY.</code>  ii_v<code class= source >Array (nv,3,nt) of column vectors to align with the</code> <code class= source >		each reference axis.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_replicate.html", "bod_replicate.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_replicate.html#bod_replicate", "bod_replicate", 'routine in <a href="obj/bod/bod_replicate.html">bod_replicate.pro</a>', "bod_replicate.pro", "", "bod_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "bddim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_rotate.html", "bod_rotate.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_rotate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_rotate.html#bod_rotate", "bod_rotate", 'routine in <a href="obj/bod/bod_rotate.html">bod_rotate.pro</a>', "bod_rotate.pro", "", "bod_rotate", "<code class= source >	Rotates a body about one its axes.</code>  ", "axisbx<code class= source > 	Any subclass of BODY (nt).</code>  _theta<code class= source >	Angle of rotation (nt).</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 2/2014</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	NONE</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_aberration.html", "bod_set_aberration.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_aberration.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_aberration.html#bod_set_aberration", "bod_set_aberration", 'routine in <a href="obj/bod/bod_set_aberration.html">bod_set_aberration.pro</a>', "bod_set_aberration.pro", "", "bod_set_aberration", "<code class= source >	Sets aberration flags for each given body descriptor.</code>  ", "unset<code class= source >If set, the named flag is unset.</code>  noeventbdname", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 7/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_avel.html", "bod_set_avel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_avel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_avel.html#bod_set_avel", "bod_set_avel", 'routine in <a href="obj/bod/bod_set_avel.html">bod_set_avel.pro</a>', "bod_set_avel.pro", "", "bod_set_avel", "<code class= source >	Replaces the angular velocity vector of each given body descriptor.</code>  ", "noeventbdavel<code class= source > Array (ndv,3,nt) of new angular velocity vectors.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_dlibdt.html", "bod_set_dlibdt.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_dlibdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_dlibdt.html#bod_set_dlibdt", "bod_set_dlibdt", 'routine in <a href="obj/bod/bod_set_dlibdt.html">bod_set_dlibdt.pro</a>', "bod_set_dlibdt.pro", "", "bod_set_dlibdt", "<code class= source >       Replaces the frequency of each libration vector for each given</code> <code class= source >       body descriptor.</code>  ", "noeventbddlibdt<code class= source > Array (ndv,nt) of new frequencies.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_ib_data.html", "bod_set_ib_data.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_ib_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_ib_data.html#bod_set_ib_data", "bod_set_ib_data", 'routine in <a href="obj/bod/bod_set_ib_data.html">bod_set_ib_data.pro</a>', "bod_set_ib_data.pro", "", "bod_set_ib_data", "<code class= source >	Replaces the function data for a body descriptor.</code>  ", "noeventbd<code class= source > Body descriptor.</code>  data<code class= source > New function data.</code>  ", "NV/LIB/BOD", "<code class= source > 	Adapted by:	Spitale, 7/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_lib.html", "bod_set_lib.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_lib.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_lib.html#bod_set_lib", "bod_set_lib", 'routine in <a href="obj/bod/bod_set_lib.html">bod_set_lib.pro</a>', "bod_set_lib.pro", "", "bod_set_lib", "<code class= source >       Replaces the phase of the libration vector at body time for</code> <code class= source >       each given body descriptor.</code>  ", "noeventbdlib<code class= source > Array (ndv,nt) of new phases of the libration vectors.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_libv.html", "bod_set_libv.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_libv.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_libv.html#bod_set_libv", "bod_set_libv", 'routine in <a href="obj/bod/bod_set_libv.html">bod_set_libv.pro</a>', "bod_set_libv.pro", "", "bod_set_libv", "<code class= source >	Replaces the libration vector of each given body descriptor.</code>  ", "noeventbdlibv<code class= source > Array (ndv,3,nt) of new libration vectors.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_opaque.html", "bod_set_opaque.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_opaque.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_opaque.html#bod_set_opaque", "bod_set_opaque", 'routine in <a href="obj/bod/bod_set_opaque.html">bod_set_opaque.pro</a>', "bod_set_opaque.pro", "", "bod_set_opaque", "<code class= source >	Replaces the opaque flag of each given body descriptor.</code>  ", "noeventbdopaque", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_orient.html", "bod_set_orient.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_orient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_orient.html#bod_set_orient", "bod_set_orient", 'routine in <a href="obj/bod/bod_set_orient.html">bod_set_orient.pro</a>', "bod_set_orient.pro", "", "bod_set_orient", "<code class= source >	Replaces the orientation matrix of each given body descriptor.</code>  ", "noeventbdorient<code class= source > Array (3,3,nt) of new orientation matrices.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_pos.html", "bod_set_pos.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_pos.html#bod_set_pos", "bod_set_pos", 'routine in <a href="obj/bod/bod_set_pos.html">bod_set_pos.pro</a>', "bod_set_pos.pro", "", "bod_set_pos", "<code class= source >       Replaces the position of body center (in the inertial frame)</code> <code class= source >       of each given body descriptor.</code>  ", "noeventbdpos<code class= source > Array (1,3,nt) of new position vectors.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_time.html", "bod_set_time.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_time.html#bod_set_time", "bod_set_time", 'routine in <a href="obj/bod/bod_set_time.html">bod_set_time.pro</a>', "bod_set_time.pro", "", "bod_set_time", "<code class= source >	Replaces the time of each given body descriptor.</code>  ", "noeventbdtime<code class= source > New time value.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_set_vel.html", "bod_set_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_set_vel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_set_vel.html#bod_set_vel", "bod_set_vel", 'routine in <a href="obj/bod/bod_set_vel.html">bod_set_vel.pro</a>', "bod_set_vel.pro", "", "bod_set_vel", "<code class= source >       Replaces the velocity vector (of body center in the inertial</code> <code class= source >       frame) of each given body descriptor.</code>  ", "noeventbdvel<code class= source > Array (ndv,3,nt) of new velocity vectors.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_time.html", "bod_time.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_time.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_time.html#bod_time", "bod_time", 'routine in <a href="obj/bod/bod_time.html">bod_time.pro</a>', "bod_time.pro", "", "bod_time", "<code class= source >	Returns the time for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Time value associated with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/bod_vel.html", "bod_vel.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "bod_vel.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/bod_vel.html#bod_vel", "bod_vel", 'routine in <a href="obj/bod/bod_vel.html">bod_vel.pro</a>', "bod_vel.pro", "", "bod_vel", "<code class= source >       Returns the velocity of body center (in the inertial frame)</code> <code class= source >       for each given body descriptor.</code>  ", "noeventbd", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Velocity of body center (in the inertial frame) associated</code> <code class= source >       with each given body descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_radius.html", "body_radius.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_radius.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/body_radius.html#body_radius", "body_radius", 'routine in <a href="obj/tools/composite/body_radius.html">body_radius.pro</a>', "body_radius.pro", "", "body_radius", "<code class= source >	Returns the sizes of the given bodies.</code>  ", "bx<code class= source >     Globe or Disk descriptor; nt.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	nt-element array giving the size of each body.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_to_image_pos.html", "body_to_image_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_to_image_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/body_to_image_pos.html#body_to_image_pos", "body_to_image_pos", 'routine in <a href="obj/tools/composite/body_to_image_pos.html">body_to_image_pos.pro</a>', "body_to_image_pos.pro", "", "body_to_image_pos", "<code class= source >       Transforms vectors in body coordinates to image coordinates</code>  ", "inertial<code class= source >      Array (nv x 3 x nt) of Vectors in inertial coordinates.</code>  valid<code class= source >Indices of valid output points.</code>  cd<code class= source >      Array of nt camera or map descriptors.</code>  bx<code class= source >      Array of nt object descriptors, subclass of BODY.</code>  v<code class= source >      Array (nv x 3 x nt) of position vectors.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale</code>  <code class= source >       An array (2 x nv x nt) of points in image coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/body_to_surface.html", "body_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "body_to_surface.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/body_to_surface.html#body_to_surface", "body_to_surface", 'routine in <a href="obj/tools/composite/body_to_surface.html">body_to_surface.pro</a>', "body_to_surface.pro", "", "body_to_surface", "<code class= source >       Transforms points in body coordinates to surface coordinates.</code>  ", "bx<code class= source >     Array of nt object descriptors (subclass of BODY).</code>  p", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of surface coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/brim.html", "brim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "brim.pro", "", "", "<code class= source >	Image browser.</code>  <code class= source >	brim may be run standalone or from within grim.  If no files or data</code> <code class= source >	descriptors are given, brim first prompts the user to select a list of</code> <code class= source >	files.  brim then displays thumbnails of all valid files.  Files may be</code> <code class= source >	selected by clicking with the left mouse button.  By default, the image</code> <code class= source >	is opened in a new grim window.  Alternate actions may be defined</code> <code class= source >	through procedures supplied by the caller.</code> <code class= source > EXAMPLES:</code> <code class= source >	To load files into brim using a file-selection widget:</code> 	 <span class= code-prompt >IDL&gt;</span> brim <code class= source >	To load all recognizeable images in the current directory into brim:</code> 	 <span class= code-prompt >IDL&gt;</span> brim, '*' <code class= source >	To browse a set of data descriptors:</code> 	 <span class= code-prompt >IDL&gt;</span> dd = dat_read('*') 	 <span class= code-prompt >IDL&gt;</span> brim, dd <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 10/2002</code>  ");
  

libdata[libdataItem++] = new Array("obj/cam/cam_assign.html", "cam_assign.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_assign.html#cam_assign", "cam_assign", 'routine in <a href="obj/cam/cam_assign.html">cam_assign.pro</a>', "cam_assign.pro", "", "cam_assign", "<code class= source >	Replaces fields in a CAMERA object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@cam__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_body_to_focal.html", "cam_body_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_body_to_focal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_body_to_focal.html#cam_body_to_focal", "cam_body_to_focal", 'routine in <a href="obj/cam/cam_body_to_focal.html">cam_body_to_focal.pro</a>', "cam_body_to_focal.pro", "", "cam_body_to_focal", "<code class= source >       Transforms the given column vectors from the body coordinate</code> <code class= source >       system to the camera focal plane coordinate system.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the camera focal plane frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_create_descriptors.html", "cam_create_descriptors.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_create_descriptors.html#cam_create_descriptors", "cam_create_descriptors", 'routine in <a href="obj/cam/cam_create_descriptors.html">cam_create_descriptors.pro</a>', "cam_create_descriptors.pro", "", "cam_create_descriptors", "<code class= source >	Init method for the CAMERA class.</code>  ", "crdbdcdn<code class= source >Number of descriptors to create.</code>  @cam__keywords_tree.include", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created or or freshly initialized camera descriptors, depending</code> <code class= source >	on the presence of the cd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_evolve.html", "cam_evolve.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_evolve.html#cam_evolve", "cam_evolve", 'routine in <a href="obj/cam/cam_evolve.html">cam_evolve.pro</a>', "cam_evolve.pro", "", "cam_evolve", "<code class= source >       Computes new camera descriptors at the given time offsets from</code> <code class= source >       the given camera descriptors using the taylor series expansion</code> <code class= source >       corresponding to the derivatives contained in the given camera</code> <code class= source >       descriptor.</code>  ", "nodv<code class= source > If set, velocities will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  cd<code class= source > Array (ncd) of CAMERA descriptors.</code>  dt<code class= source > Array (ndt) of time offsets.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (ncd,ndt) of newly allocated camera descriptors evolved</code> <code class= source >       by time dt, where ncd is the number of cd, and ndt is the</code> <code class= source >       number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_exposure.html", "cam_exposure.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_exposure.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_exposure.html#cam_exposure", "cam_exposure", 'routine in <a href="obj/cam/cam_exposure.html">cam_exposure.pro</a>', "cam_exposure.pro", "", "cam_exposure", "<code class= source >       Returns the exposure duration of each given camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Exposure duration associated with each given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fi_data.html", "cam_fi_data.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fi_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fi_data.html#cam_fi_data", "cam_fi_data", 'routine in <a href="obj/cam/cam_fi_data.html">cam_fi_data.pro</a>', "cam_fi_data.pro", "", "cam_fi_data", "<code class= source >	Returns the focal/image function data for a camera descriptor.</code>  ", "noeventcd", "NV/LIB/CAM", "<code class= source > 	Adapted by:	Spitale, 7/2016; adapted from cam_fi_data_p</code>  <code class= source >	Function data associated with the given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_filters.html", "cam_filters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_filters.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_filters.html#cam_filters", "cam_filters", 'routine in <a href="obj/cam/cam_filters.html">cam_filters.pro</a>', "cam_filters.pro", "", "cam_filters", "<code class= source >	Returns the filter name(s) for a given camera descriptor.</code>  ", "noeventcd<code class= source > Camera descriptor.</code>  i", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Names of requested filters.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_focal_to_image.html", "cam_fn_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_focal_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fn_focal_to_image.html#cam_fn_focal_to_image", "cam_fn_focal_to_image", 'routine in <a href="obj/cam/cam_fn_focal_to_image.html">cam_fn_focal_to_image.pro</a>', "cam_fn_focal_to_image.pro", "", "cam_fn_focal_to_image", "<code class= source >       Returns the name of the user-defined focal --&gt; image</code> <code class= source >       transformation function for each given camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Focal --&gt; image transformation function associated with each</code> <code class= source >       given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_image_to_focal.html", "cam_fn_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_image_to_focal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fn_image_to_focal.html#cam_fn_image_to_focal", "cam_fn_image_to_focal", 'routine in <a href="obj/cam/cam_fn_image_to_focal.html">cam_fn_image_to_focal.pro</a>', "cam_fn_image_to_focal.pro", "", "cam_fn_image_to_focal", "<code class= source >       Returns the name of the user-defined image --&gt; focal</code> <code class= source >       transformation function for each given camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Image --&gt; focal transformation function associated with each</code> <code class= source >       given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_fn_psf.html", "cam_fn_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_fn_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_fn_psf.html#cam_fn_psf", "cam_fn_psf", 'routine in <a href="obj/cam/cam_fn_psf.html">cam_fn_psf.pro</a>', "cam_fn_psf.pro", "", "cam_fn_psf", "<code class= source >	Returns the user-defined psf function for the given camera descriptor.</code>  ", "noeventcd", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	PSF function associated with each given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_body.html", "cam_focal_to_body.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_body.html#cam_focal_to_body", "cam_focal_to_body", 'routine in <a href="obj/cam/cam_focal_to_body.html">cam_focal_to_body.pro</a>', "cam_focal_to_body.pro", "", "cam_focal_to_body", "<code class= source >       Transforms the given array of points from the camera focal</code> <code class= source >       plane coordinate system to the body coordinate system.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image.html", "cam_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image.html#cam_focal_to_image", "cam_focal_to_image", 'routine in <a href="obj/cam/cam_focal_to_image.html">cam_focal_to_image.pro</a>', "cam_focal_to_image.pro", "", "cam_focal_to_image", "<code class= source >	Transforms the given array of points in the focal plane</code> <code class= source >       coordinate system to an array of points in the image</code> <code class= source >       coordinate system using the fn_focal_to_image function of the</code> <code class= source >       camera descriptor.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the image coordinate system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_linear.html", "cam_focal_to_image_linear.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_linear.html#cam_focal_to_image_linear", "cam_focal_to_image_linear", 'routine in <a href="obj/cam/cam_focal_to_image_linear.html">cam_focal_to_image_linear.pro</a>', "cam_focal_to_image_linear.pro", "", "cam_focal_to_image_linear", "<code class= source >       Transforms the given array of points in the focal plane</code> <code class= source >       coordinate system to an array of points in the image</code> <code class= source >       coordinate system using a linear model that assumes that</code> <code class= source >       distances in the image are proportional to angles in the focal</code> <code class= source >       plane.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the image coordinate system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_poly.html", "cam_focal_to_image_poly.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_poly.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_poly.html#cam_focal_to_image_poly", "cam_focal_to_image_poly", 'routine in <a href="obj/cam/cam_focal_to_image_poly.html">cam_focal_to_image_poly.pro</a>', "cam_focal_to_image_poly.pro", "", "cam_focal_to_image_poly", "<code class= source >       Transforms the given array of points in the focal plane</code> <code class= source >       coordinate system to an array of points in the image</code> <code class= source >       coordinate system using a polynomial distortion model.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the image coordinate system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_radial.html", "cam_focal_to_image_radial.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_focal_to_image_radial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_focal_to_image_radial.html#cam_focal_to_image_radial", "cam_focal_to_image_radial", 'routine in <a href="obj/cam/cam_focal_to_image_radial.html">cam_focal_to_image_radial.pro</a>', "cam_focal_to_image_radial.pro", "", "cam_focal_to_image_radial", "<code class= source >       Transforms the given array of points in the focal plane</code> <code class= source >       coordinate system to an array of points in the image</code> <code class= source >       coordinate system using a radial distortion model.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the image coordinate system.</code> <code class= source > STATUS:</code> <code class= source >	**Incomplete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_get_poly_matrices.html", "cam_get_poly_matrices.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_get_poly_matrices.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_get_poly_matrices.html#cam_get_poly_matrices", "cam_get_poly_matrices", 'routine in <a href="obj/cam/cam_get_poly_matrices.html">cam_get_poly_matrices.pro</a>', "cam_get_poly_matrices.pro", "", "cam_get_poly_matrices", "<code class= source >       Obtains the camera function data for the polynomial distortion model.</code>  ", "cd<code class= source >Array (nt) of and subclass of CAMERA.</code>  XXYYPPQQ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       XX:     Polynominal distortion coefficients in x.</code> <code class= source >       YY:     Polynominal distortion coefficients in y.</code> <code class= source >       PP:     Inverse polynominal distortion coefficients in x.</code> <code class= source >       QQ:     Inverse polynominal distortion coefficients in y.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_get_radec_twist.html", "cam_get_radec_twist.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_get_radec_twist.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_get_radec_twist.html#cam_get_radec_twist", "cam_get_radec_twist", 'routine in <a href="obj/cam/cam_get_radec_twist.html">cam_get_radec_twist.pro</a>', "cam_get_radec_twist.pro", "", "cam_get_radec_twist", "<code class= source >       Computes camera Euler angles relative to the inertial frame.</code>  ", "radectwistcd<code class= source >        Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	ra:	Array (nt) of RA angles.</code> <code class= source >	dec:	Array (nt) of DEC angles.</code> <code class= source >	twist:	Array (nt) of TWIST angles.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal.html", "cam_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal.html#cam_image_to_focal", "cam_image_to_focal", 'routine in <a href="obj/cam/cam_image_to_focal.html">cam_image_to_focal.pro</a>', "cam_image_to_focal.pro", "", "cam_image_to_focal", "<code class= source >       Transforms the given array of points in the image coordinate</code> <code class= source >       system to an array of points in the camera focal plane</code> <code class= source >       coordinate system using the fn_image_to_focal function of the</code> <code class= source >       camera descriptor.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the camera focal frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_linear.html", "cam_image_to_focal_linear.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_linear.html#cam_image_to_focal_linear", "cam_image_to_focal_linear", 'routine in <a href="obj/cam/cam_image_to_focal_linear.html">cam_image_to_focal_linear.pro</a>', "cam_image_to_focal_linear.pro", "", "cam_image_to_focal_linear", "<code class= source >       Transforms the given array of points in the image coordinate</code> <code class= source >       system to an array of points in the camera focal plane</code> <code class= source >       coordinate system using a linear model that assumes that</code> <code class= source >       distances in the image are proportional to angles in the focal</code> <code class= source >       plane.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the camera focal frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_poly.html", "cam_image_to_focal_poly.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_poly.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_poly.html#cam_image_to_focal_poly", "cam_image_to_focal_poly", 'routine in <a href="obj/cam/cam_image_to_focal_poly.html">cam_image_to_focal_poly.pro</a>', "cam_image_to_focal_poly.pro", "", "cam_image_to_focal_poly", "<code class= source >       Transforms the given array of points in the image coordinate</code> <code class= source >       system to an array of points in the camera focal plane</code> <code class= source >       coordinate system using a polynomial distortion model.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the camera focal frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_radial.html", "cam_image_to_focal_radial.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_image_to_focal_radial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_image_to_focal_radial.html#cam_image_to_focal_radial", "cam_image_to_focal_radial", 'routine in <a href="obj/cam/cam_image_to_focal_radial.html">cam_image_to_focal_radial.pro</a>', "cam_image_to_focal_radial.pro", "", "cam_image_to_focal_radial", "<code class= source >       Transforms the given array of points in the image coordinate</code> <code class= source >       system to an array of points in the camera focal plane</code> <code class= source >       coordinate system using a radial distortion model.</code>  ", "cd<code class= source >        Array (nt) of CAMERA descriptors.</code>  v", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (2,nv,nt) of points in the camera focal frame.</code> <code class= source > STATUS:</code> <code class= source >	**Incomplete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_nfilters.html", "cam_nfilters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_nfilters.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_nfilters.html#cam_nfilters", "cam_nfilters", 'routine in <a href="obj/cam/cam_nfilters.html">cam_nfilters.pro</a>', "cam_nfilters.pro", "", "cam_nfilters", "<code class= source >	Returns an integer indicating the maximum number of filters allowed</code> <code class= source >	in the 'filters' fields of the camera descriptor.  This number can</code> <code class= source >	be adjusted using the environment variable 'CAM_NFILTERS'.  The default</code> <code class= source >	is 4.</code>  <code class= source >Environment variables: </code> <code class= source >	CAM_NFILTERS:	Sets the maximum number of filters.</code>  ", "", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Current nfilters value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_oaxis.html", "cam_oaxis.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_oaxis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_oaxis.html#cam_oaxis", "cam_oaxis", 'routine in <a href="obj/cam/cam_oaxis.html">cam_oaxis.pro</a>', "cam_oaxis.pro", "", "cam_oaxis", "<code class= source >       Returns the 2-element array giving the image coordinates (in</code> <code class= source >       pixels) corresponding to the camera optic axis for each given</code> <code class= source >       camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Oaxis array associated with each given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_origin.html", "cam_origin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_origin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_origin.html#cam_origin", "cam_origin", 'routine in <a href="obj/cam/cam_origin.html">cam_origin.pro</a>', "cam_origin.pro", "", "cam_origin", "<code class= source >       Returns the 2-element array giving the image coordinates (in</code> <code class= source >       pixels) corresponding to the camera optic axis for each given</code> <code class= source >       camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	origin array associated with each given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_psf.html", "cam_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_psf.html#cam_psf", "cam_psf", 'routine in <a href="obj/cam/cam_psf.html">cam_psf.pro</a>', "cam_psf.pro", "", "cam_psf", "<code class= source >	Computes a point-spread function.</code>  <code class= source >	The function indicated by the fn_psf field of the camera descriptor</code> <code class= source >	is called and its return value is passed through to the caller of</code> <code class= source >	cam_psf.  If x and y widths are given instead of arrays, the PSF</code> <code class= source >	will be centered, and the grid spacing will be one pixel.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "noeventcd<code class= source > Camera descriptor.</code>  _x<code class= source > Array of x coordinates relative to the center of the PSF,</code> <code class= source >		 or a width in the x direction.</code>  _y<code class= source > Array of y coordinates relative to the center of the PSF,</code> <code class= source >		 or a width in the y direction.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Point-spread function values at each point specified by the x and y</code> <code class= source >	arguments.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_psf_attrib.html", "cam_psf_attrib.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_psf_attrib.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_psf_attrib.html#cam_psf_attrib", "cam_psf_attrib", 'routine in <a href="obj/cam/cam_psf_attrib.html">cam_psf_attrib.pro</a>', "cam_psf_attrib.pro", "", "cam_psf_attrib", "<code class= source >	Computes attributes of a point-spread function.</code>  ", "fwhmcd<code class= source > Camera descriptor.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	fwhm:	Full-width at half maximum of the point-spread function.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_query.html", "cam_query.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_query.html#cam_query", "cam_query", 'routine in <a href="obj/cam/cam_query.html">cam_query.pro</a>', "cam_query.pro", "", "cam_query", "<code class= source >	Returns the fields associated with a CAMERA object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@cam__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_radec_to_orient.html", "cam_radec_to_orient.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_radec_to_orient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_radec_to_orient.html#cam_radec_to_orient", "cam_radec_to_orient", 'routine in <a href="obj/cam/cam_radec_to_orient.html">cam_radec_to_orient.pro</a>', "cam_radec_to_orient.pro", "", "cam_radec_to_orient", "<code class= source >	Computes orientation matrices such that the optic axis (axis 1)</code> <code class= source >	points in the direction of the given radec and the image y direction</code> <code class= source >	(axis 2) points toward celestial north (inertial [0,0,1]).</code>  ", "y_radec<code class= source >Array (nv,3) or (1,2,nt)  giving the radec representations of the</code> <code class= source >		pointing vectors (i.e., orient[1,*,*]).</code>  ", "NV/LIB/CAM", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array (3,3,nt) of orientation matrices.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_rebin.html", "cam_rebin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_rebin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_rebin.html#cam_rebin", "cam_rebin", 'routine in <a href="obj/cam/cam_rebin.html">cam_rebin.pro</a>', "cam_rebin.pro", "", "cam_rebin", "<code class= source >       Modifies the camera parameters to reflect a re-binning of the pixels.</code>  ", "noeventcd<code class= source >    Array (nt) of CAMERA descriptors.</code>  bin<code class= source >       Binning factor, can be non-integer.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_reorient.html", "cam_reorient.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_reorient.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_reorient.html#cam_reorient", "cam_reorient", 'routine in <a href="obj/cam/cam_reorient.html">cam_reorient.pro</a>', "cam_reorient.pro", "", "cam_reorient", "<code class= source >       Repoints the camera orientiation matrix based on x,y, and theta</code> <code class= source >	image offsets.</code>  ", "absolute<code class= source >If set, the dxy argument represents an absolute image</code> <code class= source >		  position rather than an offset.</code>  nsin_anglecos_anglecd0image_axis<code class= source >Array (2,1,nt) of image points corresponding to the</code> <code class= source >			rotation axis for each descriptor.</code>  dxy<code class= source >Array (2,1,nt) of image offsets in x and y.</code>  dtheta", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_replicate.html", "cam_replicate.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_replicate.html#cam_replicate", "cam_replicate", 'routine in <a href="obj/cam/cam_replicate.html">cam_replicate.pro</a>', "cam_replicate.pro", "", "cam_replicate", "<code class= source >	Replicates the given camera descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "cd<code class= source > One CAMERA descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_rescale.html", "cam_rescale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_rescale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_rescale.html#cam_rescale", "cam_rescale", 'routine in <a href="obj/cam/cam_rescale.html">cam_rescale.pro</a>', "cam_rescale.pro", "", "cam_rescale", "<code class= source >       Produces a new camera descriptor describing an image of the same</code> <code class= source >	angluar dimensions, but with a new scale, specified by camera scale.</code>  ", "noeventcd<code class= source >Array (nt) of CAMERA descriptors to modify.</code>  scale<code class= source >Array (2,1,nt) of new camera scales.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_resize.html", "cam_resize.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_resize.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_resize.html#cam_resize", "cam_resize", 'routine in <a href="obj/cam/cam_resize.html">cam_resize.pro</a>', "cam_resize.pro", "", "cam_resize", "<code class= source >       Produces a new camera descriptor describing an image of the same</code> <code class= source >	angluar dimensions, but with a new scale, specified by image size.</code>  ", "noeventcd<code class= source >Array (nt) of CAMERA descriptors to modify.</code>  size<code class= source >Array (2,1,nt) of new image sizes.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_scale.html", "cam_scale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_scale.html#cam_scale", "cam_scale", 'routine in <a href="obj/cam/cam_scale.html">cam_scale.pro</a>', "cam_scale.pro", "", "cam_scale", "<code class= source >       Returns the 2-element array giving the camera scale</code> <code class= source >       (radians/pixel) in each direction for each given camera</code> <code class= source >       descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Scale array associated with each given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_exposure.html", "cam_set_exposure.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_exposure.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_exposure.html#cam_set_exposure", "cam_set_exposure", 'routine in <a href="obj/cam/cam_set_exposure.html">cam_set_exposure.pro</a>', "cam_set_exposure.pro", "", "cam_set_exposure", "<code class= source >       Replaces the exposure duration for each given camera descriptor.</code>  ", "noeventcd<code class= source >     Array (nt) of CAMERA descriptors.</code>  exposure<code class= source >   Array (nt) of new exposure values.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fi_data.html", "cam_set_fi_data.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fi_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fi_data.html#cam_set_fi_data", "cam_set_fi_data", 'routine in <a href="obj/cam/cam_set_fi_data.html">cam_set_fi_data.pro</a>', "cam_set_fi_data.pro", "", "cam_set_fi_data", "<code class= source >	Replaces the focal/image function data for a camera descriptor.</code>  ", "noeventcd<code class= source > Camera descriptor.</code>  data<code class= source > New function data.</code>  ", "NV/LIB/CAM", "<code class= source > 	Adapted by:	Spitale, 7/2016; adapted from cam_set_fi_data_p</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_filters.html", "cam_set_filters.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_filters.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_filters.html#cam_set_filters", "cam_set_filters", 'routine in <a href="obj/cam/cam_set_filters.html">cam_set_filters.pro</a>', "cam_set_filters.pro", "", "cam_set_filters", "<code class= source >	Sets the filter name(s) for a given camera descriptor.</code>  ", "noeventcd<code class= source > Camera descriptor.</code>  filteri", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_focal_to_image.html", "cam_set_fn_focal_to_image.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_focal_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_focal_to_image.html#cam_set_fn_focal_to_image", "cam_set_fn_focal_to_image", 'routine in <a href="obj/cam/cam_set_fn_focal_to_image.html">cam_set_fn_focal_to_image.pro</a>', "cam_set_fn_focal_to_image.pro", "", "cam_set_fn_focal_to_image", "<code class= source >       Sets the user-defined focal --&gt; image transformation function</code> <code class= source >       for the given camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  fn_focal_to_image", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_image_to_focal.html", "cam_set_fn_image_to_focal.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_image_to_focal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_image_to_focal.html#cam_set_fn_image_to_focal", "cam_set_fn_image_to_focal", 'routine in <a href="obj/cam/cam_set_fn_image_to_focal.html">cam_set_fn_image_to_focal.pro</a>', "cam_set_fn_image_to_focal.pro", "", "cam_set_fn_image_to_focal", "<code class= source >       Sets the user-defined image --&gt; focal transformation function</code> <code class= source >       for the given camera descriptor.</code>  ", "noeventcd<code class= source > Array (nt) of CAMERA descriptors.</code>  fn_image_to_focal", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_psf.html", "cam_set_fn_psf.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_fn_psf.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_fn_psf.html#cam_set_fn_psf", "cam_set_fn_psf", 'routine in <a href="obj/cam/cam_set_fn_psf.html">cam_set_fn_psf.pro</a>', "cam_set_fn_psf.pro", "", "cam_set_fn_psf", "<code class= source >	Sets the user-defined PSF function for the given camera descriptor.</code>  ", "noeventcd<code class= source > Camera descriptor.</code>  psf", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_oaxis.html", "cam_set_oaxis.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_oaxis.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_oaxis.html#cam_set_oaxis", "cam_set_oaxis", 'routine in <a href="obj/cam/cam_set_oaxis.html">cam_set_oaxis.pro</a>', "cam_set_oaxis.pro", "", "cam_set_oaxis", "<code class= source >       Replaces the oaxis array for each given camera descriptor.</code>  ", "noeventcd<code class= source >Array (nt) of CAMERA descriptors.</code>  oaxis<code class= source >Array (2,nt) of new oaxis values.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_origin.html", "cam_set_origin.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_origin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_origin.html#cam_set_origin", "cam_set_origin", 'routine in <a href="obj/cam/cam_set_origin.html">cam_set_origin.pro</a>', "cam_set_origin.pro", "", "cam_set_origin", "<code class= source >       Replaces the origin array for each given camera descriptor.</code>  ", "noeventcd<code class= source >Array (nt) of CAMERA descriptors.</code>  origin<code class= source >Array (2,nt) of new origin values.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_poly_matrices.html", "cam_set_poly_matrices.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_poly_matrices.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_poly_matrices.html#cam_set_poly_matrices", "cam_set_poly_matrices", 'routine in <a href="obj/cam/cam_set_poly_matrices.html">cam_set_poly_matrices.pro</a>', "cam_set_poly_matrices.pro", "", "cam_set_poly_matrices", "<code class= source >       Sets up the camera function data for the polynomial distortion model.</code>  ", "noeventcd<code class= source >Array (nt) of and subclass of CAMERA.</code>  XX<code class= source >    Polynominal distortion coefficients in x.</code>  YY<code class= source >    Polynominal distortion coefficients in y.</code>  PP<code class= source >    Inverse polynominal distortion coefficients in x.</code>  QQ<code class= source >    Inverse polynominal distortion coefficients in y.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_scale.html", "cam_set_scale.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_scale.html#cam_set_scale", "cam_set_scale", 'routine in <a href="obj/cam/cam_set_scale.html">cam_set_scale.pro</a>', "cam_set_scale.pro", "", "cam_set_scale", "<code class= source >       Replaces the scale array for each given camera descriptor.</code>  ", "noeventcd<code class= source >Array (nt) of CAMERA descriptors.</code>  scale<code class= source >Array (2,nt) of new scale values.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_set_size.html", "cam_set_size.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_set_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_set_size.html#cam_set_size", "cam_set_size", 'routine in <a href="obj/cam/cam_set_size.html">cam_set_size.pro</a>', "cam_set_size.pro", "", "cam_set_size", "<code class= source >       Replaces the size array for each given camera descriptor.</code>  ", "noeventcd<code class= source >     Array (nt) of CAMERA descriptors.</code>  size<code class= source >       Array (2,nt) of new size values.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_size.html", "cam_size.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_size.html#cam_size", "cam_size", 'routine in <a href="obj/cam/cam_size.html">cam_size.pro</a>', "cam_size.pro", "", "cam_size", "<code class= source >	Returns the image size (in pixels) for each given camera descriptor.</code>  ", "noeventnxnycd<code class= source > Array (nt) of CAMERA descriptors.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Size array associated with each given camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/cam_subimage.html", "cam_subimage.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "cam_subimage.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/cam_subimage.html#cam_subimage", "cam_subimage", 'routine in <a href="obj/cam/cam_subimage.html">cam_subimage.pro</a>', "cam_subimage.pro", "", "cam_subimage", "<code class= source >       Produces a new camera descriptor corresponding to dividing the</code> <code class= source >	associated image as specified.</code>  ", "noeventcd<code class= source >Array (nt) of CAMERA descriptors to modify.</code>  p0<code class= source >Starting corner of subimage.</code>  size<code class= source >Array (2,1,nt) of image sizes.</code>  ", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 4/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/cd_to_radec_twist.html", "cd_to_radec_twist.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "cd_to_radec_twist.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/cd_to_radec_twist.html#cd_to_radec_twist", "cd_to_radec_twist", 'routine in <a href="obj/tools/cd_to_radec_twist.html">cd_to_radec_twist.pro</a>', "cd_to_radec_twist.pro", "", "cd_to_radec_twist", "<code class= source >       Computes Euler angles representing the orientation of a given</code> <code class= source >	camera descriptor.</code>  ", "radectwistcd<code class= source >      Array (nv,3,nt) of camera descriptors.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       ra:	Right ascension relative to the inertial frame.</code> <code class= source >	dec:	Declination relative to the inertial frame.</code> <code class= source >	twist:	Twist angle relative to the inertial frame.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_abbrev.html", "cor_abbrev.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_abbrev.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_abbrev.html#cor_abbrev", "cor_abbrev", 'routine in <a href="obj/cor/cor_abbrev.html">cor_abbrev.pro</a>', "cor_abbrev.pro", "", "cor_abbrev", "<code class= source >	Returns the abbrieviation for the given object class.</code>  ", "noeventcrd", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	String giving the standard abbreviation for the given class,</code> <code class= source >	e.g., 'BOD'.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_add_task.html", "cor_add_task.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_add_task.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_add_task.html#cor_add_task", "cor_add_task", 'routine in <a href="obj/cor/cor_add_task.html">cor_add_task.pro</a>', "cor_add_task.pro", "", "cor_add_task", "<code class= source >	Adds a task to the descriptor task list.</code>  ", "noeventcrdtask<code class= source > String giving the name of a program that modified the</code> <code class= source >		 descriptor.</code>  ", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_assign.html", "cor_assign.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_assign.html#cor_assign", "cor_assign", 'routine in <a href="obj/cor/cor_assign.html">cor_assign.pro</a>', "cor_assign.pro", "", "cor_assign", "<code class= source >	Replaces fields in a POINT object.  This is a fast way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd<code class= source >	CORE object.</code>  @cor__keywords.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		1/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_associate_gd.html", "cor_associate_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_associate_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_associate_gd.html#cor_associate_gd", "cor_associate_gd", 'routine in <a href="obj/cor/cor_associate_gd.html">cor_associate_gd.pro</a>', "cor_associate_gd.pro", "", "cor_associate_gd", "<code class= source >	Selects all input descriptors whose gd contains the given assoc_xd.</code>  ", "xd<code class= source > 	Array of objects.</code>  assoc_xd<code class= source >Object to test against.  If not given, all input</code> <code class= source >			descriptors are returned.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 7/2017</code>  <code class= source >	Array of objets whose generic descriptors contain assoc_xd.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_class.html", "cor_class.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_class.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_class.html#cor_class", "cor_class", 'routine in <a href="obj/cor/cor_class.html">cor_class.pro</a>', "cor_class.pro", "", "cor_class", "<code class= source >	Returns the class name for the given object class.</code>  ", "xd<code class= source > Descriptor.</code>  ", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale		4/2016</code>  <code class= source >	String giving the class name for the given class, without the OMINAS_</code> <code class= source >	prefix.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_class_info.html", "cor_class_info.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_class_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_class_info.html#cor_class_info", "cor_class_info", 'routine in <a href="obj/cor/cor_class_info.html">cor_class_info.pro</a>', "cor_class_info.pro", "", "cor_class_info", "<code class= source >	Returns information about OMINAS object classes.</code>  ", "classabbrevtag", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale		2/2017</code>  <code class= source >	class:		String array giving the names of all OMINAS classes.</code> <code class= source >	abbrev:		String array giving the abbreviations of OMINAS classes.</code> <code class= source >	tag:		String array giving the tag names of OMINAS classes.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_count_descriptors.html", "cor_count_descriptors.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_count_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_count_descriptors.html#cor_count_descriptors", "cor_count_descriptors", 'routine in <a href="obj/cor/cor_count_descriptors.html">cor_count_descriptors.pro</a>', "cor_count_descriptors.pro", "", "cor_count_descriptors", "<code class= source >	Determines dimensions of an array of input descriptors.</code>  ", "ndntxds<code class= source >	Array (nd,nt) of descriptors.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale</code> <code class= source >	Copied to cor/:	Spitale 	2/2017</code>  <code class= source >	nd:	First dimension, number of objects, default is 1.</code> <code class= source >	nt:	Second dimension, number of 'timesteps', default is 1.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_create_descriptors.html", "cor_create_descriptors.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_create_descriptors.html#cor_create_descriptors", "cor_create_descriptors", 'routine in <a href="obj/cor/cor_create_descriptors.html">cor_create_descriptors.pro</a>', "cor_create_descriptors.pro", "", "cor_create_descriptors", "<code class= source >	Init method for the CORE class.</code>  ", "crd<code class= source >Core descriptor(s) to initialize, instead of creating a new one.</code>  n<code class= source > Number of descriptors to create.</code>  @cor__keywords.include", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created or or freshly initialized core descriptors depending</code> <code class= source >	on the presence of the crd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_create_gd.html", "cor_create_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_create_gd.pro", "", "", "<code class= source >	Creates a generic descriptor from a set of given descriptors.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code> <code class= source >	Moved to CORE	Spitale		2/2017</code>  ");
  

libdata[libdataItem++] = new Array("obj/cor/cor_cull.html", "cor_cull.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_cull.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_cull.html#cor_cull", "cor_cull", 'routine in <a href="obj/cor/cor_cull.html">cor_cull.pro</a>', "cor_cull.pro", "", "cor_cull", "<code class= source >	Removes null objects from an array.</code>  ", "crd", "NV/OBJ/COR", "<code class= source >  Spitale, 3/2017</code>  <code class= source >	Array objects, or !null if all were empty.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_dereference.html", "cor_dereference.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_dereference.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_dereference.html#cor_dereference", "cor_dereference", 'routine in <a href="obj/cor/cor_dereference.html">cor_dereference.pro</a>', "cor_dereference.pro", "", "cor_dereference", "<code class= source >	Turns an array of objects into an array of structures.</code>  ", "xd<code class= source >Array of objects.  Objects may have different classes, but only</code> <code class= source >		their common fields are dereferenced.</code>  ", "NV/SYS/COR", "<code class= source > 	Written by:	Spitale, 6/2002</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of structures.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	cor_rereference</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_dereference_gd.html", "cor_dereference_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_dereference_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_dereference_gd.html#cor_dereference_gd", "cor_dereference_gd", 'routine in <a href="obj/cor/cor_dereference_gd.html">cor_dereference_gd.pro</a>', "cor_dereference_gd.pro", "", "cor_dereference_gd", "<code class= source >	Dereferences a generic descriptor.</code>  ", "name_ref_extraarg", "NV/PGS", "<code class= source >	Moved to CORE	Spitale		2/2017</code>  <code class= source >	Array of descriptors or zero if no fields found.  If no keywords</code> <code class= source >	are given, then all descriptors are returned.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_evolve.html", "cor_evolve.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_evolve.html#cor_evolve", "cor_evolve", 'routine in <a href="obj/cor/cor_evolve.html">cor_evolve.pro</a>', "cor_evolve.pro", "", "cor_evolve", "<code class= source >	Calls the 'evolve' method appropriate for the given descriptor.</code>  ", "nodv<code class= source > If set, velocities will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  xd<code class= source > Any subclass of BODY.</code>  dt<code class= source > Time offset.</code>  ", "NV/SYS/COR", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Array (nxd,ndt) of newly allocated descriptors, of the same class</code> <code class= source >	as xd, evolved by time dt, where nxd is the number of xd, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_gd.html", "cor_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_gd.html#cor_gd", "cor_gd", 'routine in <a href="obj/cor/cor_gd.html">cor_gd.pro</a>', "cor_gd.pro", "", "cor_gd", "<code class= source >	Returns the generic descriptor for a CORE object.</code>  ", "namenoevent<code class= source >		If set, no event is generated.</code>  _ref_extracrd0", "NV/PGS", "<code class= source > 	Written by:	Spitale		2/2017</code>  <code class= source >	Generic descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_init_state.html", "cor_init_state.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_init_state.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_init_state.html#cor_init_state", "cor_init_state", 'routine in <a href="obj/cor/cor_init_state.html">cor_init_state.pro</a>', "cor_init_state.pro", "", "cor_init_state", "<code class= source >	Initializes the CORE state structure.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale		5/2016</code>  <code class= source >	New core state structure.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_match_gd.html", "cor_match_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_match_gd.pro", "", "", "<code class= source >	Compares generic descriptors.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  

libdata[libdataItem++] = new Array("obj/cor/cor_name.html", "cor_name.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_name.html#cor_name", "cor_name", 'routine in <a href="obj/cor/cor_name.html">cor_name.pro</a>', "cor_name.pro", "", "cor_name", "<code class= source >	Returns the name for each given core descriptor.</code>  ", "noeventcrd", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 4/2016</code>  <code class= source >	Name associated with each given core descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_query.html", "cor_query.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_query.html#cor_query", "cor_query", 'routine in <a href="obj/cor/cor_query.html">cor_query.pro</a>', "cor_query.pro", "", "cor_query", "<code class= source >	Returns fields associated with a CORE object.  This is a</code> <code class= source >	fast way of retrieving multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd<code class= source >CORE object.</code>  @cor__keywords.include", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 1/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_replicate.html", "cor_replicate.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_replicate.html#cor_replicate", "cor_replicate", 'routine in <a href="obj/cor/cor_replicate.html">cor_replicate.pro</a>', "cor_replicate.pro", "", "cor_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "crddim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_rereference.html", "cor_rereference.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_rereference.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_rereference.html#cor_rereference", "cor_rereference", 'routine in <a href="obj/cor/cor_rereference.html">cor_rereference.pro</a>', "cor_rereference.pro", "", "cor_rereference", "<code class= source >	Copies an array of structures into an array of objects.</code>  ", "new<code class= source >If set, new pointers will be allocated in xd.</code>  xd<code class= source >Array of objects.</code>  _xd<code class= source >Array of structures.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 6/2002</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	NONE</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	cor_dereference</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_select.html", "cor_select.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_select.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_select.html#cor_select", "cor_select", 'routine in <a href="obj/cor/cor_select.html">cor_select.pro</a>', "cor_select.pro", "", "cor_select", "<code class= source >	Selects descriptors based on given criteria.</code>  ", "indicesrmnoeventnameclassexclude_nameexclude_classcrx<code class= source > Array of descriptors of any subclass of CORE.</code>  key<code class= source > Array of keys to select.</code>  ", "NV/SYS/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Rewritten by:	Spitale, 4/2016</code>  <code class= source >	All descriptors in crx whose parameters match the given key.</code> <code class= source >	0 if no matches found.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_gd.html", "cor_set_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_gd.html#cor_set_gd", "cor_set_gd", 'routine in <a href="obj/cor/cor_set_gd.html">cor_set_gd.pro</a>', "cor_set_gd.pro", "", "cor_set_gd", "<code class= source >	Sets the generic descriptor in a CORE object.</code>  ", "xds<code class= source >	Array of objects to put in generic descriptor.  Generic</code> <code class= source >			descriptors in these objects are considered as well.</code>  noevent<code class= source >If set, no event is generated.</code>  _ref_extracrd0gd<code class= source >	New gd.  If no other inputs are given, then the current</code> <code class= source >			gd is overwritten with this one.  Otherwise, fields are</code> <code class= source >			appended as specified.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_name.html", "cor_set_name.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_name.html#cor_set_name", "cor_set_name", 'routine in <a href="obj/cor/cor_set_name.html">cor_set_name.pro</a>', "cor_set_name.pro", "", "cor_set_name", "<code class= source >	Replaces the name for each given core descriptor.</code>  ", "noeventcrdname", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_set_udata.html", "cor_set_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_set_udata.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_set_udata.html#cor_set_udata", "cor_set_udata", 'routine in <a href="obj/cor/cor_set_udata.html">cor_set_udata.pro</a>', "cor_set_udata.pro", "", "cor_set_udata", "<code class= source >	Stores user data in a descriptor and associates it with the</code> <code class= source >	specified name. If multiple descriptors, then the trailing dimension</code> <code class= source >	must match the number of descriptors.</code>  ", "allnoeventcrdnameudata", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_state.html", "cor_state.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_state.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_state.html#cor_state", "cor_state", 'routine in <a href="obj/cor/cor_state.html">cor_state.pro</a>', "cor_state.pro", "", "cor_state", "<code class= source >	Builds a class tree for the given descriptor.</code>  ", "trace<code class= source >New value for the trace flag.</code>  ", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale		5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_substitute_xd.html", "cor_substitute_xd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_substitute_xd.pro", "", "", "<code class= source >	Replaces objects in generic descriptors and arrays.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  

libdata[libdataItem++] = new Array("obj/cor/cor_tag.html", "cor_tag.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_tag.html#cor_tag", "cor_tag", 'routine in <a href="obj/cor/cor_tag.html">cor_tag.pro</a>', "cor_tag.pro", "", "cor_tag", "<code class= source >	Returns the tag name for the given object class.</code>  ", "x<code class= source >If set, the generic form is returned, e.g, 'CRX'.</code>  noeventcrd", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 2/2017</code>  <code class= source >	String giving the standard tag for the given class, e.g., 'CRD'.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_tasks.html", "cor_tasks.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tasks.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_tasks.html#cor_tasks", "cor_tasks", 'routine in <a href="obj/cor/cor_tasks.html">cor_tasks.pro</a>', "cor_tasks.pro", "", "cor_tasks", "<code class= source >	Returns the descriptor task list.</code>  ", "first<code class= source >If set, only the first task is returned.</code>  latest<code class= source >If set, only the most recent task is returned.</code>  noeventcrd", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	String array containing the list of all programs that have modified</code> <code class= source >	the given descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_test.html", "cor_test.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_test.html#cor_test", "cor_test", 'routine in <a href="obj/cor/cor_test.html">cor_test.pro</a>', "cor_test.pro", "", "cor_test", "<code class= source >	Tests whether the input is an OMINAS object or object structure.</code>  ", "noeventxd<code class= source > Any subclass of CORE.  Only one descriptor may be provided.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 1/2017</code>  <code class= source >	True if xd is an OMINAS object or object structure, false otherwise.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_test_gd.html", "cor_test_gd.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_test_gd.html#cor_test_gd", "cor_test_gd", 'routine in <a href="obj/cor/cor_test_gd.html">cor_test_gd.pro</a>', "cor_test_gd.pro", "", "cor_test_gd", "<code class= source >	Tests whether a generic descriptor field exists and contains a</code> <code class= source >	descriptor.</code>  ", "gd<code class= source > Generic descriptor.</code>  tag<code class= source > Name of field to test.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 2/2017</code>  <code class= source >	True if gd contains the tag and it is a valid descriptor, false otherwise.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_test_udata.html", "cor_test_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_test_udata.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_test_udata.html#cor_test_udata", "cor_test_udata", 'routine in <a href="obj/cor/cor_test_udata.html">cor_test_udata.pro</a>', "cor_test_udata.pro", "", "cor_test_udata", "<code class= source >	Tests the existence of data stored in a descriptor under the</code> <code class= source >	specified name.</code>  ", "noeventcrdname", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	True if the data is stored under the given name, false otherwise.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_tree.html", "cor_tree.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_tree.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_tree.html#cor_tree", "cor_tree", 'routine in <a href="obj/cor/cor_tree.html">cor_tree.pro</a>', "cor_tree.pro", "", "cor_tree", "<code class= source >	Builds a class tree for the given descriptor.</code>  ", "od<code class= source > Descriptor of any class.</code>  ", "NV/SYS/COR", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	String array giving the names of all classes in od, in descending order.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_udata.html", "cor_udata.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_udata.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_udata.html#cor_udata", "cor_udata", 'routine in <a href="obj/cor/cor_udata.html">cor_udata.pro</a>', "cor_udata.pro", "", "cor_udata", "<code class= source >	Retrieves user data stored in a descriptor under the specified name.</code>  ", "noeventcrdname", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Data associated with the given name.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/cor_user.html", "cor_user.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "cor_user.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/cor_user.html#cor_user", "cor_user", 'routine in <a href="obj/cor/cor_user.html">cor_user.pro</a>', "cor_user.pro", "", "cor_user", "<code class= source >	Returns the username for each given core descriptor.</code>  ", "noeventcrd", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Username associated with each given core descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/core_state_struct__define.html", "core_state_struct__define.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "core_state_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/core_state_struct__define.html#core_state_struct__define", "core_state_struct__define", 'routine in <a href="obj/cor/core_state_struct__define.html">core_state_struct__define.pro</a>', "core_state_struct__define.pro", "", "core_state_struct__define", "<code class= source >	Structure defining the CORE state.</code>  ", "", "NV/LIB/COR", "<code class= source > 	Written by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_add_transient_keyvals.html", "dat_add_transient_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_add_transient_keyvals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_add_transient_keyvals.html#dat_add_transient_keyvals", "dat_add_transient_keyvals", 'routine in <a href="obj/dat/dat_add_transient_keyvals.html">dat_add_transient_keyvals.pro</a>', "dat_add_transient_keyvals.pro", "", "dat_add_transient_keyvals", "<code class= source >	Records keyword/value pairs from a transient argument string.</code>  ", "_dd<code class= source >Data descriptor in which to record transient keyvals.</code>  trs<code class= source >Transient argument string.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_assign.html", "dat_assign.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_assign.html#dat_assign", "dat_assign", 'routine in <a href="obj/dat/dat_assign.html">dat_assign.pro</a>', "dat_assign.pro", "", "dat_assign", "<code class= source >	Replaces fields in a CAMERA object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@dat__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_cache.html", "dat_cache.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_cache.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_cache.html#dat_cache", "dat_cache", 'routine in <a href="obj/dat/dat_cache.html">dat_cache.pro</a>', "dat_cache.pro", "", "dat_cache", "<code class= source >	Returns a long integer indicating the maximum size of a data array.</code> <code class= source >	This value may be adjusted using the environment variable 'DAT_CACHE'.</code> <code class= source >	-1 is returned if it cannot be determined.</code>  <code class= source >Environment variables: </code> <code class= source >	DAT_CACHE:	Sets the size of the cache.</code>  ", "", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 8/2016</code>  <code class= source >	Current cache value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_compress.html", "dat_compress.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_compress.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_compress.html#dat_compress", "dat_compress", 'routine in <a href="obj/dat/dat_compress.html">dat_compress.pro</a>', "dat_compress.pro", "", "dat_compress", "<code class= source >	Returns the compression function suffix associated with a data</code> <code class= source >	descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	String giving the compression suffix.  The full name</code> <code class= source >	of the compression function is dat_compress_data_&lt;suffix&gt;.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_create_descriptors.html", "dat_create_descriptors.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_create_descriptors.html#dat_create_descriptors", "dat_create_descriptors", 'routine in <a href="obj/dat/dat_create_descriptors.html">dat_create_descriptors.pro</a>', "dat_create_descriptors.pro", "", "dat_create_descriptors", "<code class= source >	Creates and initializes a data descriptor.</code>  ", "crdddn<code class= source > Number of descriptors to create.</code>  @dat__keywords_tree.include", "NV/SYS", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created and initialized data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_data.html", "dat_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_data.html#dat_data", "dat_data", 'routine in <a href="obj/dat/dat_data.html">dat_data.pro</a>', "dat_data.pro", "", "dat_data", "<code class= source >	Returns the data array associated with a data descriptor.</code>  ", "samples<code class= source > Output sample indices for /current.</code>  current<code class= source > If set, the current loaded samples are returned.  In this</code> <code class= source >		  case, the sample indices are returned in the  samples </code> <code class= source >		  keyword.</code>  slice<code class= source >  Slice coordinates.</code>  nd<code class= source >      If set, the samples input is taken to be an ND coordinate</code> <code class= source >	          rather than a 1D subscript.  DAT_DATA can normally tell</code> <code class= source >	          the difference automatically, but there is an ambiguity</code> <code class= source >	          if a single ND point is requested.  In that case, DAT_DATA</code> <code class= source >	          interprets that as an array of 1D subscripts, unless /nd</code> <code class= source >	          is set.</code>  true<code class= source >    If set, the actual data array is returned, even if there is</code> <code class= source >	          a sampling function.</code>  noeventabscissa<code class= source >The abscissa is returned in this array.</code>  dd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 2/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The data array associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_set_data</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_detect_filetype.html", "dat_detect_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_detect_filetype.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_detect_filetype.html#dat_detect_filetype", "dat_detect_filetype", 'routine in <a href="obj/dat/dat_detect_filetype.html">dat_detect_filetype.pro</a>', "dat_detect_filetype.pro", "", "dat_detect_filetype", "<code class= source >	Attempts to detect the type of the file (or header) associated with the</code> <code class= source >	given data descriptor by calling the detectors in the filetype detectors</code> <code class= source >	table.</code>  ", "default<code class= source >If set, the 'DEFAULT' filetype is returned.</code> <code class= source >			The default filetype is the first item in the table</code> <code class= source >			whose action is not 'IGNORE'.</code>  all<code class= source >	If set, all filetypes in the table are returned.</code>  action<code class= source >	Action string from matched file type entry.</code>  dd<code class= source >	Data descriptor containing filename to test.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	String giving the type, or null string if none detected.  Detector</code> <code class= source >	functions take a single data descriptor argument and return a string</code> <code class= source >	specifying the type.  If the data descriptor contains a header, then</code> <code class= source >	the header type (htype) must be returned, otherwise the file type</code> <code class= source >	is expected.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_detect_instrument.html", "dat_detect_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_detect_instrument.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_detect_instrument.html#dat_detect_instrument", "dat_detect_instrument", 'routine in <a href="obj/dat/dat_detect_instrument.html">dat_detect_instrument.pro</a>', "dat_detect_instrument.pro", "", "dat_detect_instrument", "<code class= source >	Attempts to detect the instrument for a data set by calling the</code> <code class= source >	detectors in the instrument detectors table.</code>  ", "dd<code class= source >	Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	String giving the instrument, or 'DEFAULT' if none detected.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dh.html", "dat_dh.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dh.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dh.html#dat_dh", "dat_dh", 'routine in <a href="obj/dat/dat_dh.html">dat_dh.pro</a>', "dat_dh.pro", "", "dat_dh", "<code class= source >	Returns the detached header associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Detached header associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim.html", "dat_dim.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dim.html#dat_dim", "dat_dim", 'routine in <a href="obj/dat/dat_dim.html">dat_dim.pro</a>', "dat_dim.pro", "", "dat_dim", "<code class= source >	Returns the dimensions of the data array in the given data</code> <code class= source >	descriptor.</code>  ", "true<code class= source >If set, the dimension function is not called and the true</code> <code class= source >	 	dimensions of the dat are returned.</code>  noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array giving the dimensions of the data in the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim_data.html", "dat_dim_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dim_data.html#dat_dim_data", "dat_dim_data", 'routine in <a href="obj/dat/dat_dim_data.html">dat_dim_data.pro</a>', "dat_dim_data.pro", "", "dat_dim_data", "<code class= source >	Returns the dimension function associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The dim_data associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_set_dim_data</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_dim_fn.html", "dat_dim_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_dim_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_dim_fn.html#dat_dim_fn", "dat_dim_fn", 'routine in <a href="obj/dat/dat_dim_fn.html">dat_dim_fn.pro</a>', "dat_dim_fn.pro", "", "dat_dim_fn", "<code class= source >	Returns the dimension function associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The dim_fn associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_set_dim_fn</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_filename.html", "dat_filename.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_filename.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_filename.html#dat_filename", "dat_filename", 'routine in <a href="obj/dat/dat_filename.html">dat_filename.pro</a>', "dat_filename.pro", "", "dat_filename", "<code class= source >	Returns the file name associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 12/2016</code>  <code class= source >	String giving the filename.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_filetype.html", "dat_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_filetype.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_filetype.html#dat_filetype", "dat_filetype", 'routine in <a href="obj/dat/dat_filetype.html">dat_filetype.pro</a>', "dat_filetype.pro", "", "dat_filetype", "<code class= source >	Returns the filetype associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	String giving the filetype.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_gd.html", "dat_gd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_gd.html#dat_gd", "dat_gd", 'routine in <a href="obj/dat/dat_gd.html">dat_gd.pro</a>', "dat_gd.pro", "", "dat_gd", "<code class= source >	Dereferences a given generic descriptor, or the generic descriptor</code> <code class= source >	contained in a data descriptor.  Similar to cor_gd, but data</code> <code class= source >	descriptors are handled specially.</code>  ", "dd<code class= source >Data descriptor.  If gd is undefined, the generic descriptor</code> <code class= source >		contained in this data descriptor is used instead.  If this</code> <code class= source >		keyword is set (i.e., /dd), then it is treated like the</code> <code class= source >		other descriptor keywords and a data desctipro is returned</code> <code class= source >		if one exists in the generic descriptor.</code> <code class= source >	&lt;x&gt;d:	Standard descriptor keywords.  Setting a keyword causes the</code> <code class= source >		corresponding field of the generic descriptor to be returned</code> <code class= source >		in the output array.</code>  _ref_extra_gd<code class= source >Generic descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_get_value.html", "dat_get_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_get_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_get_value.html#dat_get_value", "dat_get_value", 'routine in <a href="obj/dat/dat_get_value.html">dat_get_value.pro</a>', "dat_get_value.pro", "", "dat_get_value", "<code class= source >	Calls input translators, supplying the given keyword, and builds</code> <code class= source >	a list of returned descriptors.</code>  ", "status<code class= source >	0 if at least one translator call was successful,</code> <code class= source >			-1 otherwise.</code>  trs<code class= source >	Transient argument string.</code>  dd<code class= source >	Data descriptors.  Must all have the same instrument</code> <code class= source >			string.</code>  keyword<code class= source >Keyword to pass to translators, describing the</code> <code class= source >			requested quantity.</code>  @nv_trs_keywords_include.pro", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of descriptors returned from all successful translator calls.</code> <code class= source >	Descriptors are returned in the same order that the corresponding</code> <code class= source >	translators were called.  Each translator may produce multiple</code> <code class= source >	descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_gff.html", "dat_gff.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_gff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_gff.html#dat_gff", "dat_gff", 'routine in <a href="obj/dat/dat_gff.html">dat_gff.pro</a>', "dat_gff.pro", "", "dat_gff", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_header.html", "dat_header.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_header.html#dat_header", "dat_header", 'routine in <a href="obj/dat/dat_header.html">dat_header.pro</a>', "dat_header.pro", "", "dat_header", "<code class= source >	Returns the header array associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 2/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The header array associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_set_header</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_header_info.html", "dat_header_info.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header_info.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_header_info.html#dat_header_info", "dat_header_info", 'routine in <a href="obj/dat/dat_header_info.html">dat_header_info.pro</a>', "dat_header_info.pro", "", "dat_header_info", "<code class= source >	Obtains header info specific to the given data descriptor by calling</code> <code class= source >	an application-specific header program.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 9/2017</code>  <code class= source >	Anonymous structure containing info relevant to the calling application.</code> <code class= source >	An application specific program named &lt;instrument&gt;_&lt;htype&gt;_header_info()</code> <code class= source >	Is called with the header as the only argmuent.  The output of that</code> <code class= source >	program is returned by DAT_HEADER_INFO.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_header_value.html", "dat_header_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_header_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_header_value.html#dat_header_value", "dat_header_value", 'routine in <a href="obj/dat/dat_header_value.html">dat_header_value.pro</a>', "dat_header_value.pro", "", "dat_header_value", "<code class= source >	Reads and write header keyword values.</code>  ", "get<code class= source >Value of the specified keyword read from the header.</code>  set<code class= source >New value to write to the specified keyword.</code>  noeventdd<code class= source >	Data descriptor.</code>  keyword<code class= source >String giving the name of the keyword to get or set.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 8/2013</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_htype.html", "dat_htype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_htype.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_htype.html#dat_htype", "dat_htype", 'routine in <a href="obj/dat/dat_htype.html">dat_htype.pro</a>', "dat_htype.pro", "", "dat_htype", "<code class= source >	Returns the header type associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 9/2017</code>  <code class= source >	String giving the header type.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_fn.html", "dat_input_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_fn.html#dat_input_fn", "dat_input_fn", 'routine in <a href="obj/dat/dat_input_fn.html">dat_input_fn.pro</a>', "dat_input_fn.pro", "", "dat_input_fn", "<code class= source >	Returns the input_fn value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 10/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The input_fn value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_keyvals.html", "dat_input_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_keyvals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_keyvals.html#dat_input_keyvals", "dat_input_keyvals", 'routine in <a href="obj/dat/dat_input_keyvals.html">dat_input_keyvals.pro</a>', "dat_input_keyvals.pro", "", "dat_input_keyvals", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_transforms.html", "dat_input_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_transforms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_transforms.html#dat_input_transforms", "dat_input_transforms", 'routine in <a href="obj/dat/dat_input_transforms.html">dat_input_transforms.pro</a>', "dat_input_transforms.pro", "", "dat_input_transforms", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_input_translators.html", "dat_input_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_input_translators.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_input_translators.html#dat_input_translators", "dat_input_translators", 'routine in <a href="obj/dat/dat_input_translators.html">dat_input_translators.pro</a>', "dat_input_translators.pro", "", "dat_input_translators", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_instrument.html", "dat_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_instrument.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_instrument.html#dat_instrument", "dat_instrument", 'routine in <a href="obj/dat/dat_instrument.html">dat_instrument.pro</a>', "dat_instrument.pro", "", "dat_instrument", "<code class= source >	Returns the instrument string associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 9/2001</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The instrument string associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_keyword_fn.html", "dat_keyword_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_keyword_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_keyword_fn.html#dat_keyword_fn", "dat_keyword_fn", 'routine in <a href="obj/dat/dat_keyword_fn.html">dat_keyword_fn.pro</a>', "dat_keyword_fn.pro", "", "dat_keyword_fn", "<code class= source >	Returns the keyword_fn value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 10/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The keyword_fn value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_load_data.html", "dat_load_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_load_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_load_data.html#dat_load_data", "dat_load_data", 'routine in <a href="obj/dat/dat_load_data.html">dat_load_data.pro</a>', "dat_load_data.pro", "", "dat_load_data", "<code class= source >	Loads the data array for a given data descriptor.  Adds to</code> <code class= source >	NV state maintained list if maintain == 1.</code>  ", "sampledatadd<code class= source >Data descriptor to test.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Loaded data array.</code> <code class= source > KNOWN BUGS:</code> <code class= source >	Subsampling (ie. caching) is unreliable.  Lines or other anomalies</code> <code class= source >	often appear in subsampled images.  This does not seem to happen</code> <code class= source >	with integer sampling (e.g. integer zooms in tvim or grim), so it</code> <code class= source >	may be related to rounding or truncating of indices.  It may also be</code> <code class= source >	a problem with the set arithmetic.  Caching is currently disabled</code> <code class= source >	(see (*_dd.dd0p).cache = -1 below) until it can be fixed.</code> <code class= source > STATUS:</code> <code class= source >	Some bugs.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_io.html", "dat_lookup_io.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_io.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_io.html#dat_lookup_io", "dat_lookup_io", 'routine in <a href="obj/dat/dat_lookup_io.html">dat_lookup_io.pro</a>', "dat_lookup_io.pro", "", "dat_lookup_io", "<code class= source >	Looks up the names of the data input and output functions in</code> <code class= source >	the I/O table.</code>  ", "filetype<code class= source >Filetype string from dat_detect_filetype.</code>  input_fnoutput_fnkeyword_fn", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	input_fn:	Name of the input function.</code> <code class= source >	output_fn:	Name of the output function.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_transforms.html", "dat_lookup_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_transforms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_lookup_transforms.html#dat_lookup_transforms", "dat_lookup_transforms", 'routine in <a href="obj/dat/dat_lookup_transforms.html">dat_lookup_transforms.pro</a>', "dat_lookup_transforms.pro", "", "dat_lookup_transforms", "<code class= source >	Looks up the names of the data input and output functions in</code> <code class= source >	the I/O table.</code>  ", "tab_transformsinstrument<code class= source >Instrument string from dat_detect_instrument.</code>  input_transformsoutput_transforms", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	input_transforms:	Array giving the names of the input transform</code> <code class= source >				functions.</code> <code class= source >	output_transforms:	Array giving the names of the output transform</code> <code class= source >				functions.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_lookup_translators.html", "dat_lookup_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_lookup_translators.pro", "", "", "<code class= source >	Looks up the names of the data input and output tranlators in</code> <code class= source >	the translators table.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code>  ");
  

libdata[libdataItem++] = new Array("obj/dat/dat_maintain.html", "dat_maintain.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_maintain.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_maintain.html#dat_maintain", "dat_maintain", 'routine in <a href="obj/dat/dat_maintain.html">dat_maintain.pro</a>', "dat_maintain.pro", "", "dat_maintain", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_manage_dd.html", "dat_manage_dd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_manage_dd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_manage_dd.html#dat_manage_dd", "dat_manage_dd", 'routine in <a href="obj/dat/dat_manage_dd.html">dat_manage_dd.pro</a>', "dat_manage_dd.pro", "", "dat_manage_dd", "<code class= source >	Adds a data descriptor to the NV state maintained list.  If the list</code> <code class= source >	is full, the oldest descriptor is unloaded and removed.</code>  ", "dd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_max.html", "dat_max.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_max.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_max.html#dat_max", "dat_max", 'routine in <a href="obj/dat/dat_max.html">dat_max.pro</a>', "dat_max.pro", "", "dat_max", "<code class= source >	Returns the max value associated with a data descriptor.</code>  ", "noeventabscissadd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 10/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The max value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_min.html", "dat_min.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_min.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_min.html#dat_min", "dat_min", 'routine in <a href="obj/dat/dat_min.html">dat_min.pro</a>', "dat_min.pro", "", "dat_min", "<code class= source >	Returns the min value associated with a data descriptor.</code>  ", "noeventabscissadd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 10/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The min value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_n.html", "dat_n.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_n.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_n.html#dat_n", "dat_n", 'routine in <a href="obj/dat/dat_n.html">dat_n.pro</a>', "dat_n.pro", "", "dat_n", "<code class= source >	Returns the number of elements in the data array in the given data</code> <code class= source >	descriptor.</code>  ", "true<code class= source >If set, the dimension function is not called and the true</code> <code class= source >	 	length of the data is returned.</code>  noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 6/2017</code>  <code class= source >	Number of elements in the data in the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_ndd.html", "dat_ndd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_ndd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_ndd.html#dat_ndd", "dat_ndd", 'routine in <a href="obj/dat/dat_ndd.html">dat_ndd.pro</a>', "dat_ndd.pro", "", "dat_ndd", "<code class= source >	Returns the global maintenance ndd value.</code>  ", "dd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The global maintenance ndd value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_nhist.html", "dat_nhist.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_nhist.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_nhist.html#dat_nhist", "dat_nhist", 'routine in <a href="obj/dat/dat_nhist.html">dat_nhist.pro</a>', "dat_nhist.pro", "", "dat_nhist", "<code class= source >	Returns the number of archived data states.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Integer giving the number of past data states archived</code> <code class= source >	in the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_fn.html", "dat_output_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_fn.html#dat_output_fn", "dat_output_fn", 'routine in <a href="obj/dat/dat_output_fn.html">dat_output_fn.pro</a>', "dat_output_fn.pro", "", "dat_output_fn", "<code class= source >	Returns the output_fn value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 10/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The output_fn value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_keyvals.html", "dat_output_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_keyvals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_keyvals.html#dat_output_keyvals", "dat_output_keyvals", 'routine in <a href="obj/dat/dat_output_keyvals.html">dat_output_keyvals.pro</a>', "dat_output_keyvals.pro", "", "dat_output_keyvals", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_transforms.html", "dat_output_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_transforms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_transforms.html#dat_output_transforms", "dat_output_transforms", 'routine in <a href="obj/dat/dat_output_transforms.html">dat_output_transforms.pro</a>', "dat_output_transforms.pro", "", "dat_output_transforms", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_output_translators.html", "dat_output_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_output_translators.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_output_translators.html#dat_output_translators", "dat_output_translators", 'routine in <a href="obj/dat/dat_output_translators.html">dat_output_translators.pro</a>', "dat_output_translators.pro", "", "dat_output_translators", "<code class= source >	Returns the maintenance value associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale, 7/2008</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The maintenance value associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyval.html", "dat_parse_keyval.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_keyval.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyval.html#dat_parse_keyval", "dat_parse_keyval", 'routine in <a href="obj/dat/dat_parse_keyval.html">dat_parse_keyval.pro</a>', "dat_parse_keyval.pro", "", "dat_parse_keyval", "<code class= source >	Parses a string containing a keyword=value pair.</code>  ", "_keyval<code class= source >	String of the form &lt;keyword&gt;=&lt;value&gt;.</code>  keywordvalue", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	keyword:	String giving the keyword.</code> <code class= source >	value:		String giving the value.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_keyvals.html", "dat_parse_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_keyvals.pro", "", "", "<code class= source >	Parses an array strings containing keyword=value pairs.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code>  ");
  

libdata[libdataItem++] = new Array("obj/dat/dat_parse_transient_keyvals.html", "dat_parse_transient_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_parse_transient_keyvals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_parse_transient_keyvals.html#dat_parse_transient_keyvals", "dat_parse_transient_keyvals", 'routine in <a href="obj/dat/dat_parse_transient_keyvals.html">dat_parse_transient_keyvals.pro</a>', "dat_parse_transient_keyvals.pro", "", "dat_parse_transient_keyvals", "<code class= source >	Parses a comma-delimited transient argument string into an of array</code> <code class= source >	of strings containing keyword=value pairs.</code>  ", "trs<code class= source >Transient argument string.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Array of strings containing keyword=value pairs.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_put_value.html", "dat_put_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_put_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_put_value.html#dat_put_value", "dat_put_value", 'routine in <a href="obj/dat/dat_put_value.html">dat_put_value.pro</a>', "dat_put_value.pro", "", "dat_put_value", "<code class= source >	Calls output translators, supplying the given keyword and value.</code>  ", "trs<code class= source >	Transient argument string.</code>  status<code class= source >	0 if at least one translator call was successful,</code> <code class= source >			-1 otherwise.</code>  dd<code class= source >	Data descriptor.</code>  keyword<code class= source >Keyword to pass to translators, describing the</code> <code class= source >			requested quantity.</code>  value<code class= source >	Value to write through the translators.</code>  @nv_trs_keywords_include.pro", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_query.html", "dat_query.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_query.html#dat_query", "dat_query", 'routine in <a href="obj/dat/dat_query.html">dat_query.pro</a>', "dat_query.pro", "", "dat_query", "<code class= source >	Returns the fields associated with a CAMERA object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@dat__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_read.html", "dat_read.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_read.pro", "", "", "<code class= source >	Reads a data file of arbitrary format and produces a data descriptor.</code>  <code class= source >	dat_read expands all file specifications and then attempts to detect</code> <code class= source >	the filetype for each resulting filename using the filetype detectors</code> <code class= source >	table.  If a filetype is detected, dat_read looks up the I/O functions</code> <code class= source >	and calls the input function to read the file.  Finally, it calls</code> <code class= source >	nv_init_descriptor to obtain a data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_write</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 2/1998</code>  ");
  

libdata[libdataItem++] = new Array("obj/dat/dat_read_config.html", "dat_read_config.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_read_config.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_read_config.html#dat_read_config", "dat_read_config", 'routine in <a href="obj/dat/dat_read_config.html">dat_read_config.pro</a>', "dat_read_config.pro", "", "dat_read_config", "<code class= source >	Reads an NV configuration table.</code>  ", "continuestatusenv<code class= source >Name of an environment variable giving the names of the</code> <code class= source >		configuration files to read, delimited by ':'.</code>  table_pfilenames_p", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	table_p:	Pointer to the configuration table contructed by</code> <code class= source >			concatenating the contents of each file.</code> <code class= source >	filenames_p:	List of configuration filenames that were read.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_redo.html", "dat_redo.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_redo.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_redo.html#dat_redo", "dat_redo", 'routine in <a href="obj/dat/dat_redo.html">dat_redo.pro</a>', "dat_redo.pro", "", "dat_redo", "<code class= source >	Decrements the data archive index in the data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 7/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_replicate.html", "dat_replicate.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_replicate.html#dat_replicate", "dat_replicate", 'routine in <a href="obj/dat/dat_replicate.html">dat_replicate.pro</a>', "dat_replicate.pro", "", "dat_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "fn<code class= source >Name of the cloning function.  Default is nv_clone.</code>  dd<code class= source > Data deccriptor to replicate.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_sampling_data.html", "dat_sampling_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sampling_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_sampling_data.html#dat_sampling_data", "dat_sampling_data", 'routine in <a href="obj/dat/dat_sampling_data.html">dat_sampling_data.pro</a>', "dat_sampling_data.pro", "", "dat_sampling_data", "<code class= source >	Returns the sampling function associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The sampling_data associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_set_sampling_data</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_sampling_fn.html", "dat_sampling_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sampling_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_sampling_fn.html#dat_sampling_fn", "dat_sampling_fn", 'routine in <a href="obj/dat/dat_sampling_fn.html">dat_sampling_fn.pro</a>', "dat_sampling_fn.pro", "", "dat_sampling_fn", "<code class= source >	Returns the sampling function associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	The sampling_fn associated with the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_set_sampling_fn</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_compress.html", "dat_set_compress.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_compress.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_compress.html#dat_set_compress", "dat_set_compress", 'routine in <a href="obj/dat/dat_set_compress.html">dat_set_compress.pro</a>', "dat_set_compress.pro", "", "dat_set_compress", "<code class= source >	Replaces the name of the compression function in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  compress<code class= source >String giving the name of a new compression function.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_data.html", "dat_set_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_data.html#dat_set_data", "dat_set_data", 'routine in <a href="obj/dat/dat_set_data.html">dat_set_data.pro</a>', "dat_set_data.pro", "", "dat_set_data", "<code class= source >	Replaces the data array associated with a data descriptor.</code>  ", "update<code class= source >Update mode flag.  If not given, it will be taken from dd.</code>  noeventabscissa<code class= source >If set, the given array is taken as the abscissa.</code>  sampledd<code class= source >Data descriptor.</code>  _data<code class= source >New data array.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 2/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dd:	Modified data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dh.html", "dat_set_dh.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dh.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dh.html#dat_set_dh", "dat_set_dh", 'routine in <a href="obj/dat/dat_set_dh.html">dat_set_dh.pro</a>', "dat_set_dh.pro", "", "dat_set_dh", "<code class= source >	Replaces the dh value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  dh<code class= source >New dh value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim.html", "dat_set_dim.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dim.html#dat_set_dim", "dat_set_dim", 'routine in <a href="obj/dat/dat_set_dim.html">dat_set_dim.pro</a>', "dat_set_dim.pro", "", "dat_set_dim", "<code class= source >	Replaces the dimensions in a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  dim<code class= source >New dimensions.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_data.html", "dat_set_dim_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_data.html#dat_set_dim_data", "dat_set_dim_data", 'routine in <a href="obj/dat/dat_set_dim_data.html">dat_set_dim_data.pro</a>', "dat_set_dim_data.pro", "", "dat_set_dim_data", "<code class= source >	Replaces the dimension function data associated with a data descriptor.</code>  ", "noeventdd<code class= source >		Data descriptor.</code>  data", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dd:	Modified data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_fn.html", "dat_set_dim_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_dim_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_dim_fn.html#dat_set_dim_fn", "dat_set_dim_fn", 'routine in <a href="obj/dat/dat_set_dim_fn.html">dat_set_dim_fn.pro</a>', "dat_set_dim_fn.pro", "", "dat_set_dim_fn", "<code class= source >	Replaces the dimension function associated with a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  dim_fn<code class= source >New sampling function.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dd:	Modified data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_filename.html", "dat_set_filename.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_filename.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_filename.html#dat_set_filename", "dat_set_filename", 'routine in <a href="obj/dat/dat_set_filename.html">dat_set_filename.pro</a>', "dat_set_filename.pro", "", "dat_set_filename", "<code class= source >	Changes the file name associated with a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  filename<code class= source >New file name.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_filetype.html", "dat_set_filetype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_filetype.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_filetype.html#dat_set_filetype", "dat_set_filetype", 'routine in <a href="obj/dat/dat_set_filetype.html">dat_set_filetype.pro</a>', "dat_set_filetype.pro", "", "dat_set_filetype", "<code class= source >	Changes the file name associated with a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  filetype<code class= source >New file name.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_gd.html", "dat_set_gd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_gd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_gd.html#dat_set_gd", "dat_set_gd", 'routine in <a href="obj/dat/dat_set_gd.html">dat_set_gd.pro</a>', "dat_set_gd.pro", "", "dat_set_gd", "<code class= source >	Updates a generic descriptor contained in an object.  Similar to</code> <code class= source >	cor_set_gd, except descriptor inputs are sorted according to the</code> <code class= source >	data descriptors contained in their generic descriptors.</code>  ", "noevent_extraxd<code class= source >Objects to modify.  The fields from any existing generic</code> <code class= source >		descriptors in these objects are retained in the new ones.</code>  gd<code class= source >New generic descriptor.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_gff.html", "dat_set_gff.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_gff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_gff.html#dat_set_gff", "dat_set_gff", 'routine in <a href="obj/dat/dat_set_gff.html">dat_set_gff.pro</a>', "dat_set_gff.pro", "", "dat_set_gff", "<code class= source >	Replaces the gff value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  gff<code class= source >New gff value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_header.html", "dat_set_header.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_header.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_header.html#dat_set_header", "dat_set_header", 'routine in <a href="obj/dat/dat_set_header.html">dat_set_header.pro</a>', "dat_set_header.pro", "", "dat_set_header", "<code class= source >	Replaces the header array associated with a data descriptor.</code>  ", "update<code class= source >Update mode flag.  If not given, it will be taken from dd.</code>  noeventdd<code class= source >Data descriptor.</code>  header<code class= source >New header array.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 2/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dd:	Modified data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_htype.html", "dat_set_htype.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_htype.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_htype.html#dat_set_htype", "dat_set_htype", 'routine in <a href="obj/dat/dat_set_htype.html">dat_set_htype.pro</a>', "dat_set_htype.pro", "", "dat_set_htype", "<code class= source >	Changes the header type associated with a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  htype<code class= source >	New header type.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 9/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_fn.html", "dat_set_input_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_fn.html#dat_set_input_fn", "dat_set_input_fn", 'routine in <a href="obj/dat/dat_set_input_fn.html">dat_set_input_fn.pro</a>', "dat_set_input_fn.pro", "", "dat_set_input_fn", "<code class= source >	Replaces the input_fn value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  input_fn<code class= source >New input_fn value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_keyvals.html", "dat_set_input_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_keyvals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_keyvals.html#dat_set_input_keyvals", "dat_set_input_keyvals", 'routine in <a href="obj/dat/dat_set_input_keyvals.html">dat_set_input_keyvals.pro</a>', "dat_set_input_keyvals.pro", "", "dat_set_input_keyvals", "<code class= source >	Replaces the input_keyvals value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  input_keyvals<code class= source >New input_keyvals value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_transforms.html", "dat_set_input_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_transforms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_transforms.html#dat_set_input_transforms", "dat_set_input_transforms", 'routine in <a href="obj/dat/dat_set_input_transforms.html">dat_set_input_transforms.pro</a>', "dat_set_input_transforms.pro", "", "dat_set_input_transforms", "<code class= source >	Replaces the input_transforms value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  input_transforms<code class= source >New input_transforms value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_input_translators.html", "dat_set_input_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_input_translators.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_input_translators.html#dat_set_input_translators", "dat_set_input_translators", 'routine in <a href="obj/dat/dat_set_input_translators.html">dat_set_input_translators.pro</a>', "dat_set_input_translators.pro", "", "dat_set_input_translators", "<code class= source >	Replaces the input_translators value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  input_translators<code class= source >New input_translators value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_instrument.html", "dat_set_instrument.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_instrument.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_instrument.html#dat_set_instrument", "dat_set_instrument", 'routine in <a href="obj/dat/dat_set_instrument.html">dat_set_instrument.pro</a>', "dat_set_instrument.pro", "", "dat_set_instrument", "<code class= source >	Changes the file name associated with a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  instrument<code class= source >New instrument name.</code>  ", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_keyword_fn.html", "dat_set_keyword_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_keyword_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_keyword_fn.html#dat_set_keyword_fn", "dat_set_keyword_fn", 'routine in <a href="obj/dat/dat_set_keyword_fn.html">dat_set_keyword_fn.pro</a>', "dat_set_keyword_fn.pro", "", "dat_set_keyword_fn", "<code class= source >	Replaces the keyword_fn value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  keyword_fn<code class= source >New keyword_fn value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_maintain.html", "dat_set_maintain.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_maintain.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_maintain.html#dat_set_maintain", "dat_set_maintain", 'routine in <a href="obj/dat/dat_set_maintain.html">dat_set_maintain.pro</a>', "dat_set_maintain.pro", "", "dat_set_maintain", "<code class= source >	Replaces the maintain flag in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  maintain<code class= source >New maintain flag.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_max.html", "dat_set_max.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_max.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_max.html#dat_set_max", "dat_set_max", 'routine in <a href="obj/dat/dat_set_max.html">dat_set_max.pro</a>', "dat_set_max.pro", "", "dat_set_max", "<code class= source >	Replaces the max value in a data descriptor.</code>  ", "noeventabscissadd<code class= source >	Data descriptor.</code>  max<code class= source >New max value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_min.html", "dat_set_min.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_min.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_min.html#dat_set_min", "dat_set_min", 'routine in <a href="obj/dat/dat_set_min.html">dat_set_min.pro</a>', "dat_set_min.pro", "", "dat_set_min", "<code class= source >	Replaces the min value in a data descriptor.</code>  ", "noeventabscissadd<code class= source >	Data descriptor.</code>  min<code class= source >New min value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_ndd.html", "dat_set_ndd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_ndd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_ndd.html#dat_set_ndd", "dat_set_ndd", 'routine in <a href="obj/dat/dat_set_ndd.html">dat_set_ndd.pro</a>', "dat_set_ndd.pro", "", "dat_set_ndd", "<code class= source >	Sets a new ndd value in the NV state structure.</code>  ", "ndd<code class= source >New ndd value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_nhist.html", "dat_set_nhist.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_nhist.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_nhist.html#dat_set_nhist", "dat_set_nhist", 'routine in <a href="obj/dat/dat_set_nhist.html">dat_set_nhist.pro</a>', "dat_set_nhist.pro", "", "dat_set_nhist", "<code class= source >	Changes the number of past states archived in a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  nhist<code class= source >New nhist value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_fn.html", "dat_set_output_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_fn.html#dat_set_output_fn", "dat_set_output_fn", 'routine in <a href="obj/dat/dat_set_output_fn.html">dat_set_output_fn.pro</a>', "dat_set_output_fn.pro", "", "dat_set_output_fn", "<code class= source >	Replaces the output_fn value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  output_fn<code class= source >New output_fn value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_keyvals.html", "dat_set_output_keyvals.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_keyvals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_keyvals.html#dat_set_output_keyvals", "dat_set_output_keyvals", 'routine in <a href="obj/dat/dat_set_output_keyvals.html">dat_set_output_keyvals.pro</a>', "dat_set_output_keyvals.pro", "", "dat_set_output_keyvals", "<code class= source >	Replaces the output_keyvals value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  output_keyvals<code class= source >New output_keyvals value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_transforms.html", "dat_set_output_transforms.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_transforms.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_transforms.html#dat_set_output_transforms", "dat_set_output_transforms", 'routine in <a href="obj/dat/dat_set_output_transforms.html">dat_set_output_transforms.pro</a>', "dat_set_output_transforms.pro", "", "dat_set_output_transforms", "<code class= source >	Replaces the output_transforms value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  output_transforms<code class= source >New output_transforms value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_output_translators.html", "dat_set_output_translators.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_output_translators.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_output_translators.html#dat_set_output_translators", "dat_set_output_translators", 'routine in <a href="obj/dat/dat_set_output_translators.html">dat_set_output_translators.pro</a>', "dat_set_output_translators.pro", "", "dat_set_output_translators", "<code class= source >	Replaces the output_translators value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  output_translators<code class= source >New output_translators value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_data.html", "dat_set_sampling_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sampling_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_data.html#dat_set_sampling_data", "dat_set_sampling_data", 'routine in <a href="obj/dat/dat_set_sampling_data.html">dat_set_sampling_data.pro</a>', "dat_set_sampling_data.pro", "", "dat_set_sampling_data", "<code class= source >	Replaces the sampling function data associated with a data descriptor.</code>  ", "noeventdd<code class= source >		Data descriptor.</code>  data", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dd:	Modified data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_fn.html", "dat_set_sampling_fn.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sampling_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_sampling_fn.html#dat_set_sampling_fn", "dat_set_sampling_fn", 'routine in <a href="obj/dat/dat_set_sampling_fn.html">dat_set_sampling_fn.pro</a>', "dat_set_sampling_fn.pro", "", "dat_set_sampling_fn", "<code class= source >	Replaces the sampling function associated with a data descriptor.</code>  ", "datanoeventdd<code class= source >	Data descriptor.</code>  sampling_fn<code class= source >New sampling function.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dd:	Modified data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_sibling.html", "dat_set_sibling.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_sibling.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_sibling.html#dat_set_sibling", "dat_set_sibling", 'routine in <a href="obj/dat/dat_set_sibling.html">dat_set_sibling.pro</a>', "dat_set_sibling.pro", "", "dat_set_sibling", "<code class= source >	Changes the sibling in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  dd_sibling<code class= source >Data descriptor of new sibling.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_slice.html", "dat_set_slice.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_slice.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_slice.html#dat_set_slice", "dat_set_slice", 'routine in <a href="obj/dat/dat_set_slice.html">dat_set_slice.pro</a>', "dat_set_slice.pro", "", "dat_set_slice", "<code class= source >	Sets slice coordinates in a data descriptor.</code>  ", "new<code class= source >If set, a new slice pointer is allocated instead of overwriting</code> <code class= source >		the exiting data.</code>  dd<code class= source >Data descriptorin which to set the slice coordinates.</code>  dd0<code class= source >Data descriptorin describing the source data array.</code>  slice<code class= source >Array giving the slice coordinates.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale		6/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_typecode.html", "dat_set_typecode.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_typecode.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_typecode.html#dat_set_typecode", "dat_set_typecode", 'routine in <a href="obj/dat/dat_set_typecode.html">dat_set_typecode.pro</a>', "dat_set_typecode.pro", "", "dat_set_typecode", "<code class= source >	Replaces the typecode value in a data descriptor.</code>  ", "noeventdd<code class= source >	Data descriptor.</code>  typecode<code class= source >New typecode value.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_set_update.html", "dat_set_update.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_set_update.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_set_update.html#dat_set_update", "dat_set_update", 'routine in <a href="obj/dat/dat_set_update.html">dat_set_update.pro</a>', "dat_set_update.pro", "", "dat_set_update", "<code class= source >	Changes the update flag in a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  update<code class= source >New update flag.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_sibling.html", "dat_sibling.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_sibling.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_sibling.html#dat_sibling", "dat_sibling", 'routine in <a href="obj/dat/dat_sibling.html">dat_sibling.pro</a>', "dat_sibling.pro", "", "dat_sibling", "<code class= source >	Returns the sibling data descriptor associated with a data</code> <code class= source >	descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Data descriptor of the sibling.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_slice.html", "dat_slice.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slice.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_slice.html#dat_slice", "dat_slice", 'routine in <a href="obj/dat/dat_slice.html">dat_slice.pro</a>', "dat_slice.pro", "", "dat_slice", "<code class= source >	Returns the slice coordinates for the given data descriptor.</code>  ", "dd0noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 6/2017</code>  <code class= source >	Array giving the slice coordinates for the data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_slices.html", "dat_slices.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_slices.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_slices.html#dat_slices", "dat_slices", 'routine in <a href="obj/dat/dat_slices.html">dat_slices.pro</a>', "dat_slices.pro", "", "dat_slices", "<code class= source >	Creates new data descriptors that point to subarray slices in a given</code> <code class= source >	data descriptor.</code>  ", "dd0slice<code class= source >m x n array giving coordinates of n m-dimensional arrays to</code> <code class= source >		select. If not given, the original data array is sliced into</code> <code class= source >		arrays of one dimension smaller, i.e., a cube is sliced</code> <code class= source >		into its constituent images, and an image is sliced into its</code> <code class= source >		constituent lines etc.</code>  ", "NV/OBJ/DAT", "<code class= source > 	Written by:	Spitale		6/2017</code>  <code class= source >	1) Extract the ith image of a 3-dimensional data cube:</code> <code class= source >		new_dd = dat_slices(dd, i)</code> <code class= source >	2) Extract the ith cube of a 4-dimensional data array:</code> <code class= source >		new_dd = dat_slices(dd, i)</code> <code class= source >	3) Extract the ith image in the jth cube of a 4-dimensional data array:</code> <code class= source >		new_dd = dat_slices(dd, [i,j])</code> <code class= source >	New data descriptors for the selected data arrays.  Dimensions are N - m.</code> <code class= source >	Note that new data arrays are not allocated.  Instead, the returned</code> <code class= source >	descriptors point to the subarray within the data array of the input</code> <code class= source >	data descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_test_dd.html", "dat_test_dd.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_test_dd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_test_dd.html#dat_test_dd", "dat_test_dd", 'routine in <a href="obj/dat/dat_test_dd.html">dat_test_dd.pro</a>', "dat_test_dd.pro", "", "dat_test_dd", "<code class= source >	Determines whether the argument is a valid data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor to test.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	True if the argument is present, is a valid pointer, and</code> <code class= source >	points to a data descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_typecode.html", "dat_typecode.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_typecode.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_typecode.html#dat_typecode", "dat_typecode", 'routine in <a href="obj/dat/dat_typecode.html">dat_typecode.pro</a>', "dat_typecode.pro", "", "dat_typecode", "<code class= source >	Returns the type code associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Integer giving the typecode.</code> <code class= source > STATUS: Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_undo.html", "dat_undo.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_undo.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_undo.html#dat_undo", "dat_undo", 'routine in <a href="obj/dat/dat_undo.html">dat_undo.pro</a>', "dat_undo.pro", "", "dat_undo", "<code class= source >	Increments the data archive index in the data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_unload_data.html", "dat_unload_data.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_unload_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_unload_data.html#dat_unload_data", "dat_unload_data", 'routine in <a href="obj/dat/dat_unload_data.html">dat_unload_data.pro</a>', "dat_unload_data.pro", "", "dat_unload_data", "<code class= source >	Unloads the dat descriptor data array and removes dd from the NV</code> <code class= source >	state maintained list if present.</code>  ", "all<code class= source >If set, all maintained data descriptors are unloaded.</code>  dd<code class= source >Data descriptor to test.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_update.html", "dat_update.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_update.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_update.html#dat_update", "dat_update", 'routine in <a href="obj/dat/dat_update.html">dat_update.pro</a>', "dat_update.pro", "", "dat_update", "<code class= source >	Returns the update flag associated with a data descriptor.</code>  ", "noeventdd<code class= source >Data descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Data descriptor update flag.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_valid_descriptor.html", "dat_valid_descriptor.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_valid_descriptor.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_valid_descriptor.html#dat_valid_descriptor", "dat_valid_descriptor", 'routine in <a href="obj/dat/dat_valid_descriptor.html">dat_valid_descriptor.pro</a>', "dat_valid_descriptor.pro", "", "dat_valid_descriptor", "<code class= source >	Determines whether the argument is a valid data descriptor,</code> <code class= source >	or data descriptor structure.</code>  ", "ddp", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	True if the argument is a data descriptor structure or a</code> <code class= source >	pointer to one.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dat_write.html", "dat_write.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "dat_write.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dat_write.html#dat_write", "dat_write", 'routine in <a href="obj/dat/dat_write.html">dat_write.pro</a>', "dat_write.pro", "", "dat_write", "<code class= source >	Writes a data file of arbitrary format.</code>  <code class= source >	dat_write expands all file specifications and attempts to write a</code> <code class= source >	file corresponding to each given data descriptor.  An error results</code> <code class= source >	if the filespec expands to a different number of files than the number</code> <code class= source >	of given data descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dat_read</code>  ", "nodatafiletype<code class= source >Overrides data descriptor filetype (and thus the</code> <code class= source >			output function).  Data descriptor filetype is</code> <code class= source >			updated unless /override.</code>  output_fn<code class= source >Overrides data descriptor output function.  Data</code> <code class= source >			descriptor output_fn is updated unless /override.</code>  override<code class= source >If set, filespec, filetype, and output_fn inputs</code> <code class= source >			are used for this call, but not updated in the data</code> <code class= source >			descriptor.</code>  arg1arg2", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create.html", "dh_create.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_create.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create.html#dh_create", "dh_create", 'routine in <a href="obj/dat/dh/util/dh_create.html">dh_create.pro</a>', "dh_create.pro", "", "dh_create", "<code class= source >	Creates a minimal detached header.</code>  <code class= source >	dh_create creates a detached header containing a history line and</code> <code class= source >	the '&lt;updates&gt;' separator.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "", "UTIL/DH", "<code class= source > 	Written by:	Spitale, 7/1998</code>  <code class= source >	String array in which each element is a line of the detached header.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create_section.html", "dh_create_section.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_create_section.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_create_section.html#dh_create_section", "dh_create_section", 'routine in <a href="obj/dat/dh/util/dh_create_section.html">dh_create_section.pro</a>', "dh_create_section.pro", "", "dh_create_section", "<code class= source >	Creates a minimal detached header section.</code>  ", "section<code class= source >Name of section to create.</code>  ", "UTIL/DH", "<code class= source > 	Written by:	Spitale, 12/2016</code>  <code class= source >	String array in which each element is a line of the new section.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_get_value.html", "dh_get_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_get_value.pro", "", "", "<code class= source >	Gets the value of a specified keyword.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 7/1998</code> <code class= source >	Added 'section' keyword: Spitale; 11/2001</code>  ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_put_value.html", "dh_put_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_put_value.pro", "", "", "<code class= source >	Sets the value of a specified keyword.</code>  <code class= source >	See procedure below; 'utime' and 'history' keywords are modified.</code>  <code class= source >	The data is appended to the top of the specified section of the detached</code> <code class= source >	header using the given object index and a history index that is one</code> <code class= source >	greater than the current value found in the detached header for this</code> <code class= source >	keyword.  The value of the 'utime' keyword corresponding to this history</code> <code class= source >	index is modified to reflect the current time.  If this history index is</code> <code class= source >	greater than that given by the 'history' keyword, then that value is</code> <code class= source >	modified as well.</code> <code class= source >	If 'value' is an array, then each element is written on a different line</code> <code class= source >	using the keyword with the same object index, history index, and</code> <code class= source >	comment, but whose element indices reflect the order that the data</code> <code class= source >	appear in the array.</code> <code class= source >	If 'value' is of string type, then each entry is enclosed in quotes.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 7/1998</code> <code class= source >	Added 'section' keyword: Spitale; 11/2001</code>  <code class= source >	The following commands:</code> 		<span class= code-prompt >IDL&gt;</span> val=[7,6,5,4,3] 		<span class= code-prompt >IDL&gt;</span> dh_put_value, dh, 'test_key', val <code class= source >	produce the following detached header:</code> <code class= source >	 history = -1 / Current history value</code> <code class= source >	 &lt;updates&gt;</code> <code class= source >	 utime = 2451022.404086 / Julian day of update - Mon Jul 27 9:41:53 1998</code> <code class= source >	 test_key(0) = 7</code> <code class= source >	 test_key(1) = 6</code> <code class= source >	 test_key(2) = 5</code> <code class= source >	 test_key(3) = 4</code> <code class= source >	 test_key(4) = 3</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dh_get_value, dh_rm_value</code> ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_read.html", "dh_read.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_read.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_read.html#dh_read", "dh_read", 'routine in <a href="obj/dat/dh/util/dh_read.html">dh_read.pro</a>', "dh_read.pro", "", "dh_read", "<code class= source >	Reads a detached header file.</code>  ", "buflen<code class= source >	Number of lines to allocate at a time.  Default is 1000.</code> <code class= source >			The routine is faster with larger values of buflen, but</code> <code class= source >			less memory efficient.</code>  status<code class= source >	0 if file found, -1 if not.</code>  filename<code class= source >Name of file to be read.</code>  ", "UTIL/DH", "<code class= source > 	Written by:	Spitale, 7/1998</code>  <code class= source >	String array in which each line is a line of the detached header.</code> <code class= source >	a blank detached header is created and returned if the file is</code> <code class= source >	not found.  In that case, status is set to -1.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dh_write</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_rm_value.html", "dh_rm_value.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_rm_value.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_rm_value.html#dh_rm_value", "dh_rm_value", 'routine in <a href="obj/dat/dh/util/dh_rm_value.html">dh_rm_value.pro</a>', "dh_rm_value.pro", "", "dh_rm_value", "<code class= source >	Deletes a specified keyword/value pair.</code>  ", "n_match<code class= source >Maximum number of matches to return.  If not given,</code> <code class= source >			all matches are returned.</code>  all_match<code class= source >If set, match all occurrences.</code>  all_object<code class= source >If set, match all object indices.  If not set, then</code> <code class= source >			match only object index 0.</code>  all_history<code class= source >If set, match all history indices.  If not set,</code> <code class= source >			then only the highest history index is matched.</code>  count<code class= source >	Integer giving the numebr of keywords matched.</code>  object_index<code class= source >If given, then match only this object index.</code>  history_index<code class= source >If given, then match only this history index.</code>  prefix<code class= source >	If set, then match any keyword which begins with the</code> <code class= source >			given keyword string instead of requiring an exact</code> <code class= source >			match.</code>  dh<code class= source >	String giving the detached header.</code>  keyword<code class= source >String giving the keyword to be deleted.</code>  ", "UTIL/DH", "<code class= source > 	Written by:	Spitale, 7/1998</code>  <code class= source >	dh:		dh is modified on return.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_input.html", "dh_std_input.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_std_input.pro", "", "", "<code class= source >	Input translator for detached header</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1998</code>  ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/dh_std_output.html", "dh_std_output.pro", '.pro file in <a href="obj/dat/dh/dir-overview.html">obj/dat/dh/ directory</a>', "dh_std_output.pro", "", "", "<code class= source >	Output translator for detached headers.</code>  <code class= source >	The detached header in the data descriptor is modified.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dh_std_input</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1998</code>  ");
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_validate.html", "dh_validate.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_validate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_validate.html#dh_validate", "dh_validate", 'routine in <a href="obj/dat/dh/util/dh_validate.html">dh_validate.pro</a>', "dh_validate.pro", "", "dh_validate", "<code class= source >	Validates a detached header.</code>  ", "dh<code class= source >	String array containing the detached header.</code>  ", "DAT/DH", "<code class= source > 	Written by:	Spitale, 7/2017</code>  <code class= source >	1 if valid, 0 otherwise.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	dh_write</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_write.html", "dh_write.pro", '.pro file in <a href="obj/dat/dh/util/dir-overview.html">obj/dat/dh/util/ directory</a>', "dh_write.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/dh/util/dh_write.html#dh_write", "dh_write", 'routine in <a href="obj/dat/dh/util/dh_write.html">dh_write.pro</a>', "dh_write.pro", "", "dh_write", "<code class= source >	Writes a detached header file.</code>  ", "filename<code class= source >Name of file to be written.</code>  dh<code class= source >	String array giving the detached header to write.</code>  ", "UTIL/DH", "<code class= source > 	Written by:	Spitale, 7/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_image.html", "disk_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_image.html#disk_to_image", "disk_to_image", 'routine in <a href="obj/tools/composite/disk_to_image.html">disk_to_image.pro</a>', "disk_to_image.pro", "", "disk_to_image", "<code class= source >       Transforms points in disk coordinates to image coordinates</code>  ", "body_pts<code class= source >Body coordinates of output points.</code>  valid<code class= source >Indices of valid output points.</code>  cd<code class= source >      Array of nt camera or map descriptors.</code>  dkx<code class= source >     Array of nt object descriptors (subclass of DISK).</code>  p<code class= source >      Array (nv x 3 x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of image coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_inertial_pos.html", "disk_to_inertial_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_inertial_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_inertial_pos.html#disk_to_inertial_pos", "disk_to_inertial_pos", 'routine in <a href="obj/tools/composite/disk_to_inertial_pos.html">disk_to_inertial_pos.pro</a>', "disk_to_inertial_pos.pro", "", "disk_to_inertial_pos", "<code class= source >       Transforms position vectors in disk coordinates to inertial</code> <code class= source >	coordinates.</code>  ", "rdp", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array (nv x 3 x nt) of inertial points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_map.html", "disk_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "disk_to_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/disk_to_map.html#disk_to_map", "disk_to_map", 'routine in <a href="obj/tools/composite/disk_to_map.html">disk_to_map.pro</a>', "disk_to_map.pro", "", "disk_to_map", "<code class= source >       Transforms points in disk coordinates to map coordinates.</code>  ", "md<code class= source >     Array of nt map descriptors.</code>  dkddisk_pts<code class= source >      Array (nv x 3 x nt) of disk points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of map coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_apply_radial_scale.html", "dsk_apply_radial_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_apply_radial_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_apply_radial_scale.html#dsk_apply_radial_scale", "dsk_apply_radial_scale", 'routine in <a href="obj/dsk/dsk_apply_radial_scale.html">dsk_apply_radial_scale.pro</a>', "dsk_apply_radial_scale.pro", "", "dsk_apply_radial_scale", "<code class= source >	Computes scaled radii.</code>  ", "inverse<code class= source >If set, the operation is performed in reverse.</code>  noeventdkd<code class= source > A single disk descriptors.</code>  radii<code class= source > Array of radii to convert.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Scaled radii based on the scale parameters in the disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_assign.html", "dsk_assign.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_assign.html#dsk_assign", "dsk_assign", 'routine in <a href="obj/dsk/dsk_assign.html">dsk_assign.pro</a>', "dsk_assign.pro", "", "dsk_assign", "<code class= source >	Replaces fields in a DISK object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@dsk__keywords_tree.include", "NV/OBJ/DSK", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_body_to_disk.html", "dsk_body_to_disk.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_body_to_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_body_to_disk.html#dsk_body_to_disk", "dsk_body_to_disk", 'routine in <a href="obj/dsk/dsk_body_to_disk.html">dsk_body_to_disk.pro</a>', "dsk_body_to_disk.pro", "", "dsk_body_to_disk", "<code class= source >	Transforms vectors from the body coordinate system to the disk</code> <code class= source >	coordinate system.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  v", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x 3 x nt) of column vectors in the disk coordinate system.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_cat.html", "dsk_cat.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_cat.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_cat.html#dsk_cat", "dsk_cat", 'routine in <a href="obj/tools/dsk_cat.html">dsk_cat.pro</a>', "dsk_cat.pro", "", "dsk_cat", "<code class= source >	Concatenates the given disk descriptors into one descriptor encompassing</code> <code class= source >	the entire system.</code>  ", "dkxs", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	A descriptor of the same class as dkx whose semimajor axes</code> <code class= source >	encompass the all of the input disks.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_cat_by_name.html", "dsk_cat_by_name.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_cat_by_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_cat_by_name.html#dsk_cat_by_name", "dsk_cat_by_name", 'routine in <a href="obj/tools/dsk_cat_by_name.html">dsk_cat_by_name.pro</a>', "dsk_cat_by_name.pro", "", "dsk_cat_by_name", "<code class= source >	Concatenates the given disk descriptors into one descriptor</code> <code class= source >	encompassing all of the named descriptors.</code>  ", "dkxsnames<code class= source >Array of names of disks to concatenate.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	A descriptor of the same class as dkx whose semimajor axes</code> <code class= source >	encompass the all of the named input disks.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_create_descriptors.html", "dsk_create_descriptors.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_create_descriptors.html#dsk_create_descriptors", "dsk_create_descriptors", 'routine in <a href="obj/dsk/dsk_create_descriptors.html">dsk_create_descriptors.pro</a>', "dsk_create_descriptors.pro", "", "dsk_create_descriptors", "<code class= source >	Init method for the DISK class.</code>  ", "crdbdslddkdn<code class= source >Number of descriptors to create.</code>  @dsk__keywords_tree.include", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created or or freshly initialized disk descriptors, depending</code> <code class= source >	on the presence of the dkd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dap.html", "dsk_dap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dap.html#dsk_dap", "dsk_dap", 'routine in <a href="obj/dsk/dsk_dap.html">dsk_dap.pro</a>', "dsk_dap.pro", "", "dsk_dap", "<code class= source >	Returns dap for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	dap value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_disk_to_body.html", "dsk_disk_to_body.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_disk_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_disk_to_body.html#dsk_disk_to_body", "dsk_disk_to_body", 'routine in <a href="obj/dsk/dsk_disk_to_body.html">dsk_disk_to_body.pro</a>', "dsk_disk_to_body.pro", "", "dsk_disk_to_body", "<code class= source >	Transforms vectors from the disk coordinate system to the body</code> <code class= source >	coordinate system.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  v", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x 3 x nt) of column vectors in the body coordinate system.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibldt.html", "dsk_dlibldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dlibldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibldt.html#dsk_dlibldt", "dsk_dlibldt", 'routine in <a href="obj/dsk/dsk_dlibldt.html">dsk_dlibldt.pro</a>', "dsk_dlibldt.pro", "", "dsk_dlibldt", "<code class= source >	Returns dlibldt for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dlibldt value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibmdt.html", "dsk_dlibmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dlibmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dlibmdt.html#dsk_dlibmdt", "dsk_dlibmdt", 'routine in <a href="obj/dsk/dsk_dlibmdt.html">dsk_dlibmdt.pro</a>', "dsk_dlibmdt.pro", "", "dsk_dlibmdt", "<code class= source >	Returns dlibmdt for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dlibmdt value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dtaanldt.html", "dsk_dtaanldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dtaanldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dtaanldt.html#dsk_dtaanldt", "dsk_dtaanldt", 'routine in <a href="obj/dsk/dsk_dtaanldt.html">dsk_dtaanldt.pro</a>', "dsk_dtaanldt.pro", "", "dsk_dtaanldt", "<code class= source >	Returns dtaanldt for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	dtaanldt value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_dtapmdt.html", "dsk_dtapmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_dtapmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_dtapmdt.html#dsk_dtapmdt", "dsk_dtapmdt", 'routine in <a href="obj/dsk/dsk_dtapmdt.html">dsk_dtapmdt.pro</a>', "dsk_dtapmdt.pro", "", "dsk_dtapmdt", "<code class= source >	Returns dtapmdt for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	dtapmdt value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_ecc.html", "dsk_ecc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_ecc.html#dsk_ecc", "dsk_ecc", 'routine in <a href="obj/dsk/dsk_ecc.html">dsk_ecc.pro</a>', "dsk_ecc.pro", "", "dsk_ecc", "<code class= source >	Returns ecc for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	ecc value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_em.html", "dsk_em.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_em.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_em.html#dsk_em", "dsk_em", 'routine in <a href="obj/dsk/dsk_em.html">dsk_em.pro</a>', "dsk_em.pro", "", "dsk_em", "<code class= source >	Returns em for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	em value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_evolve.html", "dsk_evolve.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_evolve.html#dsk_evolve", "dsk_evolve", 'routine in <a href="obj/dsk/dsk_evolve.html">dsk_evolve.pro</a>', "dsk_evolve.pro", "", "dsk_evolve", "<code class= source >	Computes new disk descriptors at the given time offsets from the</code> <code class= source >	given disk descriptors using the taylor series expansion</code> <code class= source >	corresponding to the derivatives contained in the given disk</code> <code class= source >	descriptor.</code>  ", "nodv<code class= source > If set, derivatives will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  dkd<code class= source > Any subclass of DISK.</code>  dt<code class= source > Time offset.</code>  ", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (ndkd,ndt) of newly allocated descriptors, of class DISK,</code> <code class= source >	evolved by time dt, where ndkd is the number of dkd, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ap.html", "dsk_get_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ap.html#dsk_get_ap", "dsk_get_ap", 'routine in <a href="obj/dsk/dsk_get_ap.html">dsk_get_ap.pro</a>', "dsk_get_ap.pro", "", "dsk_get_ap", "<code class= source >	Determines ap for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	ap value associated with each given disk descriptor.  One for each dkd.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dapdt.html", "dsk_get_dapdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dapdt.html#dsk_get_dapdt", "dsk_get_dapdt", 'routine in <a href="obj/dsk/dsk_get_dapdt.html">dsk_get_dapdt.pro</a>', "dsk_get_dapdt.pro", "", "dsk_get_dapdt", "<code class= source >	Determines dapdt for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dapdt value associated with each given disk descriptor.  One for each dkd.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_disk_points.html", "dsk_get_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_disk_points.pro", "", "", "<code class= source >	Computes points on the inner and outer edges of a disk.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlandt.html", "dsk_get_dlandt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlandt.html#dsk_get_dlandt", "dsk_get_dlandt", 'routine in <a href="obj/dsk/dsk_get_dlandt.html">dsk_get_dlandt.pro</a>', "dsk_get_dlandt.pro", "", "dsk_get_dlandt", "<code class= source >	Determines dlandt for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dlandt value associated with each given disk descriptor.  One for each dkd.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_ap.html", "dsk_get_dlibdt_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_ap.html#dsk_get_dlibdt_ap", "dsk_get_dlibdt_ap", 'routine in <a href="obj/dsk/dsk_get_dlibdt_ap.html">dsk_get_dlibdt_ap.pro</a>', "dsk_get_dlibdt_ap.pro", "", "dsk_get_dlibdt_ap", "<code class= source >	Determines dlibdt_ap for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dlibdt_ap value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_lan.html", "dsk_get_dlibdt_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_dlibdt_lan.html#dsk_get_dlibdt_lan", "dsk_get_dlibdt_lan", 'routine in <a href="obj/dsk/dsk_get_dlibdt_lan.html">dsk_get_dlibdt_lan.pro</a>', "dsk_get_dlibdt_lan.pro", "", "dsk_get_dlibdt_lan", "<code class= source >	Determines dlibdt_lan for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	dlibdt_lan value associated with each given disk descriptor.  One for each dkd.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_elevation.html", "dsk_get_edge_elevation.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_edge_elevation.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_elevation.html#dsk_get_edge_elevation", "dsk_get_edge_elevation", 'routine in <a href="obj/dsk/dsk_get_edge_elevation.html">dsk_get_edge_elevation.pro</a>', "dsk_get_edge_elevation.pro", "", "dsk_get_edge_elevation", "<code class= source >	Computes elevations along the edge of a disk.</code>  ", "inner<code class= source >If set, the inner edge is used.</code>  outer<code class= source >If set, the outer edge is used.</code>  one_to_onenoeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  ta<code class= source > Array (nta) of true anomalies at which to compute elevations.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt x nta) of elevations computed at each true anomaly on each</code> <code class= source >	disk.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_radius.html", "dsk_get_edge_radius.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_edge_radius.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_edge_radius.html#dsk_get_edge_radius", "dsk_get_edge_radius", 'routine in <a href="obj/dsk/dsk_get_edge_radius.html">dsk_get_edge_radius.pro</a>', "dsk_get_edge_radius.pro", "", "dsk_get_edge_radius", "<code class= source >	Computes radii along the edge of a disk.</code>  ", "inner<code class= source >If set, the inner edge is used.</code>  outer<code class= source >If set, the outer edge is used.</code>  timenoeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  ta<code class= source > Array (nv x nt) of true anomalies at which to compute radii.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x nt) of radii computed at each true anomaly on each</code> <code class= source >	disk.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inc.html", "dsk_get_inc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_inc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inc.html#dsk_get_inc", "dsk_get_inc", 'routine in <a href="obj/dsk/dsk_get_inc.html">dsk_get_inc.pro</a>', "dsk_get_inc.pro", "", "dsk_get_inc", "<code class= source >	Determines inc for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	inc value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inner_disk_points.html", "dsk_get_inner_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_inner_disk_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_inner_disk_points.html#dsk_get_inner_disk_points", "dsk_get_inner_disk_points", 'routine in <a href="obj/dsk/dsk_get_inner_disk_points.html">dsk_get_inner_disk_points.pro</a>', "dsk_get_inner_disk_points.pro", "", "dsk_get_inner_disk_points", "<code class= source >	Computes points on the inner edge of a disk.</code>  ", "ta<code class= source >True anomalies for the points.  Default is the full circle.</code>  disk_ptsdkd<code class= source > Array (nt) of any subclass of DISK.</code>  n_points", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (np x 3 x nt) of points on the outer edge of each disk,</code> <code class= source >	in disk body coordinates.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lan.html", "dsk_get_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lan.html#dsk_get_lan", "dsk_get_lan", 'routine in <a href="obj/dsk/dsk_get_lan.html">dsk_get_lan.pro</a>', "dsk_get_lan.pro", "", "dsk_get_lan", "<code class= source >	Determines lan for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	lan value associated with each given disk descriptor.  One for each dkd.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_ap.html", "dsk_get_lib_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lib_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_ap.html#dsk_get_lib_ap", "dsk_get_lib_ap", 'routine in <a href="obj/dsk/dsk_get_lib_ap.html">dsk_get_lib_ap.pro</a>', "dsk_get_lib_ap.pro", "", "dsk_get_lib_ap", "<code class= source >	Determines lib_ap for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	lib_ap value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_lan.html", "dsk_get_lib_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_lib_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_lib_lan.html#dsk_get_lib_lan", "dsk_get_lib_lan", 'routine in <a href="obj/dsk/dsk_get_lib_lan.html">dsk_get_lib_lan.pro</a>', "dsk_get_lib_lan.pro", "", "dsk_get_lib_lan", "<code class= source >	Determines lib_lan for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	lib_lan value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_ap.html", "dsk_get_liba_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_liba_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_ap.html#dsk_get_liba_ap", "dsk_get_liba_ap", 'routine in <a href="obj/dsk/dsk_get_liba_ap.html">dsk_get_liba_ap.pro</a>', "dsk_get_liba_ap.pro", "", "dsk_get_liba_ap", "<code class= source >	Determines liba_ap for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	liba_ap value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_lan.html", "dsk_get_liba_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_liba_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_liba_lan.html#dsk_get_liba_lan", "dsk_get_liba_lan", 'routine in <a href="obj/dsk/dsk_get_liba_lan.html">dsk_get_liba_lan.pro</a>', "dsk_get_liba_lan.pro", "", "dsk_get_liba_lan", "<code class= source >	Determines liba_lan for each given disk descriptor, based on the</code> <code class= source >	orientation of its BODY axes.</code>  ", "dkdframe_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	liba_lan value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nl.html", "dsk_get_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_nl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nl.html#dsk_get_nl", "dsk_get_nl", 'routine in <a href="obj/dsk/dsk_get_nl.html">dsk_get_nl.pro</a>', "dsk_get_nl.pro", "", "dsk_get_nl", "<code class= source >	Obtains the nl (number of vertical harmonics) value from the enironment.</code>  <code class= source >Environment variables: </code> <code class= source >	DSK_NL:		Sets the nl value.</code>  ", "", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Value for nl obtained from the DSK_NL environmet variable.  Default</code> <code class= source >	is 4.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nm.html", "dsk_get_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_nm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_nm.html#dsk_get_nm", "dsk_get_nm", 'routine in <a href="obj/dsk/dsk_get_nm.html">dsk_get_nm.pro</a>', "dsk_get_nm.pro", "", "dsk_get_nm", "<code class= source >	Obtains the nm (number of radial harmonics) value from the enironment.</code>  <code class= source >Environment variables: </code> <code class= source >	DSK_NM:		Sets the nm value.</code>  ", "", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Value for nm obtained from the DSK_NM environmet variable.  Default</code> <code class= source >	is 4.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_node.html", "dsk_get_node.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_node.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_node.html#dsk_get_node", "dsk_get_node", 'routine in <a href="obj/dsk/dsk_get_node.html">dsk_get_node.pro</a>', "dsk_get_node.pro", "", "dsk_get_node", "<code class= source >	Computes the ascending node of the given disk wrt the given frame</code> <code class= source >	body descriptor.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	One unit vector for each input descriptor pointng along the</code> <code class= source >	ascending node of each given disk on each given frame</code> <code class= source >	body descriptor.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_outer_disk_points.html", "dsk_get_outer_disk_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_outer_disk_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_outer_disk_points.html#dsk_get_outer_disk_points", "dsk_get_outer_disk_points", 'routine in <a href="obj/dsk/dsk_get_outer_disk_points.html">dsk_get_outer_disk_points.pro</a>', "dsk_get_outer_disk_points.pro", "", "dsk_get_outer_disk_points", "<code class= source >	Computes points on the outer edge of a disk.</code>  ", "ta<code class= source >True anomalies for the points.  Default is the full circle.</code>  disk_ptsdkd<code class= source > Array (nt) of any subclass of DISK.</code>  n_points", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (np x 3 x nt) of points on the outer edge of each disk,</code> <code class= source >	in disk body coordinates.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_get_perp.html", "dsk_get_perp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_get_perp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_get_perp.html#dsk_get_perp", "dsk_get_perp", 'routine in <a href="obj/tools/dsk_get_perp.html">dsk_get_perp.pro</a>', "dsk_get_perp.pro", "", "dsk_get_perp", "<code class= source >	Computes vectors in the direction perpendicular to the azimuthal</code> <code class= source >	direction at a point on a disk.</code>  ", "uucd<code class= source >Camera descriptor.</code>  dkdp<code class= source >Point on the disk n inertial coordinates.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (nv,3) of inertial direction vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_radius.html", "dsk_get_radius.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_radius.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_radius.html#dsk_get_radius", "dsk_get_radius", 'routine in <a href="obj/dsk/dsk_get_radius.html">dsk_get_radius.pro</a>', "dsk_get_radius.pro", "", "dsk_get_radius", "<code class= source >	Computes radii along the inner and outer edges of a disk.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  ta<code class= source > Array (nv x nt) of true anomalies at which to compute radii.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x 2 x nt) of radii computed at each true anomaly on each</code> <code class= source >	disk.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ranges.html", "dsk_get_ranges.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_get_ranges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_get_ranges.html#dsk_get_ranges", "dsk_get_ranges", 'routine in <a href="obj/dsk/dsk_get_ranges.html">dsk_get_ranges.pro</a>', "dsk_get_ranges.pro", "", "dsk_get_ranges", "<code class= source >	Returns ranges of valid coordinates for the given DISK object.</code>  ", "dkd<code class= source > Any subclass of DISK.  One descriptor only.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2 x 3) giving the ranges in radius, true anomaly and altitude.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_hide_points.html", "dsk_hide_points.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_hide_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_hide_points.html#dsk_hide_points", "dsk_hide_points", 'routine in <a href="obj/dsk/dsk_hide_points.html">dsk_hide_points.pro</a>', "dsk_hide_points.pro", "", "dsk_hide_points", "<code class= source >	Hides points wrt a DISK object.</code>  ", "rm<code class= source >If set, points are flagged for being in front of or behind</code> <code class= source >		the disk, rather then just behind it.</code>  epsilon<code class= source >		Distance in front of the disk for a point to be</code> <code class= source >		considered  in front of  the disk.  Default is 1.</code>  dkd<code class= source > Array (nt) of any subclass of DISK.</code>  r<code class= source > Column vector giving the position of the viewer in the disk</code> <code class= source >		 body frame.</code>  points<code class= source > Array (nv x 3 x nt) of points to test, given in the disk</code> <code class= source >		 body frame</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array Subscripts of all input vectors (points argument) that are hidden</code> <code class= source >	from the viewer at r by the given disk.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_il.html", "dsk_il.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_il.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_il.html#dsk_il", "dsk_il", 'routine in <a href="obj/dsk/dsk_il.html">dsk_il.pro</a>', "dsk_il.pro", "", "dsk_il", "<code class= source >	Returns il for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	il value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_image_bounds.html", "dsk_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_image_bounds.html#dsk_image_bounds", "dsk_image_bounds", 'routine in <a href="obj/tools/dsk_image_bounds.html">dsk_image_bounds.pro</a>', "dsk_image_bounds.pro", "", "dsk_image_bounds", "<code class= source >	Determines disk coordinate ranges visible in an image described</code> <code class= source >	by a given camera descriptor.</code>  ", "slopborder_pts_imradminradmaxlonminlonmaxnpplanestatuscropcd<code class= source >Camera descripor.</code>  dkx<code class= source >Any subclass of DISK.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	radmin:	Minimum disk radius in image.</code> <code class= source >	radmax:	Maximum disk radius in image.</code> <code class= source >	lonmin:	Minimum disk longitude in image.</code> <code class= source >	lonmax:	Maximum disk longitude in image.</code> <code class= source >	border_pts_im:	Array (2,np) of points along the edge of the image.</code> <code class= source >	status:	-1 if no disk in the image, 0 otherwise.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect.html", "dsk_intersect.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_intersect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect.html#dsk_intersect", "dsk_intersect", 'routine in <a href="obj/dsk/dsk_intersect.html">dsk_intersect.pro</a>', "dsk_intersect.pro", "", "dsk_intersect", "<code class= source >	Computes ray intersections with a DISK object.</code>  ", "thitmissepsilondkd<code class= source > Array (nt) of any subclass of DISK.</code>  view_pts<code class= source >rray (nv x 3 x nt) of column vectors giving the origins</code> <code class= source >		 of the rays in the body frame.</code>  _ray_pts<code class= source >Array (nv x 3 x nt) of column vectors giving the directions</code> <code class= source >		 of the rays in the body frame.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x 3 x nt) of column vectors giving the ray/disk</code> <code class= source >	intersections in the body frame.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect_inertial.html", "dsk_intersect_inertial.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_intersect_inertial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_intersect_inertial.html#dsk_intersect_inertial", "dsk_intersect_inertial", 'routine in <a href="obj/dsk/dsk_intersect_inertial.html">dsk_intersect_inertial.pro</a>', "dsk_intersect_inertial.pro", "", "dsk_intersect_inertial", "<code class= source >	Computes ray intersections with a DISK object, in inertial coordinates.</code>  ", "thitnoeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  v<code class= source > Array (nv x 3 x nt) of column vectors giving the origins</code> <code class= source >		 of the rays in the inertial frame.</code>  r<code class= source > Array (nv x 3 x nt) of column vectors giving the directions</code> <code class= source >		 of the rays in the inertial frame.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x 3 x nt) of column vectors giving the ray/disk</code> <code class= source >	intersections in the inertial frame.  Note this if inertial</code> <code class= source >	results are needed, this routine is slightly faster than</code> <code class= source >	dsk_intersect.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_l.html", "dsk_l.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_l.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_l.html#dsk_l", "dsk_l", 'routine in <a href="obj/dsk/dsk_l.html">dsk_l.pro</a>', "dsk_l.pro", "", "dsk_l", "<code class= source >	Returns l for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	l value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libal.html", "dsk_libal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libal.html#dsk_libal", "dsk_libal", 'routine in <a href="obj/dsk/dsk_libal.html">dsk_libal.pro</a>', "dsk_libal.pro", "", "dsk_libal", "<code class= source >	Returns libal for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	libal value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libam.html", "dsk_libam.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libam.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libam.html#dsk_libam", "dsk_libam", 'routine in <a href="obj/dsk/dsk_libam.html">dsk_libam.pro</a>', "dsk_libam.pro", "", "dsk_libam", "<code class= source >	Returns libam for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	libam value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libl.html", "dsk_libl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libl.html#dsk_libl", "dsk_libl", 'routine in <a href="obj/dsk/dsk_libl.html">dsk_libl.pro</a>', "dsk_libl.pro", "", "dsk_libl", "<code class= source >	Returns libl for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	libl value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_libm.html", "dsk_libm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_libm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_libm.html#dsk_libm", "dsk_libm", 'routine in <a href="obj/dsk/dsk_libm.html">dsk_libm.pro</a>', "dsk_libm.pro", "", "dsk_libm", "<code class= source >	Returns libm for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	libm value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_m.html", "dsk_m.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_m.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_m.html#dsk_m", "dsk_m", 'routine in <a href="obj/dsk/dsk_m.html">dsk_m.pro</a>', "dsk_m.pro", "", "dsk_m", "<code class= source >	Returns m for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	m value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_nl.html", "dsk_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_nl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_nl.html#dsk_nl", "dsk_nl", 'routine in <a href="obj/dsk/dsk_nl.html">dsk_nl.pro</a>', "dsk_nl.pro", "", "dsk_nl", "<code class= source >	Returns nl for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	nl value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_nm.html", "dsk_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_nm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_nm.html#dsk_nm", "dsk_nm", 'routine in <a href="obj/dsk/dsk_nm.html">dsk_nm.pro</a>', "dsk_nm.pro", "", "dsk_nm", "<code class= source >	Returns nm for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	nm value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_point_cloud.html", "dsk_point_cloud.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_point_cloud.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_point_cloud.html#dsk_point_cloud", "dsk_point_cloud", 'routine in <a href="obj/dsk/dsk_point_cloud.html">dsk_point_cloud.pro</a>', "dsk_point_cloud.pro", "", "dsk_point_cloud", "<code class= source >	Generates a random cloud of body-frame vectors within a DISK object.</code>  ", "dkd<code class= source >DISK descriptor.</code>  nv<code class= source >Number of points to generate.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_projected_resolution.html", "dsk_projected_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_projected_resolution.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_projected_resolution.html#dsk_projected_resolution", "dsk_projected_resolution", 'routine in <a href="obj/tools/dsk_projected_resolution.html">dsk_projected_resolution.pro</a>', "dsk_projected_resolution.pro", "", "dsk_projected_resolution", "<code class= source >	Computes the resolution (actually scale) components at a point on a</code> <code class= source >	disk in a given camera.</code>  ", "radlonperprrdkdcd<code class= source >Camera descriptor.</code>  p<code class= source >Point on the dkx in inertial coordinates.</code>  scale", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, usning an approach suggested by M. Tiscareno</code>  <code class= source >	Radial resolution on dkx at r, computed as the length of a</code> <code class= source >	segment bisecting the intersection ellipse in the radial direction.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_query.html", "dsk_query.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_query.html#dsk_query", "dsk_query", 'routine in <a href="obj/dsk/dsk_query.html">dsk_query.pro</a>', "dsk_query.pro", "", "dsk_query", "<code class= source >	Returns the fields associated with a DISK object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@dsk__keywords_tree.include", "NV/OBJ/DSK", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/dsk_radial_resolution.html", "dsk_radial_resolution.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "dsk_radial_resolution.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/dsk_radial_resolution.html#dsk_radial_resolution", "dsk_radial_resolution", 'routine in <a href="obj/tools/dsk_radial_resolution.html">dsk_radial_resolution.pro</a>', "dsk_radial_resolution.pro", "", "dsk_radial_resolution", "<code class= source >	Computes the radial resolution at a point on a disk in a</code> <code class= source >	given camera.</code>  ", "dkdcd<code class= source >Camera descriptor.</code>  r<code class= source >Point on the dkx in inertial coordinates.</code>  scale", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Radial resolution on dkx at r, computed as the length of a</code> <code class= source >	segment bisecting the intersection ellipse in the radial direction.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_radial_scale.html", "dsk_radial_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_radial_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_radial_scale.html#dsk_radial_scale", "dsk_radial_scale", 'routine in <a href="obj/dsk/dsk_radial_scale.html">dsk_radial_scale.pro</a>', "dsk_radial_scale.pro", "", "dsk_radial_scale", "<code class= source >	Returns radial_scale for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	radial_scale value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_reflect.html", "dsk_reflect.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_reflect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_reflect.html#dsk_reflect", "dsk_reflect", 'routine in <a href="obj/dsk/dsk_reflect.html">dsk_reflect.pro</a>', "dsk_reflect.pro", "", "dsk_reflect", "<code class= source >	Computes ray reflections with a DISK object.</code>  ", "hitdkd<code class= source > Array (nt) of any subclass of DISK.</code>  v<code class= source > Array (nv x 3 x nt) of column vectors giving the observer</code> <code class= source >		 position in the body frame.</code>  r<code class= source > Array (nv x 3 x nt) of column vectors giving the source</code> <code class= source >		 position in the body frame.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x 3 x nt) of column vectors giving the ray/disk</code> <code class= source >	reflections in the body frame.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_replicate.html", "dsk_replicate.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_replicate.html#dsk_replicate", "dsk_replicate", 'routine in <a href="obj/dsk/dsk_replicate.html">dsk_replicate.pro</a>', "dsk_replicate.pro", "", "dsk_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "dkd<code class= source > Any superclass of DISK.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ap.html", "dsk_set_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ap.html#dsk_set_ap", "dsk_set_ap", 'routine in <a href="obj/dsk/dsk_set_ap.html">dsk_set_ap.pro</a>', "dsk_set_ap.pro", "", "dsk_set_ap", "<code class= source >	Replaces ap in each given disk descriptor.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  ap<code class= source > New ap value.</code>  frame_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dap.html", "dsk_set_dap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dap.html#dsk_set_dap", "dsk_set_dap", 'routine in <a href="obj/dsk/dsk_set_dap.html">dsk_set_dap.pro</a>', "dsk_set_dap.pro", "", "dsk_set_dap", "<code class= source >	Replaces the apsidal shift in each given disk descriptor.  Half of the</code> <code class= source >	shift is applied to each edge, so as to not affect the mean periapse</code> <code class= source >	direction.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  dap<code class= source > New dap value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dapdt.html", "dsk_set_dapdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dapdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dapdt.html#dsk_set_dapdt", "dsk_set_dapdt", 'routine in <a href="obj/dsk/dsk_set_dapdt.html">dsk_set_dapdt.pro</a>', "dsk_set_dapdt.pro", "", "dsk_set_dapdt", "<code class= source >	Replaces dapdt in each given disk descriptor.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  dapdt<code class= source > New dapdt value.</code>  frame_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlandt.html", "dsk_set_dlandt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlandt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlandt.html#dsk_set_dlandt", "dsk_set_dlandt", 'routine in <a href="obj/dsk/dsk_set_dlandt.html">dsk_set_dlandt.pro</a>', "dsk_set_dlandt.pro", "", "dsk_set_dlandt", "<code class= source >	Replaces dlandt in each given disk descriptor.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  dlandt<code class= source > New dlandt value.</code>  frame_bd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_ap.html", "dsk_set_dlibdt_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibdt_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_ap.html#dsk_set_dlibdt_ap", "dsk_set_dlibdt_ap", 'routine in <a href="obj/dsk/dsk_set_dlibdt_ap.html">dsk_set_dlibdt_ap.pro</a>', "dsk_set_dlibdt_ap.pro", "", "dsk_set_dlibdt_ap", "<code class= source >	Sets dlibdt_ap in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  dlibdt_ap<code class= source > New dlibdt_ap value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_lan.html", "dsk_set_dlibdt_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibdt_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibdt_lan.html#dsk_set_dlibdt_lan", "dsk_set_dlibdt_lan", 'routine in <a href="obj/dsk/dsk_set_dlibdt_lan.html">dsk_set_dlibdt_lan.pro</a>', "dsk_set_dlibdt_lan.pro", "", "dsk_set_dlibdt_lan", "<code class= source >	Sets dlibdt_lan in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  dlibdt_lan<code class= source > New dlibdt_lan value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibldt.html", "dsk_set_dlibldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibldt.html#dsk_set_dlibldt", "dsk_set_dlibldt", 'routine in <a href="obj/dsk/dsk_set_dlibldt.html">dsk_set_dlibldt.pro</a>', "dsk_set_dlibldt.pro", "", "dsk_set_dlibldt", "<code class= source >	Replaces dlibldt in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  dlibldt<code class= source > New dlibldt value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibmdt.html", "dsk_set_dlibmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dlibmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dlibmdt.html#dsk_set_dlibmdt", "dsk_set_dlibmdt", 'routine in <a href="obj/dsk/dsk_set_dlibmdt.html">dsk_set_dlibmdt.pro</a>', "dsk_set_dlibmdt.pro", "", "dsk_set_dlibmdt", "<code class= source >	Replaces dlibmdt in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  dlibmdt<code class= source > New dlibmdt value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtaanldt.html", "dsk_set_dtaanldt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dtaanldt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtaanldt.html#dsk_set_dtaanldt", "dsk_set_dtaanldt", 'routine in <a href="obj/dsk/dsk_set_dtaanldt.html">dsk_set_dtaanldt.pro</a>', "dsk_set_dtaanldt.pro", "", "dsk_set_dtaanldt", "<code class= source >	Replaces dtaanldt in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  dtaanldt<code class= source > New dtaanldt value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtapmdt.html", "dsk_set_dtapmdt.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_dtapmdt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_dtapmdt.html#dsk_set_dtapmdt", "dsk_set_dtapmdt", 'routine in <a href="obj/dsk/dsk_set_dtapmdt.html">dsk_set_dtapmdt.pro</a>', "dsk_set_dtapmdt.pro", "", "dsk_set_dtapmdt", "<code class= source >	Replaces dtapmdt in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  dtapmdt<code class= source > New dtapmdt value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ecc.html", "dsk_set_ecc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_ecc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_ecc.html#dsk_set_ecc", "dsk_set_ecc", 'routine in <a href="obj/dsk/dsk_set_ecc.html">dsk_set_ecc.pro</a>', "dsk_set_ecc.pro", "", "dsk_set_ecc", "<code class= source >	Replaces ecc in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  ecc<code class= source > New ecc value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_em.html", "dsk_set_em.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_em.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_em.html#dsk_set_em", "dsk_set_em", 'routine in <a href="obj/dsk/dsk_set_em.html">dsk_set_em.pro</a>', "dsk_set_em.pro", "", "dsk_set_em", "<code class= source >	Replaces em in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  em<code class= source > New em value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_il.html", "dsk_set_il.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_il.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_il.html#dsk_set_il", "dsk_set_il", 'routine in <a href="obj/dsk/dsk_set_il.html">dsk_set_il.pro</a>', "dsk_set_il.pro", "", "dsk_set_il", "<code class= source >	Replaces il in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  il<code class= source > New il value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_inc.html", "dsk_set_inc.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_inc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_inc.html#dsk_set_inc", "dsk_set_inc", 'routine in <a href="obj/dsk/dsk_set_inc.html">dsk_set_inc.pro</a>', "dsk_set_inc.pro", "", "dsk_set_inc", "<code class= source >	Sets inc in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  inc<code class= source > New inc value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_l.html", "dsk_set_l.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_l.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_l.html#dsk_set_l", "dsk_set_l", 'routine in <a href="obj/dsk/dsk_set_l.html">dsk_set_l.pro</a>', "dsk_set_l.pro", "", "dsk_set_l", "<code class= source >	Replaces l in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  l<code class= source > New l value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lan.html", "dsk_set_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lan.html#dsk_set_lan", "dsk_set_lan", 'routine in <a href="obj/dsk/dsk_set_lan.html">dsk_set_lan.pro</a>', "dsk_set_lan.pro", "", "dsk_set_lan", "<code class= source >	Sets lan in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  lan<code class= source > New lan value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_ap.html", "dsk_set_lib_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lib_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_ap.html#dsk_set_lib_ap", "dsk_set_lib_ap", 'routine in <a href="obj/dsk/dsk_set_lib_ap.html">dsk_set_lib_ap.pro</a>', "dsk_set_lib_ap.pro", "", "dsk_set_lib_ap", "<code class= source >	Sets lib_ap in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  lib_ap<code class= source > New lib_ap value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_lan.html", "dsk_set_lib_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_lib_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_lib_lan.html#dsk_set_lib_lan", "dsk_set_lib_lan", 'routine in <a href="obj/dsk/dsk_set_lib_lan.html">dsk_set_lib_lan.pro</a>', "dsk_set_lib_lan.pro", "", "dsk_set_lib_lan", "<code class= source >	Sets lib_lan in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  lib_lan<code class= source > New lib_lan value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_ap.html", "dsk_set_liba_ap.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_liba_ap.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_ap.html#dsk_set_liba_ap", "dsk_set_liba_ap", 'routine in <a href="obj/dsk/dsk_set_liba_ap.html">dsk_set_liba_ap.pro</a>', "dsk_set_liba_ap.pro", "", "dsk_set_liba_ap", "<code class= source >	Sets liba_ap in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  liba_ap<code class= source > New liba_ap value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_lan.html", "dsk_set_liba_lan.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_liba_lan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_liba_lan.html#dsk_set_liba_lan", "dsk_set_liba_lan", 'routine in <a href="obj/dsk/dsk_set_liba_lan.html">dsk_set_liba_lan.pro</a>', "dsk_set_liba_lan.pro", "", "dsk_set_liba_lan", "<code class= source >	Sets liba_lan in each given disk descriptor.  This value is determined</code> <code class= source >	by the orientation of the BODY axes.</code>  ", "dkd<code class= source > Array (nt) of any subclass of DISK.</code>  liba_lan<code class= source > New liba_lan value.</code>  frame_bd<code class= source >Subclass of BODY giving the frame against which to</code> <code class= source >			measure inclinations and nodes, e.g., a planet</code> <code class= source >			descriptor.  One for each dkd.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libal.html", "dsk_set_libal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libal.html#dsk_set_libal", "dsk_set_libal", 'routine in <a href="obj/dsk/dsk_set_libal.html">dsk_set_libal.pro</a>', "dsk_set_libal.pro", "", "dsk_set_libal", "<code class= source >	Replaces libal in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  libal<code class= source > New libal value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libam.html", "dsk_set_libam.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libam.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libam.html#dsk_set_libam", "dsk_set_libam", 'routine in <a href="obj/dsk/dsk_set_libam.html">dsk_set_libam.pro</a>', "dsk_set_libam.pro", "", "dsk_set_libam", "<code class= source >	Replaces libam in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  libam<code class= source > New libam value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libl.html", "dsk_set_libl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libl.html#dsk_set_libl", "dsk_set_libl", 'routine in <a href="obj/dsk/dsk_set_libl.html">dsk_set_libl.pro</a>', "dsk_set_libl.pro", "", "dsk_set_libl", "<code class= source >	Replaces libl in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  libl<code class= source > New libl value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libm.html", "dsk_set_libm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_libm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_libm.html#dsk_set_libm", "dsk_set_libm", 'routine in <a href="obj/dsk/dsk_set_libm.html">dsk_set_libm.pro</a>', "dsk_set_libm.pro", "", "dsk_set_libm", "<code class= source >	Replaces libm in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  libm<code class= source > New libm value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_m.html", "dsk_set_m.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_m.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_m.html#dsk_set_m", "dsk_set_m", 'routine in <a href="obj/dsk/dsk_set_m.html">dsk_set_m.pro</a>', "dsk_set_m.pro", "", "dsk_set_m", "<code class= source >	Replaces m in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  m<code class= source > New m value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nl.html", "dsk_set_nl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_nl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nl.html#dsk_set_nl", "dsk_set_nl", 'routine in <a href="obj/dsk/dsk_set_nl.html">dsk_set_nl.pro</a>', "dsk_set_nl.pro", "", "dsk_set_nl", "<code class= source >	Replaces nl in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  nl<code class= source > New nl value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nm.html", "dsk_set_nm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_nm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_nm.html#dsk_set_nm", "dsk_set_nm", 'routine in <a href="obj/dsk/dsk_set_nm.html">dsk_set_nm.pro</a>', "dsk_set_nm.pro", "", "dsk_set_nm", "<code class= source >	Replaces nm in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  nm<code class= source > New nm value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_phase_fn.html", "dsk_set_phase_fn.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_phase_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_phase_fn.html#dsk_set_phase_fn", "dsk_set_phase_fn", 'routine in <a href="obj/dsk/dsk_set_phase_fn.html">dsk_set_phase_fn.pro</a>', "dsk_set_phase_fn.pro", "", "dsk_set_phase_fn", "<code class= source >       Replaces the phase function for each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK descriptors.</code>  phase_fn<code class= source >Array (nt) of new phase functions.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_radial_scale.html", "dsk_set_radial_scale.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_radial_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_radial_scale.html#dsk_set_radial_scale", "dsk_set_radial_scale", 'routine in <a href="obj/dsk/dsk_set_radial_scale.html">dsk_set_radial_scale.pro</a>', "dsk_set_radial_scale.pro", "", "dsk_set_radial_scale", "<code class= source >	Replaces the radial scale in each given disk descriptor.</code>  ", "noeventdkd<code class= source > 	Array (nt) of any subclass of DISK.</code>  radial_scale<code class= source > New radial_scale value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_refl_fn.html", "dsk_set_refl_fn.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_refl_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_refl_fn.html#dsk_set_refl_fn", "dsk_set_refl_fn", 'routine in <a href="obj/dsk/dsk_set_refl_fn.html">dsk_set_refl_fn.pro</a>', "dsk_set_refl_fn.pro", "", "dsk_set_refl_fn", "<code class= source >       Replaces the reflection function for each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK descriptors.</code>  refl_fn<code class= source >Array (nt) of new reflection functions.</code>  ", "NV/LIB/dsk", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_sma.html", "dsk_set_sma.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_sma.html#dsk_set_sma", "dsk_set_sma", 'routine in <a href="obj/dsk/dsk_set_sma.html">dsk_set_sma.pro</a>', "dsk_set_sma.pro", "", "dsk_set_sma", "<code class= source >	Replaces the sma in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  sma<code class= source > New sma value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_taanl.html", "dsk_set_taanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_taanl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_taanl.html#dsk_set_taanl", "dsk_set_taanl", 'routine in <a href="obj/dsk/dsk_set_taanl.html">dsk_set_taanl.pro</a>', "dsk_set_taanl.pro", "", "dsk_set_taanl", "<code class= source >	Replaces taanl in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  taanl<code class= source > New taanl value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tapm.html", "dsk_set_tapm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_set_tapm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_set_tapm.html#dsk_set_tapm", "dsk_set_tapm", 'routine in <a href="obj/dsk/dsk_set_tapm.html">dsk_set_tapm.pro</a>', "dsk_set_tapm.pro", "", "dsk_set_tapm", "<code class= source >	Replaces tapm in each given disk descriptor.</code>  ", "noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  tapm<code class= source > New tapm value.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_radial.html", "dsk_shape_radial.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_shape_radial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_radial.html#dsk_shape_radial", "dsk_shape_radial", 'routine in <a href="obj/dsk/dsk_shape_radial.html">dsk_shape_radial.pro</a>', "dsk_shape_radial.pro", "", "dsk_shape_radial", "<code class= source >	Computes radii along the edge of a disk using disk elements.</code>  ", "mm<code class= source >If set, only the radius component for this wavenumber</code> <code class= source >		is returned.</code>  mii<code class= source >If set, only the radius component with this index</code> <code class= source >		is returned.</code>  _a<code class= source > Array (nt) of semimajor axis values.</code>  _e<code class= source > Array (nt) of eccentricity values.</code>  _dap<code class= source > Array (nt) of apsidal shift values.</code>  ta<code class= source > Array (nv x nt) of true anomalies at which to compute radii.</code>  _m<code class= source > Array (nt x nm) of radial wavenumbers.</code>  _em<code class= source > Array (nt x nm) of eccentricities for each m.</code>  _tapm<code class= source > Array (nt x nm) of true anomalies of periapse for each m.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv x nt) of radii computed at each true anomaly on each</code> <code class= source >	disk.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_vertical.html", "dsk_shape_vertical.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_shape_vertical.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_shape_vertical.html#dsk_shape_vertical", "dsk_shape_vertical", 'routine in <a href="obj/dsk/dsk_shape_vertical.html">dsk_shape_vertical.pro</a>', "dsk_shape_vertical.pro", "", "dsk_shape_vertical", "<code class= source >	Computes elevations along the edge of a disk using disk elements.</code>  ", "dkdll<code class= source >If set, only the elevation component for this wavenumber</code> <code class= source >		is returned.</code>  lii<code class= source >If set, only the elevation component with this index</code> <code class= source >		is returned.</code>  a<code class= source > Array (nt) of semimajor axis values.</code>  ta<code class= source > Array (nta) of true anomalies at which to compute elevations.</code>  l<code class= source > Array (nt) of vertical wavenumbers.</code>  il<code class= source > Array (nt) of inclinations for each l.</code>  taanl<code class= source > Array (nt) of true anomalies of ascending node for each l.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt x nta) of elevations computed at each true anomaly on each</code> <code class= source >	disk.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_sma.html", "dsk_sma.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_sma.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_sma.html#dsk_sma", "dsk_sma", 'routine in <a href="obj/dsk/dsk_sma.html">dsk_sma.pro</a>', "dsk_sma.pro", "", "dsk_sma", "<code class= source >	Returns sma for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	sma value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_surface_normal.html", "dsk_surface_normal.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_surface_normal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_surface_normal.html#dsk_surface_normal", "dsk_surface_normal", 'routine in <a href="obj/dsk/dsk_surface_normal.html">dsk_surface_normal.pro</a>', "dsk_surface_normal.pro", "", "dsk_surface_normal", "<code class= source >	Computes the surface normal for a DISK object at the given</code> <code class= source >	body-frame positions.</code>  ", "noeventnorth<code class= source >    If set, the retruned normals will be pointed north.</code> <code class= source >	           Otherwise, they point toward the observer's hemisphere.</code>  dkd<code class= source >Array (nt) of any subclass of DISK descriptors.</code>  v<code class= source >Array (nv,3) of observer positions in the BODY frame.</code>  r<code class= source >Array (nv,3) of surface positions in the BODY frame.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv, 3, nt) of surface unit normals in the BODY frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_taanl.html", "dsk_taanl.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_taanl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_taanl.html#dsk_taanl", "dsk_taanl", 'routine in <a href="obj/dsk/dsk_taanl.html">dsk_taanl.pro</a>', "dsk_taanl.pro", "", "dsk_taanl", "<code class= source >	Returns taanl for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	taanl value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_tapm.html", "dsk_tapm.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_tapm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_tapm.html#dsk_tapm", "dsk_tapm", 'routine in <a href="obj/dsk/dsk_tapm.html">dsk_tapm.pro</a>', "dsk_tapm.pro", "", "dsk_tapm", "<code class= source >	Returns tapm for each given disk descriptor.</code>  ", "noeventdkd", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	tapm value associated with each given disk descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dsk/dsk_valid_edges.html", "dsk_valid_edges.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "dsk_valid_edges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/dsk_valid_edges.html#dsk_valid_edges", "dsk_valid_edges", 'routine in <a href="obj/dsk/dsk_valid_edges.html">dsk_valid_edges.pro</a>', "dsk_valid_edges.pro", "", "dsk_valid_edges", "<code class= source >	Determines which edges (i.e., inner/outer) in the input DISK objects</code> <code class= source >	are valid.</code>  ", "inner<code class= source >If set, only the inner edges are tested.</code>  outer<code class= source >If set, only the outer edges are tested.</code>  all<code class= source >If set, the inner and outer edges are tested, and must</code> <code class= source >		both be valid to be selected.</code>  noeventdkd<code class= source > Array (nt) of any subclass of DISK.</code>  ", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of subscripts of the descriptors whose edges meet the criteria</code> <code class= source >	defined by the input keyowrds.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_atan.html", "edge_model_atan.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_atan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_atan.html#edge_model_atan", "edge_model_atan", 'routine in <a href="obj/tools/icv/edge_model_atan.html">edge_model_atan.pro</a>', "edge_model_atan.pro", "", "edge_model_atan", "<code class= source >	Calculates an arctan edge model for use in curve fitting.</code>  ", "zerodeltacdn<code class= source >Size of the model in samples</code>  a<code class= source >Scaling factor: larger values give a sharper edge.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source >       Written by:     Spitale, 6/1998</code>  <code class= source >	An array containing the model.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_gauss.html", "edge_model_gauss.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_gauss.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_gauss.html#edge_model_gauss", "edge_model_gauss", 'routine in <a href="obj/tools/icv/edge_model_gauss.html">edge_model_gauss.pro</a>', "edge_model_gauss.pro", "", "edge_model_gauss", "<code class= source >	Calculates a gaussian edge model for use in curve fitting.</code>  ", "zerodeltacdn<code class= source >Size of the model in samples</code>  w<code class= source >Width of the gaussian (sigma)</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source >       Written by:     Haemmerle, 6/1998</code>  <code class= source >	An array containing the model.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_limb.html", "edge_model_nav_limb.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_nav_limb.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_limb.html#edge_model_nav_limb", "edge_model_nav_limb", 'routine in <a href="obj/tools/icv/edge_model_nav_limb.html">edge_model_nav_limb.pro</a>', "edge_model_nav_limb.pro", "", "edge_model_nav_limb", "<code class= source >	Returns the edge model used by the VICAR program NAV for limb fits.</code>  ", "zerodeltacd", "NV/LIB/TOOLS/ICV", "<code class= source >       Written by:     Spitale, 6/1998</code>  <code class= source >	An array containing the model.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_ring.html", "edge_model_nav_ring.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_nav_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_nav_ring.html#edge_model_nav_ring", "edge_model_nav_ring", 'routine in <a href="obj/tools/icv/edge_model_nav_ring.html">edge_model_nav_ring.pro</a>', "edge_model_nav_ring.pro", "", "edge_model_nav_ring", "<code class= source >	Returns the edge model used by the VICAR program NAV for ring fits.</code>  ", "zerodeltacd", "NV/LIB/TOOLS/ICV", "<code class= source >       Written by:     Spitale, 6/1998</code>  <code class= source >	An array containing the model.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_psf_ring.html", "edge_model_psf_ring.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "edge_model_psf_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/edge_model_psf_ring.html#edge_model_psf_ring", "edge_model_psf_ring", 'routine in <a href="obj/tools/icv/edge_model_psf_ring.html">edge_model_psf_ring.pro</a>', "edge_model_psf_ring.pro", "", "edge_model_psf_ring", "<code class= source >	Returns an edge model produced by convolving a sharp edge with</code> <code class= source >	a point-spread function.</code>  ", "cdzerodelta", "NV/LIB/TOOLS/ICV", "<code class= source >       Written by:     Spitale, 6/1998</code>  <code class= source >	An array containing the model.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/footprint.html", "footprint.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "footprint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/footprint.html#footprint", "footprint", 'routine in <a href="obj/tools/footprint.html">footprint.pro</a>', "footprint.pro", "", "footprint", "<code class= source >	Computes the footprint of a camera on a given body.</code>  ", "slop<code class= source >	Number of pixels by which to expand the image in each</code> <code class= source >			direction.</code>  corners<code class= source >Array(2,2) giving corers of image region to consider.</code>  hit_indices<code class= source >Array (nhit) of bx indices.</code>  image_pts<code class= source >Footprint points in the image frame.</code>  body_p<code class= source >	Array (nhit) of pointers to body footprint points for</code> <code class= source >			each body hit.</code>  sample<code class= source >	Sampling rate; default is 1 pixel.</code>  cd<code class= source >	Camera descripor.  Only one allowed.</code>  bx<code class= source >	Body descriptors.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale		5/2014</code>  <code class= source >	Array (nhit) of pointers to inertial footprint points for each body hit.</code> <code class= source >	Zero is returned if no bodies are hit.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_disk_ref.html", "get_disk_ref.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_disk_ref.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_disk_ref.html#get_disk_ref", "get_disk_ref", 'routine in <a href="obj/tools/get_disk_ref.html">get_disk_ref.pro</a>', "get_disk_ref.pro", "", "get_disk_ref", "<code class= source >	Produces inertial unit vectors corresponding to the projection</code> <code class= source >	of the given body 2-axis direction into the given disk plane.</code>  ", "dkx<code class= source >Array (nt) of any subclass of DISK.</code>  bx<code class= source >Array (nt) of any subclass of BODY.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (1,3,nt) of inertial unit vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_border_pts.html", "get_image_border_pts.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_border_pts.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_border_pts.html#get_image_border_pts", "get_image_border_pts", 'routine in <a href="obj/tools/get_image_border_pts.html">get_image_border_pts.pro</a>', "get_image_border_pts.pro", "", "get_image_border_pts", "<code class= source >	Computes points around the edge of an image.</code>  ", "cornerscentercropsampleaperturecd<code class= source >Camera descripor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (2,np) of image points on the image border.  np is computed</code> <code class= source >	such that points are spaced by one pixel.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_profile.html", "get_image_profile.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_profile.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_profile.html#get_image_profile", "get_image_profile", 'routine in <a href="obj/tools/get_image_profile.html">get_image_profile.pro</a>', "get_image_profile.pro", "", "get_image_profile", "<code class= source >	Extracts a profile from a rectangular, but not necessarily axis-aligned,</code> <code class= source >	image region using interpolation.</code>  ", "distance<code class= source >Array (nl) giving the distance along the scan.</code>  interp<code class= source >	Type of interpolation, see image_interp_cam.</code>  arg_interp<code class= source >Interpolation argument, see image_interp_cam.</code>  sigma<code class= source >	Standard deviation across the profile at each sample</code> <code class= source >			along the profile.</code>  image_pts<code class= source >Array (2,nl) of image points along the center of</code> <code class= source >			the scan.</code>  imcd<code class= source >Camera descriptor.</code>  p<code class= source >Array (2,2) of image points giving the start and end points</code> <code class= source >		for the scan.</code>  nl<code class= source >Number of samples along the scan.</code>  nw<code class= source >Number of samples across the scan.</code>  sample", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (nl) containing the profile.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_profile_outline.html", "get_image_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_profile_outline.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_profile_outline.html#get_image_profile_outline", "get_image_profile_outline", 'routine in <a href="obj/tools/get_image_profile_outline.html">get_image_profile_outline.pro</a>', "get_image_profile_outline.pro", "", "get_image_profile_outline", "<code class= source >	Generates an outline of an oblique rectangular image region.</code>  ", "nw<code class= source >Number of samples across the scan.</code>  nl<code class= source >Number of samples along the scan.</code>  samplepoints<code class= source >Array (2,2) of image points defining corners at opposite ends</code> <code class= source >		on one side of the sector.</code>  point<code class= source >Image point defining and third corner.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array of image points defining the outline of the sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_image_vector.html", "get_image_vector.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_image_vector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_image_vector.html#get_image_vector", "get_image_vector", 'routine in <a href="obj/tools/get_image_vector.html">get_image_vector.pro</a>', "get_image_vector.pro", "", "get_image_vector", "<code class= source >	Projects inertial vectors into an image.</code>  ", "cd<code class= source >Array (nt) of camera descriptors.</code>  v<code class= source >Array (nv,3,nt) of vectors in the inertial frame.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (2,nv,nt) of image vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline.html", "get_limb_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline.html#get_limb_profile_outline", "get_limb_profile_outline", 'routine in <a href="obj/tools/get_limb_profile_outline.html">get_limb_profile_outline.pro</a>', "get_limb_profile_outline.pro", "", "get_limb_profile_outline", "<code class= source >       Generates an outline of a limb sector.</code>  ", "altaznaltnazinertial<code class= source >Inertial vectors corresponding to the limb sector</code> <code class= source >			outline points.</code>  dkd<code class= source >Disk descriptor corresponding to the skyplane.</code>  save_azsscan_altscan_azlimb_pts_bodygraphiccd<code class= source >Camera descriptor.</code>  gbx<code class= source >Globe descriptor.</code>  points<code class= source >Array (2,2) of image points defining opposite corners</code> <code class= source >		of the sector.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, 8/2006</code>  <code class= source >       Array of image points defining the outline of the sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_linear.html", "get_limb_profile_outline_linear.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_linear.html#get_limb_profile_outline_linear", "get_limb_profile_outline_linear", 'routine in <a href="obj/tools/get_limb_profile_outline_linear.html">get_limb_profile_outline_linear.pro</a>', "get_limb_profile_outline_linear.pro", "", "get_limb_profile_outline_linear", "<code class= source >       Generates an outline of a rectangular limb sector.</code>  ", "altaz0rimpointsnaltnriminertial<code class= source >Inertial vectors corresponding to the limb sector</code> <code class= source >			outline points.</code>  save_rimsscan_altscan_rimlimb_pts_bodygraphiccd<code class= source >Camera descriptor.</code>  gbx<code class= source >Globe descriptor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, 1/2009</code>  <code class= source >       Array of image points defining the outline of the sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_oblique.html", "get_limb_profile_outline_oblique.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_limb_profile_outline_oblique.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_limb_profile_outline_oblique.html#get_limb_profile_outline_oblique", "get_limb_profile_outline_oblique", 'routine in <a href="obj/tools/get_limb_profile_outline_oblique.html">get_limb_profile_outline_oblique.pro</a>', "get_limb_profile_outline_oblique.pro", "", "get_limb_profile_outline_oblique", "<code class= source >       Generates an outline of an oblique limb sector.</code>  ", "naltnazdkdcd<code class= source >Camera descriptor.</code>  gbx<code class= source >Globe descriptor.</code>  points<code class= source >Array (2,2) of image points defining opposite corners</code> <code class= source >		of the sector.</code>  point ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, 1/2009</code>  <code class= source >       Array of image points defining the outline of the sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_object_by_name.html", "get_object_by_name.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_object_by_name.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_object_by_name.html#get_object_by_name", "get_object_by_name", 'routine in <a href="obj/tools/get_object_by_name.html">get_object_by_name.pro</a>', "get_object_by_name.pro", "", "get_object_by_name", "<code class= source >	Selects from a list of descriptors based on their name.</code>  ", "xds<code class= source >Array of any subclass of CORE.</code>  name", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array descriptors whose CORE name field matches the given name.</code> <code class= source >	If no matches are found, 0 is returned.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_primary.html", "get_primary.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_primary.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_primary.html#get_primary", "get_primary", 'routine in <a href="obj/tools/get_primary.html">get_primary.pro</a>', "get_primary.pro", "", "get_primary", "<code class= source >	Attempts to determine the primary planet from a list of descriptors</code> <code class= source >	based on their names and proximity to the observer, or extracts</code> <code class= source >	the observer descriptor from an object's generic descriptor.</code>  ", "planetsarg1arg2", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       NONE</code> <code class= source > KEYOWRDS:</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile.html", "get_ring_profile.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile.html#get_ring_profile", "get_ring_profile", 'routine in <a href="obj/tools/get_ring_profile.html">get_ring_profile.pro</a>', "get_ring_profile.pro", "", "get_ring_profile", "<code class= source >       Generates a ring profile in radius or longitude.</code>  <code class= source >       The profile is calculated by applying a grid of (radius, longitude)</code> <code class= source >       given by rad and lon on a ring sector, interpolating the dn in</code> <code class= source >       the image, and averaging along a direction to give a radius profile,</code> <code class= source >       or a longitudinal profile.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ", "azimuthal<code class= source >     If set, a longitudinal scan is done instead.</code>  interpim_ptsdxdsk_ptssigmawidthnnarg_interpimage<code class= source >     The image to scan</code>  cd<code class= source >     Camera descriptor</code>  dkd<code class= source >     Disk descriptor</code>  lon_ptsrad_pts", "NV/LIB/TOOLS", "<code class= source >       Written by:     Haemmerle, 6/1998</code>  <code class= source >       An array of averaged dn values that match the given rad or</code> <code class= source >       match the given lon if /azimuthal selected.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_bin.html", "get_ring_profile_bin.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_bin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_bin.html#get_ring_profile_bin", "get_ring_profile_bin", 'routine in <a href="obj/tools/get_ring_profile_bin.html">get_ring_profile_bin.pro</a>', "get_ring_profile_bin.pro", "", "get_ring_profile_bin", "<code class= source >       Generates a ring profile in radius or longitude using binning.</code>  <code class= source >       A ring sector polygon is calculated from the given dlon and rad</code> <code class= source >       arrays.  All the pixels of the image within this polygon are</code> <code class= source >       binned in an equally-spaced histogram in radius or longitude.</code>  <code class= source >       The dlon and rad arrays are treated as equally spaced, that is,</code> <code class= source >       the binsize is calculated by dividing the spacing in radius by</code> <code class= source >       number of points minus one.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ", "slopeazimuthal<code class= source >     If set, a longitudinal scan is done instead.</code>  image<code class= source >     The image to scan</code>  cd<code class= source >     Camera descriptor</code>  dkd<code class= source >     Disk descriptor</code>  lon_ptsrad_pts", "NV/LIB/TOOLS", "<code class= source >       Written by:     Haemmerle, 6/1998</code>  <code class= source >       An array of averaged dn values that match the given rad or</code> <code class= source >       match the given dlon if /azimuthal selected.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_n.html", "get_ring_profile_n.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_n.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_n.html#get_ring_profile_n", "get_ring_profile_n", 'routine in <a href="obj/tools/get_ring_profile_n.html">get_ring_profile_n.pro</a>', "get_ring_profile_n.pro", "", "get_ring_profile_n", "<code class= source >       Calculate the number of points in radius and longitude for</code> <code class= source >       a ring profile.</code>  <code class= source >       Routine goes along the radial and longitudinal edges of a ring</code> <code class= source >       profile sector and calculates the minimum spacing between the</code> <code class= source >       points in image space, then derives the n_rad and n_lon points</code> <code class= source >       to make the minimum spacing 1 pixel.  If the oversamp parameter</code> <code class= source >       is given, the numbers are multiplied by this factor.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ", "oversamp<code class= source >   Oversample factor compared to regular calculation of</code> <code class= source >                       radius and longitude spacing which would put maximum</code> <code class= source >                       spacing at 1 pixel.</code>  outline_pts<code class= source >   Outline sector image points which are the result</code> <code class= source >                       of calling get_ring_profile_outline()</code>  cd<code class= source >   Camera descriptor</code>  dkd<code class= source >   Disk descriptor</code>  lon<code class= source >   Equally spaced longitude array</code>  rad<code class= source >   Equally spaced radius array</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Haemmerle, 6/1998</code>  <code class= source >       Array containg n_rad and n_lon to be used by get_ring_profile() or</code> <code class= source >       get_ring_profile_bin().</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline.html", "get_ring_profile_outline.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline.html#get_ring_profile_outline", "get_ring_profile_outline", 'routine in <a href="obj/tools/get_ring_profile_outline.html">get_ring_profile_outline.pro</a>', "get_ring_profile_outline.pro", "", "get_ring_profile_outline", "<code class= source >       Generates an outline of a ring sector.</code>  ", "rad<code class= source >Array of disk radii for sector</code>  lon<code class= source >Array of disk longitudes for sector</code>  xlondirnrad<code class= source >Number of points in the radial direction.</code>  nlon<code class= source >Number of points in the longitudinal direction.</code>  slopeinertial<code class= source >Inertial vectors corresponding to the ring sector</code> <code class= source >			outline points.</code>  cd<code class= source >Camera descriptor.</code>  dkdpoints<code class= source >Array (2,2) of image points defining corners of the sector.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Vance Haemmerle & Joe Spitale, 6/1998</code>  <code class= source >       Output is set of image points (x,y) defining the outline of the</code> <code class= source >       ring sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_oblique.html", "get_ring_profile_outline_oblique.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline_oblique.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_oblique.html#get_ring_profile_outline_oblique", "get_ring_profile_outline_oblique", 'routine in <a href="obj/tools/get_ring_profile_outline_oblique.html">get_ring_profile_outline_oblique.pro</a>', "get_ring_profile_outline_oblique.pro", "", "get_ring_profile_outline_oblique", "<code class= source >       Generates an outline of an oblique ring sector.</code>  ", "dirnrad<code class= source >Number of points in the radial direction.</code>  nlon<code class= source >Number of points in the longitudinal direction.</code>  cd<code class= source >Camera descriptor.</code>  dkxpoints<code class= source >Array (2,2) of image points defining corners at opposite ends</code> <code class= source >		on one side of the sector.</code>  point<code class= source >Image point defining and third corner.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, 8/2006</code>  <code class= source >       Array of image points defining the outline of the sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_perp.html", "get_ring_profile_outline_perp.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_ring_profile_outline_perp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_ring_profile_outline_perp.html#get_ring_profile_outline_perp", "get_ring_profile_outline_perp", 'routine in <a href="obj/tools/get_ring_profile_outline_perp.html">get_ring_profile_outline_perp.pro</a>', "get_ring_profile_outline_perp.pro", "", "get_ring_profile_outline_perp", "<code class= source >       Generates an outline of a ring sector perpendicular to the</code> <code class= source >	image-projected radial direction.</code>  ", "dirnrad<code class= source >Number of points in the radial direction.</code>  nlon<code class= source >Number of points in the longitudinal direction.</code>  cd<code class= source >Camera descriptor.</code>  dkxpoints<code class= source >Array (2,2) of image points defining corners of the sector.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, 8/2006</code>  <code class= source >       Array of image points defining the outline of the sector.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/get_solar_ref.html", "get_solar_ref.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "get_solar_ref.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/get_solar_ref.html#get_solar_ref", "get_solar_ref", 'routine in <a href="obj/tools/get_solar_ref.html">get_solar_ref.pro</a>', "get_solar_ref.pro", "", "get_solar_ref", "<code class= source >	Produces inertial unit vectors corresponding to the projection</code> <code class= source >	of the sun direction into the given disk plane.</code>  ", "dkx<code class= source >Array (nt) of any subclass of DISK.</code>  ltd<code class= source >Array (nt) of any subclass of STAR representing the sun.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (1,3,nt) of inertial vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/get_surface_ranges.html", "get_surface_ranges.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "get_surface_ranges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/get_surface_ranges.html#get_surface_ranges", "get_surface_ranges", 'routine in <a href="obj/tools/composite/get_surface_ranges.html">get_surface_ranges.pro</a>', "get_surface_ranges.pro", "", "get_surface_ranges", "<code class= source >	Determines full ranges of valid surface coordinate system.</code>  ", "od<code class= source >     Observer: camera or map descriptor</code>  bx<code class= source >     Object descriptor (subclass of BODY)</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	Array of 2 points representng the minimum and maximum values of the</code> <code class= source >	relevant coordinate system.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_altaz_to_local.html", "glb_altaz_to_local.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_altaz_to_local.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_altaz_to_local.html#glb_altaz_to_local", "glb_altaz_to_local", 'routine in <a href="obj/glb/glb_altaz_to_local.html">glb_altaz_to_local.pro</a>', "glb_altaz_to_local.pro", "", "glb_altaz_to_local", "<code class= source >       Converts the given column vectors from the altaz coordinate</code> <code class= source >       system to the local coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  vr", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the local system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_assign.html", "glb_assign.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_assign.html#glb_assign", "glb_assign", 'routine in <a href="obj/glb/glb_assign.html">glb_assign.pro</a>', "glb_assign.pro", "", "glb_assign", "<code class= source >	Replaces fields in a GLOBE object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@glb__keywords_tree.include", "NV/OBJ/GLB", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_body_to_globe.html", "glb_body_to_globe.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_body_to_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_body_to_globe.html#glb_body_to_globe", "glb_body_to_globe", 'routine in <a href="obj/glb/glb_body_to_globe.html">glb_body_to_globe.pro</a>', "glb_body_to_globe.pro", "", "glb_body_to_globe", "<code class= source >       Transforms the given column vectors from the body coordinate</code> <code class= source >       system to the globe coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  v", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the globe frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_body_to_local.html", "glb_body_to_local.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_body_to_local.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_body_to_local.html#glb_body_to_local", "glb_body_to_local", 'routine in <a href="obj/glb/glb_body_to_local.html">glb_body_to_local.pro</a>', "glb_body_to_local.pro", "", "glb_body_to_local", "<code class= source >       Converts the given column vectors from the body coordinate</code> <code class= source >       system to the local coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  vr", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the local system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_create_descriptors.html", "glb_create_descriptors.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_create_descriptors.html#glb_create_descriptors", "glb_create_descriptors", 'routine in <a href="obj/glb/glb_create_descriptors.html">glb_create_descriptors.pro</a>', "glb_create_descriptors.pro", "", "glb_create_descriptors", "<code class= source >	Init method for the GLOBE class.</code>  ", "crdbdsldgbdn<code class= source >Number of descriptors to create.</code>  @glb__keywords_tree.include", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created or or freshly initialized globe descriptors, depending</code> <code class= source >	on the presence of the bd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_evolve.html", "glb_evolve.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_evolve.html#glb_evolve", "glb_evolve", 'routine in <a href="obj/glb/glb_evolve.html">glb_evolve.pro</a>', "glb_evolve.pro", "", "glb_evolve", "<code class= source >       Computes new globe descriptors at the given time offsets from</code> <code class= source >       the given globe descriptors using the taylor series expansion</code> <code class= source >       corresponding to the derivatives contained in the given globe</code> <code class= source >       descriptor.</code>  ", "nodv<code class= source > If set, velocities will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  gbd<code class= source > Array (ngd) of any subclass of GLOBE descriptors.</code>  dt<code class= source > Array (ndt) of time offsets.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (ngd,ndt) of newly allocated globe descriptors evolved</code> <code class= source >       by time dt, where ngd is the number of gbd, and ndt is the</code> <code class= source >       number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_cusp_points.html", "glb_get_cusp_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_cusp_points.pro", "", "", "<code class= source >	Iteratively computes the two points that occupy the limb from two</code> <code class= source >	different viewpoints for each given globe object.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_limb_points.html", "glb_get_limb_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_limb_points.pro", "", "", "<code class= source >	Iteratively computes the points on the limb for each given globe</code> <code class= source >	object.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_radius.html", "glb_get_radius.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_radius.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_radius.html#glb_get_radius", "glb_get_radius", 'routine in <a href="obj/glb/glb_get_radius.html">glb_get_radius.pro</a>', "glb_get_radius.pro", "", "glb_get_radius", "<code class= source >	Computes the local radius of a GLOBE object at the given lat/lon.</code>  ", "noeventgbd<code class= source >Array (nt) of any subclass of GLOBE descriptors.</code>  lat<code class= source >Array (nv) of latitudes.</code>  lon<code class= source >Array (nv) of longitudes.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv, nt) of radius values.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_ranges.html", "glb_get_ranges.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_ranges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_ranges.html#glb_get_ranges", "glb_get_ranges", 'routine in <a href="obj/glb/glb_get_ranges.html">glb_get_ranges.pro</a>', "glb_get_ranges.pro", "", "glb_get_ranges", "<code class= source >	Returns ranges of valid coordinates for the given GLOBE object.</code>  ", "gbd", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2 x 3) giving the ranges in globe coordinates.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html", "glb_get_surface_normal.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_get_surface_normal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_get_surface_normal.html#glb_get_surface_normal", "glb_get_surface_normal", 'routine in <a href="obj/glb/glb_get_surface_normal.html">glb_get_surface_normal.pro</a>', "glb_get_surface_normal.pro", "", "glb_get_surface_normal", "<code class= source >	Computes the surface normal of a GLOBE object at the given</code> <code class= source >	globe position.</code>  ", "noeventnonorm<code class= source >If set, the returned vectors are not normalized.</code>  body<code class= source >If set, the inputs given in the BODY system instead of GLOBE.</code>  gbd<code class= source >Array (nt) of any subclass of GLOBE descriptors.</code>  globe_pts", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv, 3, nt) of surface normals in the BODY frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_body.html", "glb_globe_to_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_globe_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_body.html#glb_globe_to_body", "glb_globe_to_body", 'routine in <a href="obj/glb/glb_globe_to_body.html">glb_globe_to_body.pro</a>', "glb_globe_to_body.pro", "", "glb_globe_to_body", "<code class= source >       Transforms the given column vectors from the globe coordinate</code> <code class= source >       system to the body coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  v", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_graphic.html", "glb_globe_to_graphic.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_globe_to_graphic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_globe_to_graphic.html#glb_globe_to_graphic", "glb_globe_to_graphic", 'routine in <a href="obj/glb/glb_globe_to_graphic.html">glb_globe_to_graphic.pro</a>', "glb_globe_to_graphic.pro", "", "glb_globe_to_graphic", "<code class= source >       Converts the given vectors from the globe coordinate</code> <code class= source >       system to the graphic coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  v", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the graphic system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_graphic_to_globe.html", "glb_graphic_to_globe.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_graphic_to_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_graphic_to_globe.html#glb_graphic_to_globe", "glb_graphic_to_globe", 'routine in <a href="obj/glb/glb_graphic_to_globe.html">glb_graphic_to_globe.pro</a>', "glb_graphic_to_globe.pro", "", "glb_graphic_to_globe", "<code class= source >       Converts the given vectors from the graphic coordinate</code> <code class= source >       system to the globe coordinate system.</code>  ", "noeventgbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  v", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the globe system.</code> <code class= source > STATUS:</code> <code class= source >	 Not complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_hide_points.html", "glb_hide_points.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_hide_points.pro", "", "", "<code class= source >	Identifies points that are obscured by a GLOBE with respect to a given</code> <code class= source >	viewpoint.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("obj/glb/glb_hide_points_limb.html", "glb_hide_points_limb.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_hide_points_limb.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_hide_points_limb.html#glb_hide_points_limb", "glb_hide_points_limb", 'routine in <a href="obj/glb/glb_hide_points_limb.html">glb_hide_points_limb.pro</a>', "glb_hide_points_limb.pro", "", "glb_hide_points_limb", "<code class= source >	Hides points lying on the surface of a GLOBE object that are</code> <code class= source >	obscured by the limb with respect to a given viewpoint.  This</code> <code class= source >	procedure is much faster then the more general glb_hide_points.</code>  ", "gbd<code class= source >	Array (nt) of any subclass of GLOBE descriptors.</code>  view_pts<code class= source >Columns vector giving the BODY-frame position of the viewer.</code>  hide_pts<code class= source >Array (nv) of BODY-frame vectors giving the points to hide.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Subscripts of the points in p that are hidden by the object.</code> <code class= source >	Note that this routine is only valid for points that lie on</code> <code class= source >	the surface of the globe.  This routine is faster than</code> <code class= source >	glb_hide_points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/glb_image_bounds.html", "glb_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "glb_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/glb_image_bounds.html#glb_image_bounds", "glb_image_bounds", 'routine in <a href="obj/tools/glb_image_bounds.html">glb_image_bounds.pro</a>', "glb_image_bounds.pro", "", "glb_image_bounds", "<code class= source >	Determines globe coordinate ranges visible in an image described</code> <code class= source >	by a given camera descriptor.</code>  ", "slopborder_pts_imcornerscenterlatminlatmaxlonminlonmaxstatuscd<code class= source >Camera descripor.</code>  pd", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	latmin:	Minimum latitude in image.</code> <code class= source >	latmax:	Maximum latitude in image.</code> <code class= source >	lonmin:	Minimum longitude in image.</code> <code class= source >	lonmax:	Maximum longitude in image.</code> <code class= source >	border_pts_im:	Array (2,np) of points along the edge of the image.</code> <code class= source >	status:	-1 if no globe in the image, 0 otherwise.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect.html", "glb_intersect.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect.html#glb_intersect", "glb_intersect", 'routine in <a href="obj/glb/glb_intersect.html">glb_intersect.pro</a>', "glb_intersect.pro", "", "glb_intersect", "<code class= source >	Computes the intersection of rays with GLOBE objects.</code>  ", "hit<code class= source >Array giving the indices of rays that hit the object in</code> <code class= source >		the forward direction.</code>  miss<code class= source >Array giving the indices of rays that miss the object.</code>  back_pts<code class= source >		Array (nv,3,nt) of additional intersections in order of distance</code> <code class= source >		from the observer.</code>  discriminant<code class= source >Discriminant of the quadriatic equation used to</code> <code class= source >			determine the intersections.</code>  nosolve<code class= source >If set, the intersections are not computed, though the</code> <code class= source >		 discriminant is.</code>  score<code class= source >Array in which each element indicates the number of forward hits.</code>  epsilongbd<code class= source >	Array (nt) of any subclass of GLOBE descriptors.</code>  view_pts<code class= source >Array (nv,3,nt) giving ray origins in the BODY frame.</code>  _ray_pts<code class= source >Array (nv,3,nt) giving ray directions in the BODY frame.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) of points in the BODY frame corresponding to the</code> <code class= source >	first intersections with the ray.  Zero vector is returned for points</code> <code class= source >	with no solution, including those behind the viewer.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_intersect_plane.html", "glb_intersect_plane.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_intersect_plane.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_intersect_plane.html#glb_intersect_plane", "glb_intersect_plane", 'routine in <a href="obj/glb/glb_intersect_plane.html">glb_intersect_plane.pro</a>', "glb_intersect_plane.pro", "", "glb_intersect_plane", "<code class= source >	Computesthe intersection of a plane with a GLOBE object.</code>  ", "npgbd<code class= source >Array (nt) of any subclass of GLOBE descriptors.</code>  v<code class= source >Array (1,3,nt) giving plane origins in the BODY frame.</code>  n<code class= source >Array (1,3,nt) giving the plane unit normals in the</code> <code class= source >		BODY frame.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (np,3,nt) of points in the BODY frame, np is the number of</code> <code class= source >	points on the curve of intersection.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_j.html", "glb_j.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_j.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_j.html#glb_j", "glb_j", 'routine in <a href="obj/glb/glb_j.html">glb_j.pro</a>', "glb_j.pro", "", "glb_j", "<code class= source >       Returns the zonal harmonics for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nj,nt) of zonal harmonics associated with each given globe</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_local_to_altaz.html", "glb_local_to_altaz.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_local_to_altaz.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_local_to_altaz.html#glb_local_to_altaz", "glb_local_to_altaz", 'routine in <a href="obj/glb/glb_local_to_altaz.html">glb_local_to_altaz.pro</a>', "glb_local_to_altaz.pro", "", "glb_local_to_altaz", "<code class= source >       Converts the given column vectors from the local coordinate</code> <code class= source >       system to the altaz coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  v_r", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the altaz system.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_local_to_body.html", "glb_local_to_body.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_local_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_local_to_body.html#glb_local_to_body", "glb_local_to_body", 'routine in <a href="obj/glb/glb_local_to_body.html">glb_local_to_body.pro</a>', "glb_local_to_body.pro", "", "glb_local_to_body", "<code class= source >       Converts the given column vectors from the local coordinate</code> <code class= source >       system to the body coordinate system.</code>  ", "gbd<code class= source >        Array (nt) of any subclass of GLOBE descriptors.</code>  vr", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nv,3,nt) of column vectors in the body frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_lora.html", "glb_lora.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_lora.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_lora.html#glb_lora", "glb_lora", 'routine in <a href="obj/glb/glb_lora.html">glb_lora.pro</a>', "glb_lora.pro", "", "glb_lora", "<code class= source >	Returns the longitude of the first ellipsoid radius for each</code> <code class= source >	given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Longitude of the first ellipsoid radius associated with each</code> <code class= source >       given globe descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_lref.html", "glb_lref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_lref.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_lref.html#glb_lref", "glb_lref", 'routine in <a href="obj/glb/glb_lref.html">glb_lref.pro</a>', "glb_lref.pro", "", "glb_lref", "<code class= source >       Returns the longitude system reference for each given globe</code> <code class= source >       descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Longitude system reference associated with each given globe</code> <code class= source >       descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_model.html", "glb_model.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_model.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_model.html#glb_model", "glb_model", 'routine in <a href="obj/glb/glb_model.html">glb_model.pro</a>', "glb_model.pro", "", "glb_model", "<code class= source >       Returns the model string for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of model strings associated with each given globe</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_nj.html", "glb_nj.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_nj.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_nj.html#glb_nj", "glb_nj", 'routine in <a href="obj/glb/glb_nj.html">glb_nj.pro</a>', "glb_nj.pro", "", "glb_nj", "<code class= source >	Returns an integer indicating the maximum number of zonal harmonics</code> <code class= source >	allowed in the 'j' field of the globe descriptor.  This number</code> <code class= source >	can be adjusted using the environment variable 'GLB_NJ'.  The default</code> <code class= source >	is 11.</code>  <code class= source >Environment variables: </code> <code class= source >	GLB_NJ:		Sets the nj value.</code>  ", "", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Current nj value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_point_cloud.html", "glb_point_cloud.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_point_cloud.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_point_cloud.html#glb_point_cloud", "glb_point_cloud", 'routine in <a href="obj/glb/glb_point_cloud.html">glb_point_cloud.pro</a>', "glb_point_cloud.pro", "", "glb_point_cloud", "<code class= source >	Generates a random cloud of body-frame vectors within a GLOBE object.</code>  ", "gbd<code class= source >GLOBE descriptor.</code>  nv<code class= source >Number of points to generate.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_query.html", "glb_query.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_query.html#glb_query", "glb_query", 'routine in <a href="obj/glb/glb_query.html">glb_query.pro</a>', "glb_query.pro", "", "glb_query", "<code class= source >	Returns the fields associated with a GLOBE object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@glb__keywords_tree.include", "NV/OBJ/GLB", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_radii.html", "glb_radii.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_radii.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_radii.html#glb_radii", "glb_radii", 'routine in <a href="obj/glb/glb_radii.html">glb_radii.pro</a>', "glb_radii.pro", "", "glb_radii", "<code class= source >       Returns the triaxial radii for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Triaxial radii associated with each given globe descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_reflect.html", "glb_reflect.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_reflect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_reflect.html#glb_reflect", "glb_reflect", 'routine in <a href="obj/glb/glb_reflect.html">glb_reflect.pro</a>', "glb_reflect.pro", "", "glb_reflect", "<code class= source >	Computes the reflection of rays with GLOBE objects.</code>  ", "hitmissallvalidgbd<code class= source >Array (nt) of any subclass of GLOBE descriptors.</code>  v<code class= source >Array (nv,3,nt) giving observer positions in the BODY frame.</code>  r<code class= source >Array (nv,3,nt) giving point positions in the BODY frame.</code>  epsilon<code class= source >Controls the precision of the iteration.  Default</code> <code class= source >			is 1d-3.</code>  niter<code class= source >Maximum number of iterations, default is 1000</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	Array (nv,3,nt) of points in the BODY frame.  Zero</code> <code class= source >	vector is returned for points with no solution.</code> <code class= source > STATUS:</code> <code class= source >	Not well tested</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_replicate.html", "glb_replicate.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_replicate.html#glb_replicate", "glb_replicate", 'routine in <a href="obj/glb/glb_replicate.html">glb_replicate.pro</a>', "glb_replicate.pro", "", "glb_replicate", "<code class= source >	Replicates the given globe descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "gbd<code class= source > One descriptor of any subclass of GLOBE descriptor</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	globe descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_rref.html", "glb_rref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_rref.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_rref.html#glb_rref", "glb_rref", 'routine in <a href="obj/glb/glb_rref.html">glb_rref.pro</a>', "glb_rref.pro", "", "glb_rref", "<code class= source >       Returns the reference radius for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of reference radii associated with each given globe</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_j.html", "glb_set_j.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_j.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_j.html#glb_set_j", "glb_set_j", 'routine in <a href="obj/glb/glb_set_j.html">glb_set_j.pro</a>', "glb_set_j.pro", "", "glb_set_j", "<code class= source >       Replaces the zonal harmonics for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  J<code class= source > Array (nj,nt) of new zonal harmonics.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_lora.html", "glb_set_lora.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_lora.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_lora.html#glb_set_lora", "glb_set_lora", 'routine in <a href="obj/glb/glb_set_lora.html">glb_set_lora.pro</a>', "glb_set_lora.pro", "", "glb_set_lora", "<code class= source >       Replaces the longitude of the first ellipsoid radius for each</code> <code class= source >       given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  lora<code class= source > Array (nt) of new longitude values of the first ellipsoid radius.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_lref.html", "glb_set_lref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_lref.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_lref.html#glb_set_lref", "glb_set_lref", 'routine in <a href="obj/glb/glb_set_lref.html">glb_set_lref.pro</a>', "glb_set_lref.pro", "", "glb_set_lref", "<code class= source >       Replaces the longitude system reference for each given globe</code> <code class= source >       descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  lref<code class= source > String array (nt) of new longitude system names.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_model.html", "glb_set_model.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_model.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_model.html#glb_set_model", "glb_set_model", 'routine in <a href="obj/glb/glb_set_model.html">glb_set_model.pro</a>', "glb_set_model.pro", "", "glb_set_model", "<code class= source >       Replaces the model string for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  model<code class= source > String array (nt) of new model strings.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_radii.html", "glb_set_radii.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_radii.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_radii.html#glb_set_radii", "glb_set_radii", 'routine in <a href="obj/glb/glb_set_radii.html">glb_set_radii.pro</a>', "glb_set_radii.pro", "", "glb_set_radii", "<code class= source >       Replaces the triaxial radii for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  radii<code class= source > Array (3,nt) of new triaxial radii.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_set_rref.html", "glb_set_rref.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_set_rref.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_set_rref.html#glb_set_rref", "glb_set_rref", 'routine in <a href="obj/glb/glb_set_rref.html">glb_set_rref.pro</a>', "glb_set_rref.pro", "", "glb_set_rref", "<code class= source >       Replaces the reference radius for each given globe descriptor.</code>  ", "noeventgbd<code class= source > Array (nt) of any subclass of GLOBE descriptors.</code>  rref<code class= source > String array (nt) of new reference radii.</code>  ", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_sub_point.html", "glb_sub_point.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_sub_point.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_sub_point.html#glb_sub_point", "glb_sub_point", 'routine in <a href="obj/glb/glb_sub_point.html">glb_sub_point.pro</a>', "glb_sub_point.pro", "", "glb_sub_point", "<code class= source >	Computes the planetocentric sub-point in body coordinates.</code>  ", "noeventgbd<code class= source >Array (nt) of any subclass of GLOBE descriptors.</code>  v", "NV/LIB/GLB", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nv,3,nt) points in the BODY frame that lie on the surface</code> <code class= source >	of each globe, directly 'beneath' r, i.e., such that each</code> <code class= source >	planetocentric surface normal points at each r.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/glb_sub_point_graphic.html", "glb_sub_point_graphic.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "glb_sub_point_graphic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/glb_sub_point_graphic.html#glb_sub_point_graphic", "glb_sub_point_graphic", 'routine in <a href="obj/glb/glb_sub_point_graphic.html">glb_sub_point_graphic.pro</a>', "glb_sub_point_graphic.pro", "", "glb_sub_point_graphic", "<code class= source >	Computes the planetographic sub-point in body coordinates.</code>  ", "noeventepsilon<code class= source >Convergence criterion for angular deviation from normal.</code> <code class= source >			Default is 1d-8.</code>  niter<code class= source >	Maximum number of iterations.  Default is 5000.</code>  gbd<code class= source >Array (nt) of any subclass of GLOBE descriptors.</code>  v", "NV/LIB/GLB", "<code class= source > 	Written by:		Spitale, 1/1998</code> <code class= source > 	Adapted by:		Spitale, 5/2016</code> <code class= source >	Added iteration count:	Moretto, 8/2016</code>  <code class= source >	Array (nv,3,nt) points in the BODY frame that lie on the surface</code> <code class= source >	of each globe, directly 'beneath' r, i.e., such that each</code> <code class= source >	planetographic surface normal points at each r.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_image.html", "globe_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "globe_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_image.html#globe_to_image", "globe_to_image", 'routine in <a href="obj/tools/composite/globe_to_image.html">globe_to_image.pro</a>', "globe_to_image.pro", "", "globe_to_image", "<code class= source >       Transforms points in body globe coordinates to image coordinates.</code>  ", "body_ptsvalidcd<code class= source >Array of nt Camera or map descriptor</code>  gbx<code class= source >Array of nt Object descriptor (of type GLOBE)</code>  p<code class= source >Array (nv x 3 x nt) of globe points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of image points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_map.html", "globe_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "globe_to_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/globe_to_map.html#globe_to_map", "globe_to_map", 'routine in <a href="obj/tools/composite/globe_to_map.html">globe_to_map.pro</a>', "globe_to_map.pro", "", "globe_to_map", "<code class= source >       Transforms points in globe coordinates to map coordinates.</code>  ", "md<code class= source >Array of nt map descriptor.</code>  gbx<code class= source >Array of nt globe descriptor.</code>  globe_pts<code class= source >Array (nv x 3 x nt) of globe points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of map coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/tools/gr_colortool.html", "gr_colortool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_colortool.pro", "", "", "<code class= source >	Tool for adjusting colors in GRIM.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code>  ");
  

libdata[libdataItem++] = new Array("grim/tools/gr_lsqtool.html", "gr_lsqtool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_lsqtool.pro", "", "", "", "", "          -1", "<code class= source > 	Written by:	Spitale 7/2002</code>  ");
  

libdata[libdataItem++] = new Array("grim/tools/gr_maptool.html", "gr_maptool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_maptool.pro", "", "", "", "", "          -1", "<code class= source > 	Written by:	Spitale 7/2002</code>  ");
  

libdata[libdataItem++] = new Array("grim/tools/gr_phttool.html", "gr_phttool.pro", '.pro file in <a href="grim/tools/dir-overview.html">grim/tools/ directory</a>', "gr_phttool.pro", "", "", "", "", "          -1", "<code class= source > 	Written by:	Spitale 7/2002</code>  ");
  

libdata[libdataItem++] = new Array("grim/interface/graft.html", "graft.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "graft.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/graft.html#graft", "graft", 'routine in <a href="grim/interface/graft.html">graft.pro</a>', "graft.pro", "", "graft", "<code class= source >	Grafts POINT arrays into GRIM.</code>  ", "psym<code class= source > Plotting symbol.</code>  symsize<code class= source >Plotting symbol size.</code>  color<code class= source > Plotting color.</code>  tag<code class= source > If given, the array is added as user data with this tag name.</code>  pn<code class= source > Plane number to access.  If not given, then current plane</code> <code class= source >		 is used.</code>  grn<code class= source > ID of GRIM instance to use.  If not given, then current one</code> <code class= source >		 is used.</code>  arg<code class= source >POINT object or array of image points.</code>  ", "NV/GR", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	(1) Open a GRIM window, load an image, and compute planet centers.</code> <code class= source >	(2) At the command line, type:</code> 		<span class= code-prompt >IDL&gt;</span> grift, gd=gd 		<span class= code-prompt >IDL&gt;</span> limb_ptd = pg_limb(gd=gd, gbx=gd.pd) 		<span class= code-prompt >IDL&gt;</span> graft, limb_ptd <code class= source >	GRIM should plot the new overlay.</code> <code class= source > SEE ALSO:</code> <code class= source >	grim, grift</code> ");
  
  

libdata[libdataItem++] = new Array("grim/interface/grift.html", "grift.pro", '.pro file in <a href="grim/interface/dir-overview.html">grim/interface/ directory</a>', "grift.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/interface/grift.html#grift", "grift", 'routine in <a href="grim/interface/grift.html">grift.pro</a>', "grift.pro", "", "grift", "<code class= source >	External access to GRIM data.  Purloins object and array references</code> <code class= source >	from GRIM so that they may be manipulated on the command line or by an</code> <code class= source >	external agent.  The returned descriptors allow direct access to the</code> <code class= source >	memory images of GRIM's objects, so any changes made affect the</code> <code class= source >	objects that GRIM is using.  GRIM monitors those objects and updates</code> <code class= source >	itself whenever a change occurs.</code>  ", "plane<code class= source >Grim plane structure(s) instead of giving pn.  Note all planes</code> <code class= source >		must belong to the same grim instance.</code>  pn<code class= source >Plane number(s) to access.  If not given, then current plane</code> <code class= source >		is used.</code>  all<code class= source >If set, all planes are used.</code>  active<code class= source >If set, only active memebrs of the selected objects are</code> <code class= source >		returned.</code>  grngd<code class= source >Generic descriptor containing all of GRIM's descriptors.</code> <code class= source >		For multiple planes, a list is returned with each element</code> <code class= source >		corresponding to a plane.</code> <code class= source >	&lt;xd&gt;:	Any descriptor maintained by GRIM.</code> <code class= source >	&lt;xdx&gt;:	Returnds all descriptors containing the given class, e.g.,</code> <code class= source >		bx, gbx, dkx.   Not implemented.</code> <code class= source >	&lt;overlay&gt;_ptd:</code> <code class= source >		POINT object giving the points for the overlay of type &lt;overlay&gt;.</code>  ddcdmdpdrdsdstdardltdodbxbbxdkxlimb_ptdring_ptdstar_ptdstation_ptdarray_ptdterm_ptdplgrid_ptdcenter_ptdshadow_ptdreflection_ptdobject_ptd<code class= source >		POINT object giving all overlay points.</code>  tie_ptd<code class= source >		POINT object giving the tie points.  For multiple planes, a</code> <code class= source >		list is returned with each element corresponding to a plane.</code>  curve_ptd<code class= source >		POINT object giving the curve points.  For multiple planes, a</code> <code class= source >		list is returned with each element corresponding to a plane.</code>  _ref_extraarg<code class= source >GRIM window number or GRIM data struture.  If not given, the</code> <code class= source >		most recently accessed grim instance is used.</code>  ", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  <code class= source >	(1) Open a GRIM window, load an image, and compute limb points.</code> <code class= source >	(2) At the command line, type:</code> 		<span class= code-prompt >IDL&gt;</span> grift, cd=cd 		<span class= code-prompt >IDL&gt;</span> pg_repoint, [50,50], 0d, cd=cd <code class= source >	GRIM should detect the change to the camera descriptor and update</code> <code class= source >	itself by recomputing the limb points and refreshing the display.</code> <code class= source > SEE ALSO:</code> <code class= source >	grim, graft</code> ");
  
  

libdata[libdataItem++] = new Array("grim/grim.html", "grim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim.html#grim_constants", "grim_constants", 'routine in <a href="grim/grim.html">grim.pro</a>', "grim.pro", "", "grim_constants", " GRIM        General-purpose GRaphical Interface for oMinas   CATEGORY: NV/GR   CALLING SEQUENCE: <code class= source >          grim, arg1, arg2</code>    ARGUMENTS:    INPUT:        arg1, arg2:              Grim accepts up to two arguments, which can appear in either             order.  Possible arguments are:                    data descriptors (object)                   file specification (string)                   grn (scalar)                   plot (1d array)                   image (2d array)                   cube (3d array)        Plots are displayed as graphs whose abscissa are the array index, unless       an abscissa is present in the data descriptor.  Many functions are not       available in this mode.        Cubes are handled as multiple image planes unless /rgb is used       (see below).  All grim planes will contain the same data array,       but display only data ranges corresponding to one channel of the cube.       For /rgb (assuming the cube has three channels), the data are placed       on a single image plane with each cube channel assigned the R, G, or B       color channel.    OUTPUT:        None    KEYWORDS:     INPUT:        Descriptor Keywords        The following inputs replace objects already maintained by GRIM.  They       must be given as either a single element, which is applied to the       current plane, or as an array with one element for each plane.        cd:  Replaces the current camera descriptor.  This may also be               a map descriptor, in which case some of GRIM's functions              will not be available.  When using a map descriptor instead              of a camera descriptor, you can specify a camera descriptor              as the observer descriptor (see the 'od' keyword below) and              some additional geometry functions will be available.        od:  Replaces the current observer descriptor.  The observer              descriptor is used to allow some geometry objects (limb,              terminator) to be computed when using a map descriptor instead              of a camera descriptor.        The following inputs replace or augment objects already maintained       by GRIM.  They are sorted into their respective planes by comparing       their internal generic descriptors with the data descriptor or       observer descriptor (in the case of a map) for each plane.  Objects       whose names match those already maintained by GRIM replace them.        ltd: Replaces the current light descriptor.        pd:   Adds/replaces planet descriptors.        rd:   Adds/replaces ring descriptors.        sd:   Adds/replaces star descriptors.        std:  Adds/replaces station descriptors        ard:  Adds/replaces array descriptors        gd:   Generic descriptor containing some or all of the above               descriptors.    assoc_xd:    If given, use these descriptors to sort descriptors into    planes instead of matching the data descriptors or observer    descriptors in their internal generic descriptors.        Descriptor Select Keywords        Descriptor select keywords (see pg_get_*) are specified using the       standard prefix corresponding to the descriptor type.  For example,       the fov keyword to pg_get_planets would be given to grim as plt_fov.        Initial Colormap Keywords        The colormap structure (see colormap_descriptor__define) can be       be initialized via keywords prefied with 'cmd_', e.g., 'cmd_shade'.       In addition, the following keywords apply to the initial color map:        *auto_stretch:             If set, the color table for each plane is automatically             stretched.  This is identical to using the 'Auto' button             on on the grim color tool.        Translator Keywords        The following keywords are passed directly to the translators, which       are responsible for interpreting their meanings.        *cam_trs: String giving translator keywords for the camera descriptors.        *lgt_trs: String giving translator keywords for the light descriptors.        *plt_trs: String giving translator keywords for the planet descriptors.        *rng_trs: String giving translator keywords for the ring descriptors.        *str_trs: String giving translator keywords for the star descriptors.        *stn_trs: String giving translator keywords for the stations descriptors.        *arr_trs: String giving translator keywords for the array descriptors.        TVIM Keywords        The following keywords set the initial viewing parameters and are       simply passed to TVIM.        *xsize:  Size of the graphics window in the x direction.        *ysize:  Size of the graphics window in the y direction.        *zoom:   Initial zoom to be applied to the image.  If not given, grim                  computes an initial zoom such that the entire image fits on the                  screen.        *rotate: Initial rotate value to be applied to the image (as in the IDL                  ROTATE routine).  If not given, 0 is assumed.        *order:  Initial display order to be applied to the image.        *offset: Initial offset (dx,dy) to be applied to the image.        doffset: Change the offset viewing parameter by this amount.        default: If set, use default tvim properties (zoom=[1,1], offset=[0,0]                  order=0 [bottom-up])        previous: If set, restore last-used tvim viewing parameters.        restore: If set, use saved tvim viewing paramters.        Customization Keywords        *menu_extensions:             Array of strings giving the names of functions that return             menu definitions, as defined by cw_pdmenu.  These menus are             added to the built-in GRIM menus between the Overlays menu             and the Help menu.  The default is 'grim_default_menus'.  If             the first character in the first menu function is '+', then             grim_default_menus is retained an the new menu are appended             after that menu.  Otherwise, 'grim_default_menus' is replaced.        *button_extensions:             Array of strings giving the names of definition functions             for custom cursor modes to be added after the built-in             cursor modes.  The definition function takes one argument             (see arg_extensions below) and returns a grim_user_mode_struct.        *arg_extensions:             Argument to be provided to the button extension definition             function above.        *menu_fname:             Name of a file containing additional menus to add to             the grim widget.  The file syntax follows that for cw_pdmenu.        Other Keywords        *extensions:                String array giving extensions to try for each input file.                see dat_read.        *new:  If set, a new grim instance is created and all keywords apply                to that instance.        erase: If set, erase the current image before doing anything else.        *mode_init:                Initial cursor mode.  See below.        *mode_args:                Array giving arguments for the cursor modes initialization                functions.  If a string, then syntax is NAME:ARG, where NAME                is the name of the cursor mode, and ARG is the argument for                that mode.  For example: <code class= source >  mode_args='READOUT:myreadout_fn'</code>                would cause the function 'myreadout_fn' to be added to                the list of functions called by pg_cursor and pg_measure                via the readout cursor mode.  If not a string, the argument                is passed to the initialization function with no processing.        *retain:                Retain settings for backing store (see  backing store  in                the IDL reference guide).  Defaults to 2.        *clip: Controls the number of fields of view in which overlays are                computed.        *fov:  Controls the number of fields of view in which to request                planet, ring and star descriptors.  Values are as follows:                     0 : get all descriptors                   &lt;0 : relative to viewport                   &gt;0 : relative to image / optic axis                 Note that fov &gt; 0 is the same as setting the fov descriptor                select keywords (see above).  Default is 0, but stars operate                best when fov &gt; 0.        *hide: If set, overlays are hidden w.r.t shadows and obstructions.                Default is on.        no_erase:                If set, GRIM does not erase the draw windoww.        no_refresh:                If set, grim does not refresh.        *rgb:  If set, grim interprets a 3-plane cube as a 3-channel color image                to be displayed on a single plane.        *channel:                Array of bitmasks specifying the color channel in which to                display each given image: 1b, 2b, or 4b.        *visibility:                Initial visibility setting for planes:                    0: Only the current plane is drawn.                   1: All planes are drawn.                 Default is 0.        *max:  Maximum data value to scale to when displaying images.                Values larger than this are set to the maximum color table                index.  If not set, the maximum value in the data set is used.                In cases where the data array is being subsampled, this value                may not be known, resulting in varying image scaling as more                and more data values are sampled.  That problem may be                eliminated via this keyword.        exit:  If set, GRIM immediately exits.  This can be used to kill an                existing GRIM window.        modal: If set, grim is run as a modal widget, i.e., there is no command                prompt.        *frame:If set, the initial view is set such that all members of the                named overlay types are are visible.  If /frame, then all                overlays are framed.  Note that object types that rely on the                view to determine which objects to compute (e.g., stars)                cannot be framed in this way.        refresh_callbacks:                Array of strings giving the names of procedures to be                called after each refresh.  See CALLBACK PROCEDURES                below.  Refresh callbacks receive only the data argument.        refresh_callback_data_ps:                Array of pointers (one per callback) to data for the refresh                callback procedures specified using the refresh_callbacks                keyword.  See CALLBACK PROCEDURES below.        plane_callbacks:                Array of strings giving the names of procedures to be                called after each plane change.  See CALLBACK PROCEDURES                below.  Plane callbacks receive only the data argument.        plane_callback_data_ps:                Array of pointers (one per callback) to data for the plane                callback procedures specified using the plane_callbacks                keyword.  See CALLBACK PROCEDURES below.        *nhist:History setting to be applied to data decriptor (see                ominas_data__define).  GRIM uses data descriptor history to                undo changes to the data array.  If nhist is not set, or is                equal to 1, the undo menu option will not function.        *maintain:                If given, this maintainance setting is applied to the data                descriptor (see ominas_data__define).        *compress:                Compression setting to be applied to data decriptor (see                ominas_data__define).        *filter:                Initial filter to use when loading or browsing files.        *load_path:                Initial path for the file loading dialog.        *save_path:                Initial path for the file saving dialog.        *path:  Sets both load_path and save_path to this value.        *workdir:                Default directory for saving user points, masks, tie                points, curves        user_psym:                Default plotting symbol for user overlays.        grn:   Identifies a specific GRIM window by number.  Grim numbers are                displayed in the status bar, e.g.: grim &lt;grn&gt;.        pn:    Directs GRIM to change to the plane corresponding to this plane                number.        *cursor_swap:                If set, cursor bitmaps are byte-order swapped.        *loadct:                Index of color table to load.        *beta: If set beta features are enabled.        *npoints:                Number of point to compute for various overlays.  Default is 1000.        *plane_syncing:                Turns plane syncing on (1) or off(0).  Default is 0.        *tiepoint_syncing:                Turns tiepoint syncing on (1) or off(0).  Default is 0.        *curve_syncing:                Turns curve syncing on (1) or off(0).  Default is 0.        position:                Sets the plot position; see the POSITION grahics keyword.        color: Sets the line color index for plots.  One element per plane.        xrange:Sets the X-axis range for plots.        yrange:Sets the Y-axis range for plots.        thick: Sets the line thickness for plots.  One element per plane.        title: For plots, sets the plot title for plots; one element per plane.                For images, sets the base default title.        xtitle:Sets the X-axis label for plots.  One element per plane.        ytitle:Sets the Y-axis label for plots.  One element per plane.        psym:  Sets the plotting symbol for plots.  One element per plane.        nsum:  See OPLOT.  One element per plane.        *lights:                List of bodies to use as light sources.  Default is 'SUN'.        *overlays:                List of initial overlays to compute on startup.  Each element                is of the form: <code class= source >          type[:name1,name2,...]</code>                where 'type' is one of {limb, terminator, center,                star, ring, planet_grid, array, station, shadow, reflection}                and the names identify the name of the desired object.  Note                that grim will load more objects than named if required by another                startup overlay.  For example: <code class= source >        overlays='ring:a_ring'</code>                will cause only one ring descriptor to load, whereas: <code class= source >        overlays=['limb:saturn', 'ring:a_ring']</code>                will cause all of Saturn's rings to load because they are                required in computing the limb points (for hiding).                 Different results may be obtained using translator keywords,                because those keywords are evaluated at the translator level.                For example: <code class= source >        overlays='ring:fn54'</code>                may result in no ring, while: <code class= source >        overlays='ring', trs_rd='name=fn54'</code>                would be more likely to yield a ring.  In the former example,                the specified name is compared against whatever default ring                descriptors are returned by the tranlators, while in the latter                case, the 'name' translator keyword is compared against all                rings available to the translator.                 Also note that the ordering is significant.  For example:                          overlays=['planet_grid:EARTH,MOON', $                                   'terminator:MOON', $                                   'shadow:MOON']  		produces a different result than:                          overlays=['terminator:MOON', $                                   'shadow:MOON'                                   'planet_grid:EARTH,MOON']        *delay_overlays:                If set, initial overlays (see 'overlays' above) are not computed                until the first time they are accessed.  This option can greatly                improve performance in cases where a large number of image planes                are loaded with initial overlays, particularly if it is not                expected that all planes will necesarily be viewed or otherwise                accessed.  Typically this option will cause overlays to be                computed only for the initially visible planes, with other                planes loading overlays only as they are made visible.  However,                there may be other cirumstances that can cause initial overlays                to be loaded without actually viewing a plane.        *activate:                If set, inital overlay are activated.        *ndd:  Sets the global ndd value in the OMINAS sate structure, which                controls the maximum number of data descriptors with maintain == 1                to keep in memory at any given time        *render_sampling:                Over-sampling value for rendering.        *render_numbra:                Number of random rays to trace to light sources when rendering.        *render_minimum:                Minimum value (percent) to assign to photometric output in                renderings.        *render_rgb:                If set, renderings are done in color if the source has color 		color planes.  Default is off.        *render_current:                If set, the rendering source is the image on this plane rather 		a map.  Default is off.        *render_spawn:                If set, renderings from an image (as opposed to a rendering) are 		placed on a new plane.  Default is on, except for rendering planes.        *render_sky:                If set, the sky is included in the rendering.  Default is off.        *render_auto:                If set, automatically render whenever there is an object event.                Default is off, though note that rendering planes always 		automatically re-render.        *rendering:                If set, perform a rendering on the initial descriptor set. 		(not yet implemented)    OUTPUT:        None    Resource File         The keywords marked above with an asterisk may be overridden using        the file $HOME/.ominas/grimrc.  Keyword=value pairs may be entered, one per        line, using the same syntax as if the keyword were entered on the IDL        command line to invoke grim.  Lines beginning with '#' are ignored.        Keywords entered in the resource file override the default values, and        are themselves overridden by keywords entered on the command line.    Shell Interface         The grim alias may be used to start grim from the shell prompt        via the XIDL interface.  The shell interface accepts all keywords        marked above with an asterisk.  See grim.bat.         Example (assuming the grim alias described in grim.bat): <code class= source >    % grim -beta data/*.img overlay=center,limb:JUPITER</code>         Grim currently defines no environment variables..    Environment Variables    Common Blocks          grim_block:          Keeps track of most recent grim instance and which ones are          selected.    Side Effects         Grim operates directly on the memory images of the descriptors that        it is given.  Therefore, those descriptors are modified during        a session.  This architecture allows data to be operated on concurrently        through grim and from the command line; see grift.pro for details.    Layout         The philosphy that drives GRIM's layout is that the maximum possible        screen space should be devoted to displaying the data.  This policy        allows for many GRIM windows to be used simultaneously without being        obscured by crazy control panels full of buttons, gadgets, widgets,        doodads, whirly-gigs, and what-nots.  The grim layout consists of the        following items:              Title bar                 The title bar displays the grim window number (grn),                the current plane number (pn), the total number of planes, the                name field of the data descriptor for the current plane, the                default title (if given; see the title keyword above), and                a string indicating which RGB channels are associated with the                current plane.              Menu bar                 Most of grim's functionality is accessed through the                system of pulldown menus at the top.  Individual menu                items are described in their own sections.              Shortcut buttons                 Some commonly used menu options are duplicated as shortcut                buttons arranged horizontally just beneath the menu bar.  The                function of each button is displayed in the status bar (see                below) when the mouse cursor is hovered ove the button.        Cursor mode buttons                 Cursor mode shortcut buttons are arranged vertically along the                left side of the GRIM window, and as provided as shortcuts                for the corresponding options in the Mode menu.  The following                modes are available:                    Activate:                        In activate mode, overlay objects may be activated                        or deactivated by clicking and/or dragging using the                        left or right mouse buttons respectively.  This                        activation mechanism allows the user to select which                        among a certain type of objects should be used in a                        given menu selection.  A left click on an overlay                        activates that overlay and a right click deactivates                        it.  A double click activates or deactivates all                        overlays associated with a given descriptor, or all                        stars.  Active overlays appear in the colors selected                        in the 'Overlay Settings' menu selection.  Inactive                        overlays appear in cyan.  A descriptor is active                        whenever any of its overlays are active.                    Zoom:The zoom button puts grim in a zoom cursor mode, wherein                        the image zoom and offset are controlled by selecting                        a box in the image.  When the box is created using the                        left mouse button, zoom and offset are changed so that                        the contents of the box best fill the current graphics                        window.  When the right button is used, the contents of                        the current graphics window are shrunken so as to best                        fill the box.  In other words, the left button zooms in                        and the right button zooms out.                    Pan: The pan button puts grim in a pan cursor mode, wherein the                        image offset is controlled by selecting an offset vector                        using the left mouse button.  The middle button may be                        used to center the image on a selected point.                    Pixel Readout:                        In pixel readout mode, a text window appears                        and displays data about the pixel selected                        using the left mouse button.                    Tiepoint:                        In tiepoint mode, tiepoints are added using the                        left mouse button and deleted using the right button.                        Tiepoints appear as crosses identified by numbers.                        The use of tiepoints is determined by the particular                        option selected by the user.                    Curve:                        In curve mode, curves are added using the                        left mouse button and deleted using the right button.                        Curves appear as red lines identified by numbers at                        each end.  The use of curves is determined by the                        particular option selected by the user.                    Mask:GRIM maintains a mask for each plane whose use is                        appication-dependent.  Mask mode allows pixels in the                        mask to be toggled on and off.                    Magnify:                        In magnify mode, image pixels in the graphics                        window may be magnifed using either the right or left                        mouse buttons.  The left button magnifies the displayed                        pixels, directly from the graphics window.  The right                        button magnifies the data itself, without the overlays.                    XY Zoom:                        Same as 'zoom' above, except the aspect ratio is                        set by the proportions of the selected box.                    Remove overlays:                        Allows the user to remove overlay arrays.                    Trim overlays:                        Allows the user to trim points from overlay arrays.                    Select within overlays:                        Allows the user to select points within overlay arrays.                    Define Region:                        Allows the user to define GRIM's region of interest.                    Smooth:                        Allows the user to select a smoothing box to be applied                        to the data array.                    Select Plane:                        Allows the user to change planes using the pointer.                        This option is only useful in cases where multiple                        planes are displayed.                    Drag Image:                        Allows the user to reposition the current plane by                        clicking and dragging.                    Navigate:                        Allows the user to modify the camera position and                        orientation using the mouse.                    Target:                        Allows the user to re-target the camera by clicking.              Graphics window                 The graphics window displays the data associated with the                given data descriptor using the current zoom, offset, and                display order.  The edges of an image are indicated by a dotted                line.  The camera optic axis is indicated by a large red cross.              Pixel readout                 The cursor position and corresponding data value are are                displayed beneath the graphics window, next to the message line.              Message line                 The message line displays short messages pertaining GRIM's                 current state, or displayng button functions.    Callback Procedures         GRIM callback procedures are called with one or two arguments:        the first argument is a pointer to data that was provided        when the callback was added.  The second argument, if present, depends        on the applicatation.    Resource Names         The following X-windows resource names apply to grim:          grim_base:   top level base         grim_mbar:   menu bar         grim_shortcuts_base: base containing shortcut buttons         grim_modes_base: base containing modes buttons         grim_draw:   grim draw widget         grim_label:    grim bottom label widget         To turn off the confusing higlight box around the modes buttons,        put the following line in your ~/.Xdefaults file: <code class= source >    Idl*grim_modes_base*highlightThickness:  0</code>         GRIM displays 1-, 2-, and 3-dimensional data sets.  1-dimensional        data arrays are displayed as plots.  In that case, the abscissa is        the sample number unless the data descriptor contains an abscissa.        2- and 3-dimensional arrays are displaye as image planes.  The only        difference between images and cubes in GRIM is that images planes        each have their own data descriptor, while cubes are represented by        multiple image planes that share a common data descriptor; each plane        in a cube corresponds to a unique offset in the data array stored in        the common data descriptor.  Some functionality is not available when        working with plots.  In that case, those options do not appear in the        menus.    Operation         GRIM requests only the data samples needed for the current viewing        parameters.  Therefore, GRIM can display data sets of arbitrary size        when used with a file reader that supports subsampling.  However, note        that specific menu options may request the entire data array, depending        on the application.         Each GRIM window may contain any number of planes as well as        associated geometric data (i.e. object descriptors) and overlay arrays        for displaying various geometric objects -- limbs, rings, stars, etc.        An array of user overlay points is maintained to be used for application-        specific purposes.  Generally, a set of overlay points or a descriptor        must be activated in order to be used as input to a menu item; see        activate mode above.         There are exclusive and non-exclusive mechanisms for selecting grim        windows.  Grim windows may be non-exclusively selected using the select        mode button mentioned above (upper-left corner).  The exclusive        selection mechanism consists of a  primary  GRIM window, indicated by        a red outline in the graphics window.  The primary selection is        changed by pressing any mode or shortcut button, or by clicking in        the graphics area of the desired grim window.  The meaning of the        various selections depends on the application.         The functions of the left and right mouse buttons are determined by the        cursor mode; some cursor modes define modifier keys to broaden the number        of functions available in that mode.  The middle mouse button toggles        the activation state of overlay arrays, or pans the image if no overlay        appears beneath the cursor.  The mouse wheel cycles among cursor modes,        or zooms about the cursor position if the control key is held down.         Objects maintained by GRIM are accessible via the grift interface,        for example:     <span class= code-prompt >IDL&gt;</span> grift, dd=dd, cd=cd, pd=pd, limb_ptd=limb_ptd        returns the data desciptor, camera descriptor, planet descriptors,        and limb points associated with the current plane.         GRIM registers event handlers for all of its objects, so the window        is updated any time an object is modifed, whether by GRIM or by some        other program, or from the command line.   ", "", "          -1", "   Written by: Spitale 7/2002               (1) To create a new grim instance with no data:      <span class= code-prompt >IDL&gt;</span> grim, /new             (2) To create a new grim instance with data from a file of name                  filename :  <span class= code-prompt >IDL&gt;</span> dd = dat_read(filename)  <span class= code-prompt >IDL&gt;</span> grim, dd  <code class= source >       or:</code>                   IDL&gt; grim, filename              (3) To give an existing grim instance a new camera descriptor:      <span class= code-prompt >IDL&gt;</span> grim, cd=cd         Window resizing is not precise.  GRIM tries to resize to the selected        size, but typically overshoots.  This is probably platform-dependent.    Known bugs         Objects inherited by rendering planes do not respond to events.         Image shifting:         -  Descriptors not updated if shift performed form another window            because the there's no way for the irst window to know to            update its descriptors               - fix wrap-around; clip instead         Plane-&gt;Coregister does not update descriptors         Navigate mode gets weird when you do certain modifer key presses           --&gt; maybe a conflict with &lt;ctrl&gt; wheel zoom action         Crashes occur with File-&gt;Close         /no_erase is not enabled for images, just plots.  Probably should fix        that.         Initial visibility setting does not seem to work until applied        using plane settings window.         /frame causes a crash if there are no initial overlays.         It's not clear whether the symsize keyword is actually used.         pn keyword does not function.         Crash when tiepoint syncing is on and tiepoint selected with        multiple planes.         Title keyword does not properly map multiple elements to multiple        planes.         Nsum keyword does not properly map multiple elements to multiple        planes.         Plane syncing appears to be incomplete and I don't remember what it        was supposed to be.  I'm sure it was awesome, though.         Not sure what slave_overlays keyword does, or was supposed to do.         Overlays on rendered planes do not respond to events         Menu toggles don't update propoerly in some circumsumstances.         grim_message sometimes pops up messages from nv_message, which can        be pretty obnxious.  This probably has to do with the calls to        grim_message in grim_compute.include         Overlay point selections are not retained after recomputing         Undo does not seem to be working reliably         Events on overlays copied to rendering planes do not function         The help menu is currently not working because it relied on the old        documentation system.         Navigation mode control is poor for the Shift-Right motion.  	Target mode flips the camera orientation in the X direction.  	File-&gt; Save Postscript doesn't work right: the image order is 	sometimes wrong, and the overlays don't line up    SEE ALSO         GRIFT, GRAFT   ");
  
  

libdata[libdataItem++] = new Array("grim/grim_default_menus.html", "grim_default_menus.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_default_menus.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_core_help_event", "grim_menu_core_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_core_help_event", "<code class= source >	This option allows you extract a brightness profile at the selected</code> <code class= source >	location for each plane in the image.  The left button selects a single</code> <code class= source >	point, and the right button selects a region to average over.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2016</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_image_profile_help_event", "grim_menu_image_profile_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_image_profile_help_event", "<code class= source >	This option allows you extract a brightness profile in an arbitrary</code> <code class= source >	direction in the image.  The left button selects the region's length</code> <code class= source >	and then width; the right button selects a region with a width of</code> <code class= source >	one pixel.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 6/2005</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_box_profile_radial_help_event", "grim_menu_ring_box_profile_radial_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_radial_help_event", "<code class= source >  This option allows you create a radial brightness profile from a</code> <code class= source >  rectangular image region.</code> <code class= source >   1) Activate the ring from which you wish to extract the profile.</code> <code class= source >   2) Select this option and use the mouse to outline a ring sector:</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 6/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_box_profile_longitudinal_help_event", "grim_menu_ring_box_profile_longitudinal_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_box_profile_longitudinal_help_event", "<code class= source >  This option allows you create a longitudinal brightness profile from a</code> <code class= source >  rectangular image region.</code> <code class= source >    1) Activate the ring from which you wish to extract the profile.</code> <code class= source >    2) Select this option and use the mouse to outline a ring sector.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_profile_radial_help_event", "grim_menu_ring_profile_radial_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_radial_help_event", "<code class= source >  This option allows you create a radial brightness profile.</code> <code class= source >   1) Activate the ring from which you wish to extract the profile.</code> <code class= source >   2) Select this option and use the mouse to outline a ring sector:</code> <code class= source >      Left Button:   the sector is bounded by lines of constant</code> <code class= source >                     longitude.', $</code> <code class= source >      Middle Button: the sector is selected in an arbitrary direction.</code> <code class= source >      Left Button:   the sector is bounded by lines perpendicular to</code> <code class= source >                     the projected longitudinal direction.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_ring_profile_longitudinal_help_event", "grim_menu_ring_profile_longitudinal_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_ring_profile_longitudinal_help_event", "<code class= source >  This option allows you create a longitudinal brightness profile.</code> <code class= source >    1) Activate the ring from which you wish to extract the profile.</code> <code class= source >    2) Select this option and use the mouse to outline a ring sector.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_limb_profile_azimuthal_help_event", "grim_menu_limb_profile_azimuthal_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_azimuthal_help_event", "<code class= source >  This option allows you create an azimutal brightness profile about a limb.</code> <code class= source >    1) Activate the planet from which you wish to extract the profile.</code> <code class= source >    2) Select this option and use the mouse to outline a sector.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2006</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_limb_profile_radial_help_event", "grim_menu_limb_profile_radial_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_limb_profile_radial_help_event", "<code class= source >  This option allows you create radial brightness profile across a limb.</code> <code class= source >    1) Activate the planet from which you wish to extract the profile.</code> <code class= source >    2) Select this option and use the mouse to outline a sector.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2006</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_farfit_help_event", "grim_menu_pointing_farfit_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_farfit_help_event", "<code class= source >   This option produces a rough pointing correction by comparing the</code> <code class= source >   active points with edges detected in the image using pg_edges and</code> <code class= source >   pg_farfit.</code> <code class= source >    1) Activate the edges that you wish to correlate.</code> <code class= source >    2) Select this option.</code> <code class= source >   Only active limbs, terminators, and ring edges are used.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_renderfit_help_event", "grim_menu_pointing_renderfit_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_renderfit_help_event", "<code class= source >   This option uses pg_renderfit to produce a pointing correction by comparing</code> <code class= source >   the image with a simulated image.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_pointing_lsq_help_event", "grim_menu_pointing_lsq_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_pointing_lsq_help_event", "<code class= source >	Opens a gr_lsqtool widget.  Using the current data, camera, active</code> <code class= source >	planet, and active ring descriptors.  See gr_lsqtool.pro for details.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_toggle_reorigin_event_help_event", "grim_menu_toggle_reorigin_event_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_toggle_reorigin_event_help_event", "<code class= source >   This option allows the user to set whether geometry descriptors are</code> <code class= source >   updated whenever the data array is shifted.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 12/2016</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_enter_step_event_help_event", "grim_menu_shift_enter_step_event_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_step_event_help_event", "<code class= source >   This option prompts the user to enter the step size for the image-shift</code> <code class= source >   menu options.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 1/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_enter_offset_event_help_event", "grim_menu_shift_enter_offset_event_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_enter_offset_event_help_event", "<code class= source >   This option prompts the user to shift an image by entering an offset.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 1/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_left_help_event", "grim_menu_shift_left_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_left_help_event", "<code class= source >   This option shifts the image left and corrects the camera pointing</code> <code class= source >   accordingly.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_right_help_event", "grim_menu_shift_right_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_right_help_event", "<code class= source >   This option shifts the image right and corrects the camera pointing</code> <code class= source >   accordingly.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_up_help_event", "grim_menu_shift_up_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_up_help_event", "<code class= source >   This option shifts the image up and corrects the camera pointing</code> <code class= source >   accordingly.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_shift_down_help_event", "grim_menu_shift_down_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_shift_down_help_event", "<code class= source >   This option shifts the image down and corrects the camera pointing</code> <code class= source >   accordingly.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_corrections_photometry_help_event", "grim_menu_corrections_photometry_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_corrections_photometry_help_event", "<code class= source >	Opens a gr_phttool widget.  Using the primary data, camera, planet, and</code> <code class= source >	ring descriptors.  See gr_phttool.pro for details.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_project_map_help_event", "grim_menu_project_map_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_project_map_help_event", "<code class= source >	Opens a gr_maptool widget.  Using the primary data, camera, planet, and</code> <code class= source >	ring descriptors.  See gr_maptool.pro for details.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_default_menus.html#grim_menu_mosaic_help_event", "grim_menu_mosaic_help_event", 'routine in <a href="grim/grim_default_menus.html">grim_default_menus.pro</a>', "grim_default_menus.pro", "", "grim_menu_mosaic_help_event", "<code class= source >	Uses pg_mosaic to combine all visible image planes into a mosaic.</code> <code class= source >	The new mosiac is opened in a new grim instance.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_menus_include.html", "grim_menus_include.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_menus_include.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_help_event", "grim_menu_file_load_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_help_event", "<code class= source >	Allows user to load images into new image planes.  The user is</code> <code class= source >	prompted for filenames and DAT_READ is used to read each image.</code> <code class= source >	Multiple images may be selected and a new plane is created for</code> <code class= source >	each image.  On X-windows systems, multiple files may be selected</code> <code class= source >	either by dragging across the filenames or by holding down the</code> <code class= source >	control key to toggle the selected files.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_browse_help_event", "grim_menu_file_browse_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_browse_help_event", "<code class= source >	Allows user to load images into new image planes using the BRIM</code> <code class= source >	browser.  Images are selected using the left mouse button and</code> <code class= source >	each image is loaded on a new plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_help_event", "grim_menu_file_save_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_help_event", "<code class= source >	Allows user to save the current image plane and geometry.  If there</code> <code class= source >	is no current filename for the current plane, then the user is</code> <code class= source >	prompted for one.  All descriptors are written through the translators</code> <code class= source >	and then DAT_WRITE is used to write the data file.  Specific behavior</code> <code class= source >	is governed by OMINAS' configuration.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_as_help_event", "grim_menu_file_save_as_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_as_help_event", "<code class= source >	Same as 'Save' above, except always prompts for a filename.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_open_as_rgb_help_event", "grim_menu_open_as_rgb_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_open_as_rgb_help_event", "<code class= source >	Opens a new GRIM window with the current channal configuration</code> <code class= source >	reduced to a 3-channel RGB cube.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2016</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_user_ptd_help_event", "grim_menu_file_save_user_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_user_ptd_help_event", "<code class= source >	Writes user points for the current plane to a file called</code> <code class= source >	[image name].user_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_all_user_ptd_help_event", "grim_menu_file_save_all_user_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_all_user_ptd_help_event", "<code class= source >	Writes user points for all planes to files called</code> <code class= source >	[image name].user_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_detached_header_help_event", "grim_menu_file_save_detached_header_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_detached_header_help_event", "<code class= source >	Saves a detached header for the current plane.  User is prompted</code> <code class= source >	to select the location, and name.  Default name is [image name].dh.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_all_detached_headers_help_event", "grim_menu_file_save_all_detached_headers_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_all_detached_headers_help_event", "<code class= source >	Writes detached headers for all planes to files called [image name].dh</code> <code class= source >	User is prompted for the directory name.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_user_ptd_help_event", "grim_menu_file_load_user_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_user_ptd_help_event", "<code class= source >	loads user points for the current plane from a file called</code> <code class= source >	[image name].user_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_all_user_ptd_help_event", "grim_menu_file_load_all_user_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_all_user_ptd_help_event", "<code class= source >	Loads user points for all planes from files called</code> <code class= source >	[image name].user_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_tie_ptd_help_event", "grim_menu_file_save_tie_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_tie_ptd_help_event", "<code class= source >	Writes tie points for the current plane to a file called</code> <code class= source >	[image name].tie_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_all_tie_ptd_help_event", "grim_menu_file_save_all_tie_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_all_tie_ptd_help_event", "<code class= source >	Writes tie points for all planes to files called</code> <code class= source >	[image name].tie_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_tie_ptd_help_event", "grim_menu_file_load_tie_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_tie_ptd_help_event", "<code class= source >	loads tie points for the current plane from a file called</code> <code class= source >	[image name].tie_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_all_tie_ptd_help_event", "grim_menu_file_load_all_tie_ptd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_all_tie_ptd_help_event", "<code class= source >	Loads tie points for all planes from files called</code> <code class= source >	[image name].tie_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_curves_help_event", "grim_menu_file_save_curves_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_curves_help_event", "<code class= source >	Writes curves for the current plane to a file called</code> <code class= source >	[image name].curve_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 12/2015</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_all_curves_help_event", "grim_menu_file_save_all_curves_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_all_curves_help_event", "<code class= source >	Writes curves for all planes to files called</code> <code class= source >	[image name].curve_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 12/2015</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_curves_help_event", "grim_menu_file_load_curves_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_curves_help_event", "<code class= source >	loads curves for the current plane from a file called</code> <code class= source >	[image name].curve_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 12/2015</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_all_curves_help_event", "grim_menu_file_load_all_curves_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_all_curves_help_event", "<code class= source >	Loads curves for all planes from files called</code> <code class= source >	[image name].curve_ptd</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 12/2015</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_mask_help_event", "grim_menu_file_save_mask_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_mask_help_event", "<code class= source >	Writes mask points for the current plane to a file called</code> <code class= source >	[image name].mask</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_all_masks_help_event", "grim_menu_file_save_all_masks_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_all_masks_help_event", "<code class= source >	Writes mask points for all planes to files called</code> <code class= source >	[image name].mask</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_mask_help_event", "grim_menu_file_load_mask_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_mask_help_event", "<code class= source >	loads mask points for the current plane from a file called</code> <code class= source >	[image name].mask</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_load_all_masks_help_event", "grim_menu_file_load_all_masks_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_load_all_masks_help_event", "<code class= source >	Loads mask points for all planes from files called</code> <code class= source >	[image name].mask</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_save_ps_help_event", "grim_menu_file_save_ps_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_save_ps_help_event", "<code class= source >	Saves the current view as a postscript file.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 12/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_repeat_help_event", "grim_menu_repeat_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_repeat_help_event", "<code class= source >	Repeats the last menu option.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2006</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_undo_help_event", "grim_menu_undo_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_undo_help_event", "<code class= source >	Undoes the last data modification.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2006</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_redo_help_event", "grim_menu_redo_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_redo_help_event", "<code class= source >	Redoes the last data modification.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2006</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_select_help_event", "grim_select_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_select_help_event", "<code class= source >	Selects or unselects a grim window.  This functionality is for use</code> <code class= source >	with functions that require input from more than one grim instance.</code> <code class= source >	The selected state is red; unselected is gray.</code>  ", "event", "NV/GR OPERATION:	This option toggles a given grim instance between selected	and unselected states for use with functions that require	input from more than one grim instance When a given instance	is selected this button displays an asterisk", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_identify_help_event", "grim_identify_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_identify_help_event", "<code class= source >	Causes grim to identify itself on the IDL command line.</code>  ", "event", "NV/GR OPERATION:	This option causes grim to print a message on the IDL command line It is useful in cases where multiple grim instances are running in	multiple IDL sessions", "<code class= source > 	Written by:	Spitale, 3/2009</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_file_close_help_event", "grim_menu_file_close_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_file_close_help_event", "<code class= source >	Closes the current image plane.  All other image plane numbers</code> <code class= source >	remain the same.  If there is only one image plane, the grim exits.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_next_help_event", "grim_menu_plane_next_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_next_help_event", "<code class= source >	Changes to the next-numbered image plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_previous_help_event", "grim_menu_plane_previous_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_previous_help_event", "<code class= source >	Changes to the previous-numbered image plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_jump_help_event", "grim_menu_plane_jump_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_jump_help_event", "<code class= source >	Prompts the user and jumps to a new plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2005</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_browse_help_event", "grim_menu_plane_browse_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_browse_help_event", "<code class= source >	Opens a brim browser showing all planes.  The left mouse button</code> <code class= source >	may be used to jump among planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_open_help_event", "grim_menu_plane_open_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_open_help_event", "<code class= source >	Opens the image of the current plane in a new grim window.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_evolve_help_event", "grim_menu_plane_evolve_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_evolve_help_event", "<code class= source >	Evolves the selected objects onto all other planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_crop_help_event", "grim_menu_plane_crop_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_crop_help_event", "<code class= source >	Crops the data to the current viewing parameters.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_reorder_time_help_event", "grim_menu_plane_reorder_time_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_reorder_time_help_event", "<code class= source >	Rearranges all planes in time order.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_sequence_help_event", "grim_menu_plane_sequence_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_sequence_help_event", "<code class= source >	Displays all planes in sequence using xinteranimate.  This option is</code> <code class= source >	useful or blinking as well.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_dump_help_event", "grim_menu_plane_dump_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_dump_help_event", "<code class= source >	Dumps all planes to png files entitled [filename].png.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_coregister_help_event", "grim_menu_plane_coregister_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_coregister_help_event", "<code class= source >	Shifts the images on each plane so as to center the active object</code> <code class= source >	at the same pixel on each plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_coadd_help_event", "grim_menu_plane_coadd_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_coadd_help_event", "<code class= source >	Averages all planes.  Not implemented.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_toggle_plane_syncing_help_event", "grim_menu_plane_toggle_plane_syncing_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_toggle_plane_syncing_help_event", "<code class= source >	Toggles plane syncing on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2016</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_highlight_help_event", "grim_menu_plane_highlight_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_highlight_help_event", "<code class= source >	Toggles highlighting of the current plane image.  Useful when</code> <code class= source >	multiple planes are visible simultaneously.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_copy_tiepoints_help_event", "grim_menu_plane_copy_tiepoints_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_copy_tiepoints_help_event", "<code class= source >	Copies tie points from the current plane to all other planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_propagate_tiepoints_help_event", "grim_menu_plane_propagate_tiepoints_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_propagate_tiepoints_help_event", "<code class= source >	Copies all tieppoints from the current plane to all other planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_toggle_tiepoint_syncing_help_event", "grim_menu_plane_toggle_tiepoint_syncing_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_toggle_tiepoint_syncing_help_event", "<code class= source >	Toggles tiepoint syncing on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_clear_tiepoints_help_event", "grim_menu_plane_clear_tiepoints_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_clear_tiepoints_help_event", "<code class= source >	Clears all tiepoints from the current plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_copy_curves_help_event", "grim_menu_plane_copy_curves_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_copy_curves_help_event", "<code class= source >	Copies all curves from the current plane to all other planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_toggle_curve_syncing_help_event", "grim_menu_plane_toggle_curve_syncing_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_toggle_curve_syncing_help_event", "<code class= source >	Toggles curve syncing on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_clear_curves_help_event", "grim_menu_plane_clear_curves_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_clear_curves_help_event", "<code class= source >	Clears all curves from the current plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_copy_mask_help_event", "grim_menu_plane_copy_mask_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_copy_mask_help_event", "<code class= source >	Copies mask from the current plane to all other planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_clear_mask_help_event", "grim_menu_plane_clear_mask_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_clear_mask_help_event", "<code class= source >	Clears the mask from the current plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_plane_settings_help_event", "grim_menu_plane_settings_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_plane_settings_help_event", "<code class= source >	Allows the user modify settings for the loaded image planes.</code> <code class= source >	Each plane may displayed in any combination of the three color</code> <code class= source >	channels.  Also, a plane may be made visible even when it is not</code> <code class= source >	the current plane, instead of the default behavior, which is to</code> <code class= source >	display the plane only whenit is current.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_data_adjust_help_event", "grim_menu_data_adjust_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_data_adjust_help_event", "<code class= source >	This option allows the user to adjust data values.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2014</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_refresh_help_event", "grim_menu_view_refresh_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_refresh_help_event", "<code class= source >	Redraws the overlays on the graphics display.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_help_event", "grim_menu_view_zoom_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_help_event", "<code class= source >	Prompts the user for a new zoom factor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2005</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_double_help_event", "grim_menu_view_zoom_double_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_double_help_event", "<code class= source >	Doubles the current zoom, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_half_help_event", "grim_menu_view_zoom_half_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_half_help_event", "<code class= source >	Halves the current zoom, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_help_event", "grim_menu_view_zoom_1_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_help_event", "<code class= source >	Sets the current zoom to 1, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_2_help_event", "grim_menu_view_zoom_2_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_2_help_event", "<code class= source >	Sets the current zoom to 2, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_3_help_event", "grim_menu_view_zoom_3_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_3_help_event", "<code class= source >	Sets the current zoom to 3, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_4_help_event", "grim_menu_view_zoom_4_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_4_help_event", "<code class= source >	Sets the current zoom to 4, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_5_help_event", "grim_menu_view_zoom_5_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_5_help_event", "<code class= source >	Sets the current zoom to 5, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_6_help_event", "grim_menu_view_zoom_6_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_6_help_event", "<code class= source >	Sets the current zoom to 6, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_7_help_event", "grim_menu_view_zoom_7_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_7_help_event", "<code class= source >	Sets the current zoom to 7, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_8_help_event", "grim_menu_view_zoom_8_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_8_help_event", "<code class= source >	Sets the current zoom to 8, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_9_help_event", "grim_menu_view_zoom_9_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_9_help_event", "<code class= source >	Sets the current zoom to 9, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_10_help_event", "grim_menu_view_zoom_10_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_10_help_event", "<code class= source >	Sets the current zoom to 10, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_2_help_event", "grim_menu_view_zoom_1_2_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_2_help_event", "<code class= source >	Sets the current zoom to 1/2, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_3_help_event", "grim_menu_view_zoom_1_3_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_3_help_event", "<code class= source >	Sets the current zoom to 1/3, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_4_help_event", "grim_menu_view_zoom_1_4_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_4_help_event", "<code class= source >	Sets the current zoom to 1/4, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_5_help_event", "grim_menu_view_zoom_1_5_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_5_help_event", "<code class= source >	Sets the current zoom to 1/5, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_5_help_event", "grim_menu_view_zoom_1_5_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_5_help_event", "<code class= source >	Sets the current zoom to 1/5, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_6_help_event", "grim_menu_view_zoom_1_6_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_6_help_event", "<code class= source >	Sets the current zoom to 1/6, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_7_help_event", "grim_menu_view_zoom_1_7_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_7_help_event", "<code class= source >	Sets the current zoom to 1/7, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_8_help_event", "grim_menu_view_zoom_1_8_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_8_help_event", "<code class= source >	Sets the current zoom to 1/8, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_9_help_event", "grim_menu_view_zoom_1_9_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_9_help_event", "<code class= source >	Sets the current zoom to 1/9, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_zoom_1_10_help_event", "grim_menu_view_zoom_1_10_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_zoom_1_10_help_event", "<code class= source >	Sets the current zoom to 1/10, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_0_help_event", "grim_menu_view_rotate_0_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_0_help_event", "<code class= source >	Sets the current rotate to 0, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_1_help_event", "grim_menu_view_rotate_1_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_1_help_event", "<code class= source >	Sets the current rotate to 1, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_2_help_event", "grim_menu_view_rotate_2_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_2_help_event", "<code class= source >	Sets the current rotate to 2, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_3_help_event", "grim_menu_view_rotate_3_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_3_help_event", "<code class= source >	Sets the current rotate to 3, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_4_help_event", "grim_menu_view_rotate_4_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_4_help_event", "<code class= source >	Sets the current rotate to 4, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_5_help_event", "grim_menu_view_rotate_5_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_5_help_event", "<code class= source >	Sets the current rotate to 5, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_6_help_event", "grim_menu_view_rotate_6_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_6_help_event", "<code class= source >	Sets the current rotate to 6, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_rotate_7_help_event", "grim_menu_view_rotate_7_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_rotate_7_help_event", "<code class= source >	Sets the current rotate to 7, centered at the mouse cursor.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2013</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_recenter_help_event", "grim_menu_view_recenter_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_recenter_help_event", "<code class= source >	Recenters the view at the cursor position.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2008</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_apply_help_event", "grim_menu_view_apply_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_apply_help_event", "<code class= source >	Applys the current view to all planes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2016</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_home_help_event", "grim_menu_view_home_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_home_help_event", "<code class= source >	Sets the tvim home view settings.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 5/2005</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_save_help_event", "grim_menu_view_save_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_save_help_event", "<code class= source >	Saves the current view settings.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_restore_help_event", "grim_menu_view_restore_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_restore_help_event", "<code class= source >	Restores the last-saved view settings.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_previous_help_event", "grim_menu_view_previous_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_previous_help_event", "<code class= source >	Restores the previous view settings.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_entire_help_event", "grim_menu_view_entire_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_entire_help_event", "<code class= source >	Applies the 'entire' display parameters, as given in tvim.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_initial_help_event", "grim_menu_view_initial_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_initial_help_event", "<code class= source >	Reverts to the initial view parameters for this grim widget.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2007</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_flip_help_event", "grim_menu_view_flip_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_flip_help_event", "<code class= source >	Reverses the curent display order.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_frame_help_event", "grim_menu_view_frame_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_frame_help_event", "<code class= source >	Modifies view settings so as to display the either all overlays</code> <code class= source >	or those that are active.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2007</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_header_help_event", "grim_menu_view_header_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_header_help_event", "<code class= source >	Opens a text window showing the image header.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_notes_help_event", "grim_menu_notes_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_notes_help_event", "<code class= source >	Opens a text window allowing the user to enter notes for each plane.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 10/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_image_help_event", "grim_menu_image_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_image_help_event", "<code class= source >	Toggles the image On/Off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_image_overlays_help_event", "grim_menu_image_overlays_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_image_overlays_help_event", "<code class= source >	Toggles the image and overlays On/Off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_context_help_event", "grim_menu_context_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_context_help_event", "<code class= source >	Toggles the context window On/Off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2005</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_axes_help_event", "grim_menu_axes_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_axes_help_event", "<code class= source >	Toggles the axes window On/Off.  The colors are as follows:</code> <code class= source >	 Blue	- Inertial axes.</code> <code class= source >	 Red	- Camera axes.</code> <code class= source >	 Green	- Direction to primary planet, not foreshortened.</code> <code class= source >	 Yellow	- Direction to primary light source, not foreshortened.</code> <code class= source >	Vectors pointing away from the camera are dotted.  The vectors are</code> <code class= source >	rooted at a point 1d5 distance units in front of the camera .</code> <code class= source >	In the direction corresponding to the image position of the drawn</code> <code class= source >	axes.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2005</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_toggle_rgb_help_event", "grim_menu_render_toggle_rgb_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_toggle_rgb_help_event", "<code class= source >	Toggles RGB rendering on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_enter_numbra_help_event", "grim_menu_render_enter_numbra_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_enter_numbra_help_event", "<code class= source >   This option prompts the user to enter a numbra value for rendering.  Numbra</code> <code class= source >   specifies the number of samples to compute on a light source to produce</code> <code class= source >   accurate shadows.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_enter_sampling_help_event", "grim_menu_render_enter_sampling_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_enter_sampling_help_event", "<code class= source >   This option prompts the user to enter a sampling value for rendering.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_enter_minimum_help_event", "grim_menu_render_enter_minimum_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_enter_minimum_help_event", "<code class= source >   This option prompts the user to enter a minimum data value (0-1) for</code> <code class= source >   renderings.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_toggle_current_plane_help_event", "grim_menu_render_toggle_current_plane_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_toggle_current_plane_help_event", "<code class= source >	Toggles rednering from the current plane on/off.  If off, rendering</code> <code class= source >	data are taken from any map projections found by PG_LOAD_MAPS. When</code> <code class= source >	toggled on, the current data descriptor and camera descriptor are</code> <code class= source >	cloned and saved for use as the rendering source.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_toggle_spawn_help_event", "grim_menu_render_toggle_spawn_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_toggle_spawn_help_event", "<code class= source >	Toggles spawning of a new plane for each rendering on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_toggle_sky_help_event", "grim_menu_render_toggle_sky_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_toggle_sky_help_event", "<code class= source >	Toggles sky rendering on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_toggle_auto_help_event", "grim_menu_render_toggle_auto_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_toggle_auto_help_event", "<code class= source >	Toggles automatic rendering on/off.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_render_help_event", "grim_menu_render_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_render_help_event", "<code class= source >	Renders the visible scene and places it in a new plane unless</code> <code class= source >	the current plane is already a rendering.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2015</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_view_colors_help_event", "grim_menu_view_colors_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_view_colors_help_event", "<code class= source >	Opens gr_colortool.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_centers_help_event", "grim_menu_points_centers_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_centers_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	center positions using pg_center for all active globes.  If no</code> <code class= source >	active objects, then all centers are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_limbs_help_event", "grim_menu_points_limbs_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_limbs_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	limbs using pg_limbs for all active objects.  If no active objects,</code> <code class= source >	then all limbs are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_terminators_help_event", "grim_menu_points_terminators_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_terminators_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	terminators using pg_limb with the lights as the observer for all active</code> <code class= source >	objects.  If no active objects, then all terminators are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_planet_grids_help_event", "grim_menu_points_planet_grids_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_planet_grids_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	planet grids using pg_grid for all active objects.  If no active</code> <code class= source >	objects, then all grids are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_rings_help_event", "grim_menu_points_rings_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_rings_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	ring outlines using pg_disk.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_ring_grids_help_event", "grim_menu_points_ring_grids_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_ring_grids_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	ring grids using pg_grid for all active objects.  If no active</code> <code class= source >	objects, then all grids are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2004</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_stations_help_event", "grim_menu_points_stations_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_stations_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	planet stations for all active objects.  If no active objects, then</code> <code class= source >	all stations are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 2/2009</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_arrays_help_event", "grim_menu_points_arrays_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_arrays_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	arrays for all active objects.  If no active objects, then</code> <code class= source >	all arrays are computed.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 3/2012</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_stars_help_event", "grim_menu_points_stars_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_stars_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	star positions using pg_center.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_shadows_help_event", "grim_menu_points_shadows_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_shadows_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	shadows of the currently active overlay points on all other objects.</code> <code class= source >	Note that you may have to disable overlay hiding in order to compute</code> <code class= source >	and activate all of the appropriate source points for the shadows</code> <code class= source >	since many point that are not visible to the observer may still have</code> <code class= source >	a line of sight to the lights.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 1/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_reflections_help_event", "grim_menu_points_reflections_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_reflections_help_event", "<code class= source >	Obtains the necessary descriptors through the translators and computes</code> <code class= source >	reflections of the currently active overlay points on all other objects.</code> <code class= source >	Note that you may have to disable overlay hiding in order to compute</code> <code class= source >	and activate all of the appropriate source points for the reflections</code> <code class= source >	since many point that are not visible to the observer may still have</code> <code class= source >	a line of sight to the lights.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 1/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_hide_all_help_event", "grim_menu_hide_all_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_hide_all_help_event", "<code class= source >	 Hides/unhides all overlay objects.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 1/2003</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_clear_all_help_event", "grim_menu_clear_all_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_clear_all_help_event", "<code class= source >	 Clears all objects.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_clear_active_help_event", "grim_menu_clear_active_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_clear_active_help_event", "<code class= source >	 Clears all active objects.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_activate_all_help_event", "grim_menu_activate_all_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_activate_all_help_event", "<code class= source >	 Activates all objects.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_deactivate_all_help_event", "grim_menu_deactivate_all_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_deactivate_all_help_event", "<code class= source >	 Deactivates all objects.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 9/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_invert_all_help_event", "grim_menu_invert_all_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_invert_all_help_event", "<code class= source >	 Inverts current overlay activations.  Desccriptor activations are</code> <code class= source >	 determined by the resulting overlay activations.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 11/2002</code>  ");
  
  libdata[libdataItem++] = new Array("grim/grim_menus_include.html#grim_menu_points_settings_help_event", "grim_menu_points_settings_help_event", 'routine in <a href="grim/grim_menus_include.html">grim_menus_include.pro</a>', "grim_menus_include.pro", "", "grim_menu_points_settings_help_event", "<code class= source >	Allows the user modify settings relevant to the overlay points.</code>  ", "event", "NV/GR", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_activate.html", "grim_mode_activate.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_activate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_activate.html#grim_mode_activate_button_help_event", "grim_mode_activate_button_help_event", 'routine in <a href="grim/grim_mode_activate.html">grim_mode_activate.pro</a>', "grim_mode_activate.pro", "", "grim_mode_activate_button_help_event", "<code class= source >	Selects the activate cursor mode.</code>  ", "event", "NV/GR OPERATION: 	Overlay objects may be activated or deactivated by clicking	and/or dragging using the left or right mouse buttons	respectively This activation mechanism allows the user to	select which among a certain type of objects should be used	in a given menu selection A left click on an overlay	activates that overlay and a right click deactivates it A	double click activates or deactivates all overlays associated	with a given descriptor or all stars Active overlays appear	in the colors selected in the 'Overlay Settings' menu selection Inactive overlays appear in cyan A descriptor is active	whenever any of its overlays are active", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_curves.html", "grim_mode_curves.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_curves.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_curves.html#grim_mode_curves_button_help_event", "grim_mode_curves_button_help_event", 'routine in <a href="grim/grim_mode_curves.html">grim_mode_curves.pro</a>', "grim_mode_curves.pro", "", "grim_mode_curves_button_help_event", "<code class= source >	Selects the curves cursor mode.</code>  ", "event", "NV/GR OPERATION:	curves are added using the left mouse button and deleted	using the right button", "<code class= source > 	Written by:	Spitale, 10/2012</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_drag.html", "grim_mode_drag.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_drag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_drag.html#grim_mode_drag_button_help_event", "grim_mode_drag_button_help_event", 'routine in <a href="grim/grim_mode_drag.html">grim_mode_drag.pro</a>', "grim_mode_drag.pro", "", "grim_mode_drag_button_help_event", "<code class= source >	Selects the drag cursor mode.</code>  ", "event", "NV/GR OPERATION:	Allow the user to drag the image", "<code class= source > 	Written by:	Spitale, 2/2009</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html", "grim_mode_magnify.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_magnify.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_magnify.html#grim_mode_magnify_button_help_event", "grim_mode_magnify_button_help_event", 'routine in <a href="grim/grim_mode_magnify.html">grim_mode_magnify.pro</a>', "grim_mode_magnify.pro", "", "grim_mode_magnify_button_help_event", "<code class= source >	Selects the magnify cursor mode.</code>  ", "event", "NV/GR OPERATION:	Image pixels in the graphics window may be magnifed using	either the left or right mouse buttons The left button	magnifies the displayed pixels directly from the graphics	window The right button magnifies the data itself without	the overlays", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_mask.html", "grim_mode_mask.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_mask.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_mask.html#grim_mode_mask_button_help_event", "grim_mode_mask_button_help_event", 'routine in <a href="grim/grim_mode_mask.html">grim_mode_mask.pro</a>', "grim_mode_mask.pro", "", "grim_mode_mask_button_help_event", "<code class= source >	Selects the mask cursor mode.</code>  ", "event", "NV/GR OPERATION:	Allowqs the user to select pixel to include in the mask", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html", "grim_mode_navigate.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_navigate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_navigate.html#grim_mode_navigate_button_help_event", "grim_mode_navigate_button_help_event", 'routine in <a href="grim/grim_mode_navigate.html">grim_mode_navigate.pro</a>', "grim_mode_navigate.pro", "", "grim_mode_navigate_button_help_event", "<code class= source >	Selects the navigate cursor mode.</code> <code class= source >	 Camera orientation:</code> <code class= source >	   Left button:		Allows the optic axis to be repointed.</code> <code class= source >	   Right button:	Allows the camera to twist about an axis</code> <code class= source >				corresponding to the selected pixel location.</code> <code class= source >	 Camera position:</code> <code class= source >	   &lt;Shift&gt; Left:	Allows the camera to be repositioned in the</code> <code class= source >				X-Z plane (image plane).  Speeds depend on</code> <code class= source >				the object under the cursor.</code> <code class= source >	   &lt;Shift&gt; Right:	Allows the camera to be repositioned and</code> <code class= source >				reoriented simultaneosly by tracking the</code> <code class= source >				object under the cursor.</code> <code class= source >	   &lt;Shift&gt; Wheel:	Allows the camera to be repositioned in the</code> <code class= source >				Y (optic axis) direction.  Speeds depend on</code> <code class= source >				the object under the cursor.</code>  ", "event", "NV/GR OPERATION:	Allow the user to fly around the system", "<code class= source > 	Written by:	Spitale, 2/2009</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_pan.html", "grim_mode_pan.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_pan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan.html#grim_mode_pan_button_help_event", "grim_mode_pan_button_help_event", 'routine in <a href="grim/grim_mode_pan.html">grim_mode_pan.pro</a>', "grim_mode_pan.pro", "", "grim_mode_pan_button_help_event", "<code class= source >	Selects the pan cursor mode.</code>  ", "event", "NV/GR OPERATION:	The image offset is controlled by selecting an offset vector	using the left mouse button or the middle button may be	used to center the image on a selected point", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html", "grim_mode_pan_plot.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_pan_plot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_pan_plot.html#grim_mode_pan_plot_button_help_event", "grim_mode_pan_plot_button_help_event", 'routine in <a href="grim/grim_mode_pan_plot.html">grim_mode_pan_plot.pro</a>', "grim_mode_pan_plot.pro", "", "grim_mode_pan_plot_button_help_event", "<code class= source >	Selects the pan cursor mode.</code>  ", "event", "NV/GR OPERATION:	The image offset is controlled by selecting an offset vector	using the left mouse button or the middle button may be	used to center the image on a selected point", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_plane.html", "grim_mode_plane.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_plane.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_plane.html#grim_mode_plane_button_help_event", "grim_mode_plane_button_help_event", 'routine in <a href="grim/grim_mode_plane.html">grim_mode_plane.pro</a>', "grim_mode_plane.pro", "", "grim_mode_plane_button_help_event", "<code class= source >	Selects the plane cursor mode.</code>  ", "event", "NV/GR OPERATION:	Planes can be selected by clicking in the image window This option	is not useful unless planes other than the current plane are visible If more than one plane under the cursor contains data the one with	the lowest plane number is selected unless one of them is the current	plane", "<code class= source > 	Written by:	Spitale, 8/2008</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_readout.html", "grim_mode_readout.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_readout.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_readout.html#grim_mode_readout_button_help_event", "grim_mode_readout_button_help_event", 'routine in <a href="grim/grim_mode_readout.html">grim_mode_readout.pro</a>', "grim_mode_readout.pro", "", "grim_mode_readout_button_help_event", "<code class= source >	Selects the readout cursor mode.</code>  ", "event", "NV/GR OPERATION:	A text window appears and displays data about the pixel selected	using the left mouse button The amount and type of information	displayed depends on which descriptors are loaded", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_region.html", "grim_mode_region.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_region.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_region.html#grim_mode_region_button_help_event", "grim_mode_region_button_help_event", 'routine in <a href="grim/grim_mode_region.html">grim_mode_region.pro</a>', "grim_mode_region.pro", "", "grim_mode_region_button_help_event", "<code class= source >	Selects the 'region' cursor mode.</code>  ", "event", "NV/GR OPERATION:	An image region is defined by clicking and dragging a box or curve", "<code class= source > 	Written by:	Spitale, 2/2014</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_remove.html", "grim_mode_remove.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_remove.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_remove.html#grim_mode_remove_button_help_event", "grim_mode_remove_button_help_event", 'routine in <a href="grim/grim_mode_remove.html">grim_mode_remove.pro</a>', "grim_mode_remove.pro", "", "grim_mode_remove_button_help_event", "<code class= source >	Selects the remove cursor mode.</code>  ", "event", "NV/GR OPERATION:	A single click on an overlay causes it to be deleted A       double click causes the entire object to be deleted The left	button applies to standard overlays; the right button applies	to user overlays", "<code class= source > 	Written by:	Spitale, 8/2006</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_select.html", "grim_mode_select.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_select.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_select.html#grim_mode_select_button_help_event", "grim_mode_select_button_help_event", 'routine in <a href="grim/grim_mode_select.html">grim_mode_select.pro</a>', "grim_mode_select.pro", "", "grim_mode_select_button_help_event", "<code class= source >	Selects the 'select' cursor mode.</code>  ", "event", "NV/GR OPERATION:	Overlay points are selected by clicking and dragging and curve around	the desired points The left button selects overlay points the right	deselects overlay points", "<code class= source > 	Written by:	Spitale, 2/2014</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html", "grim_mode_smooth.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_smooth.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_smooth.html#grim_mode_smooth_button_help_event", "grim_mode_smooth_button_help_event", 'routine in <a href="grim/grim_mode_smooth.html">grim_mode_smooth.pro</a>', "grim_mode_smooth.pro", "", "grim_mode_smooth_button_help_event", "<code class= source >	Selects the smooth cursor mode.</code>  ", "event", "NV/GR OPERATION:	The user selects a box which is used to determine the kernel	size for smothing the data set", "<code class= source > 	Written by:	Spitale, 10/2006</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_target.html", "grim_mode_target.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_target.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_target.html#grim_mode_target_button_help_event", "grim_mode_target_button_help_event", 'routine in <a href="grim/grim_mode_target.html">grim_mode_target.pro</a>', "grim_mode_target.pro", "", "grim_mode_target_button_help_event", "<code class= source >	Selects the target cursor mode.</code> <code class= source >	 Camera orientation:</code> <code class= source >	   Left button:		Repoints the optic axis at the cursor.</code> <code class= source >	   Right button:	Repoints the optic axis at the center of the</code> <code class= source >				nearest selected body.</code>  ", "event", "NV/GR OPERATION:	Repoints the camera at the cursor position or a selected body", "<code class= source > 	Written by:	Spitale, 8/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html", "grim_mode_tiepoints.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_tiepoints.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_tiepoints.html#grim_mode_tiepoints_button_help_event", "grim_mode_tiepoints_button_help_event", 'routine in <a href="grim/grim_mode_tiepoints.html">grim_mode_tiepoints.pro</a>', "grim_mode_tiepoints.pro", "", "grim_mode_tiepoints_button_help_event", "<code class= source >	Selects the tiepoints cursor mode.</code>  ", "event", "NV/GR OPERATION:	Tiepoints are added using the left mouse button and deleted	using the right button Tiepoints appear as crosses labeled	by numbers The use of tiepoints is determined by the	particular option selected by the user", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_trim.html", "grim_mode_trim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_trim.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_trim.html#grim_mode_trim_button_help_event", "grim_mode_trim_button_help_event", 'routine in <a href="grim/grim_mode_trim.html">grim_mode_trim.pro</a>', "grim_mode_trim.pro", "", "grim_mode_trim_button_help_event", "<code class= source >	Selects the trim cursor mode.</code>  ", "event", "NV/GR OPERATION:	Overlay points are trimmed by clicking and dragging and curve around	the desired points The left button trims standard overlays the right	trims user overlay points", "<code class= source > 	Written by:	Spitale, 8/2006</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html", "grim_mode_xyzoom.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_xyzoom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_xyzoom.html#grim_mode_xyzoom_button_help_event", "grim_mode_xyzoom_button_help_event", 'routine in <a href="grim/grim_mode_xyzoom.html">grim_mode_xyzoom.pro</a>', "grim_mode_xyzoom.pro", "", "grim_mode_xyzoom_button_help_event", "<code class= source >	Selects the xy-zoom cursor mode.</code>  ", "event", "NV/GR OPERATION:	Same as 'zoom' mode except the aspect ratio is set by the	proportions of the selected box", "<code class= source > 	Written by:	Spitale, 5/2005</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html", "grim_mode_zoom.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_zoom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom.html#grim_mode_zoom_button_help_event", "grim_mode_zoom_button_help_event", 'routine in <a href="grim/grim_mode_zoom.html">grim_mode_zoom.pro</a>', "grim_mode_zoom.pro", "", "grim_mode_zoom_button_help_event", "<code class= source >	Selects the zoom cursor mode.</code>  ", "event", "NV/GR OPERATION:	The image zoom and offset are controlled by selecting	a box in the image When the box is created using the	left mouse button zoom and offset are changed so that	the contents of the box best fill the current graphics	window When the right button is used the contents of	the current graphics window are shrunken so as to best	fill the box In other words the left button zooms in	and the right button zooms out", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html", "grim_mode_zoom_plot.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "grim_mode_zoom_plot.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("grim/grim_mode_zoom_plot.html#grim_mode_zoom_plot_button_help_event", "grim_mode_zoom_plot_button_help_event", 'routine in <a href="grim/grim_mode_zoom_plot.html">grim_mode_zoom_plot.pro</a>', "grim_mode_zoom_plot.pro", "", "grim_mode_zoom_plot_button_help_event", "<code class= source >	Selects the zoom cursor mode.</code>  ", "event", "NV/GR OPERATION:	The image zoom and offset are controlled by selecting	a box in the image When the box is created using the	left mouse button zoom and offset are changed so that	the contents of the box best fill the current graphics	window When the right button is used the contents of	the current graphics window are shrunken so as to best	fill the box In other words the left button zooms in	and the right button zooms out", "<code class= source > 	Written by:	Spitale, 7/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/hide_points.html", "hide_points.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "hide_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/hide_points.html#hide_points", "hide_points", 'routine in <a href="obj/tools/composite/hide_points.html">hide_points.pro</a>', "hide_points.pro", "", "hide_points", "<code class= source >	Hides points with respect to given object and observer.</code>  ", "rm<code class= source >If set, points are flagged for being in front of or behind</code> <code class= source >		the globe, rather then just behind it.</code>  limb<code class= source >If set, hide wrt to limb, where applicable.  Assumes points lie</code> <code class= source >		on the surface of the body.</code>  bx<code class= source >	Array (nt) of any subclass of BODY.</code>  view_pts<code class= source >Columns vector giving the BODY-frame position of the viewer.</code>  hide_pts<code class= source >Array (nv) of BODY-frame vectors giving the points to hide.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	Subscripts of the points in p that are hidden by the object.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_chisq.html", "icv_chisq.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_chisq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_chisq.html#icv_chisq", "icv_chisq", 'routine in <a href="obj/tools/icv/icv_chisq.html">icv_chisq.pro</a>', "icv_chisq.pro", "", "icv_chisq", "<code class= source >	Computes chi-squared value for given curve fit parameters.</code>  ", "norm<code class= source >	If set, the returned value is normalized by dividing</code> <code class= source >			it by the number of degrees of freedom.</code>  dxy<code class= source >	Array (2) giving x- and y-offset solution.</code>  dtheta<code class= source >	Scalar giving theta-offset solution.</code>  fix<code class= source >	Array specifying which parameters to fix as</code> <code class= source >			[dx,dy,dtheta].</code>  cos_alpha<code class= source >Array (n_points) of direction cosines computed by</code> <code class= source >			icv_compute_directions.</code>  sin_alpha<code class= source >Array (n_points) of direction sines computed by</code> <code class= source >			icv_compute_directions.</code>  scan_offsets<code class= source >Array (n_points) containing offset of best correlation</code> <code class= source >			at each point on the curve.  Produced by icv_scan_strip.</code>  scan_pts<code class= source >Array (2, n_points) of image coordinates corresponding</code> <code class= source >			to each scan offset.</code>  axis<code class= source >	Array (2) giving image coordinates of rotation axis</code> <code class= source >			in the case of a 3-parameter fit.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 6/1998</code>  <code class= source >	The chi-squared value is returned.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_coeff.html", "icv_coeff.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_coeff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_coeff.html#icv_coeff", "icv_coeff", 'routine in <a href="obj/tools/icv/icv_coeff.html">icv_coeff.pro</a>', "icv_coeff.pro", "", "icv_coeff", "<code class= source >	Computes coefficients for the 2- or 3-parameter linear least-square fit.</code>  <code class= source >	Since the fit has been linearized, it can be written as a matrix</code> <code class= source >	equation:</code> <code class= source >				Mx = b,</code> <code class= source >	where x is the 3-element column vector [dx, dy, dtheta] of the</code> <code class= source >	independent variables. 	This routine computes the matrix M and the</code> <code class= source >	vector b.  Once these are known, mbfit can be used to solve the</code> <code class= source >	linear system.  Moreover, since the fit is linear, a simultaneous</code> <code class= source >	fit can be performed by simply adding together any number of</code> <code class= source >	coefficient matrices and vectors, which can also be done using</code> <code class= source >	mbfit.</code>  <code class= source >	The fit associated with these coefficients has been linearized</code> <code class= source >	and is only valid for small corrections.  For larger corrections,</code> <code class= source >	this procedure can be iterated.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ", "sigma<code class= source >Uncertainty in each scan_offset.  Defaults to 1.</code>  M<code class= source >3x3 matrix of coefficients for the linear fit.</code>  b<code class= source >3-element column vector rhs of the linear fit.</code>  _cos_alpha<code class= source >Array (n_points) of direction cosines computed by</code> <code class= source >			icv_compute_directions.</code>  _sin_alpha<code class= source >Array (n_points) of direction sines computed by</code> <code class= source >			icv_compute_directions.</code>  scan_offsets<code class= source >Array (n_points) containing offset of best correlation</code> <code class= source >			at each point on the curve.  Produced by icv_scan_strip.</code>  scan_pts<code class= source >Array (2, n_points) of image coordinates corresponding</code> <code class= source >			to each scan offset.</code>  axis<code class= source >	Array (2) giving image coordinates of rotation axis</code> <code class= source >			in the case of a 3-parameter fit.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_compute_directions.html", "icv_compute_directions.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_compute_directions.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_compute_directions.html#icv_compute_directions", "icv_compute_directions", 'routine in <a href="obj/tools/icv/icv_compute_directions.html">icv_compute_directions.pro</a>', "icv_compute_directions.pro", "", "icv_compute_directions", "<code class= source >	Computes the normal to a specified curve at every point.</code>  <code class= source >	It is assumed that the curve is closed; if this is not the case, then</code> <code class= source >	the results will not be meaningful at the endpoints of the curve.</code>  <code class= source >	At each point on the specified curve, the two nearest neighbors are</code> <code class= source >	used to compute the components of the normal.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "centercos_alphasin_alphacurve_pts<code class= source >Array (2, n_points) of image points making up the curve.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_convert_scan_offsets.html", "icv_convert_scan_offsets.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_convert_scan_offsets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_convert_scan_offsets.html#icv_convert_scan_offsets", "icv_convert_scan_offsets", 'routine in <a href="obj/tools/icv/icv_convert_scan_offsets.html">icv_convert_scan_offsets.pro</a>', "icv_convert_scan_offsets.pro", "", "icv_convert_scan_offsets", "<code class= source >	Converts offsets produced by icv_scan_strip to image coordinates.</code>  ", "curve_pts<code class= source >Array (2, n_points) of image points making up the curve.</code>  scan_offsets<code class= source >Array (n_points) containing offset of best correlation</code> <code class= source >			at each point on the curve.  Produced by icv_scan_strip.</code>  cos_alpha<code class= source >Array (n_points) of direction cosines computed by</code> <code class= source >			icv_compute_directions.</code>  sin_alpha<code class= source >Array (n_points) of direction sines computed by</code> <code class= source >			icv_compute_directions.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array (2, n_points) of image coordinates corresponding to each scan</code> <code class= source >	offset.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_invert_scan_offsets.html", "icv_invert_scan_offsets.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_invert_scan_offsets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_invert_scan_offsets.html#icv_invert_scan_offsets", "icv_invert_scan_offsets", 'routine in <a href="obj/tools/icv/icv_invert_scan_offsets.html">icv_invert_scan_offsets.pro</a>', "icv_invert_scan_offsets.pro", "", "icv_invert_scan_offsets", "<code class= source >	Uses scan image coordinates to produce scan offsets and angles.  This</code> <code class= source >	routine is the reverse of icv_convert_scan_offsets.</code>  ", "curve_pts<code class= source >Array (2, n_points) of image points making up the curve.</code>  scan_pts<code class= source >Array (2, n_points) of image coordinates corresponding to each scan</code> <code class= source >			offset.</code>  cos_alpha<code class= source >Array (n_points) of direction cosines.</code>  sin_alpha<code class= source >Array (n_points) of direction sines.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array (2, n_points) of image coordinates corresponding to each scan</code> <code class= source >	offset.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_reset_scan_precision.html", "icv_reset_scan_precision.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_reset_scan_precision.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_reset_scan_precision.html#icv_reset_scan_precision", "icv_reset_scan_precision", 'routine in <a href="obj/tools/icv/icv_reset_scan_precision.html">icv_reset_scan_precision.pro</a>', "icv_reset_scan_precision.pro", "", "icv_reset_scan_precision", "<code class= source >	Modifies the scan precision by rebinning the given image strip.</code>  <code class= source >	The strip and model are rebinned by the specified precision factor</code> <code class= source >	using cubic interpolation.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "strip<code class= source >	Image strip to modify.</code>  model<code class= source >	Corresponding edge models.</code>  szero<code class= source >	Zero-offset position in the strip.</code>  mzero<code class= source >	Zero-offset position in the model.</code>  precision<code class= source >New precision in inverse pixels.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip.html", "icv_scan_strip.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip.html#icv_scan_strip", "icv_scan_strip", 'routine in <a href="obj/tools/icv/icv_scan_strip.html">icv_scan_strip.pro</a>', "icv_scan_strip.pro", "", "icv_scan_strip", "<code class= source >	At each point along an image strip, determines the point at which</code> <code class= source >	some criterion is optimized, depending on an externally-supplied</code> <code class= source >	function.</code>  <code class= source >	This program is a wrapper for a number of functions that use various</code> <code class= source >	algorithms determined by the 'algorithm' keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ", "ccsigmaalgorithmargstrip<code class= source >Image strip (n_points,ns) to be scanned.  Output from</code> <code class= source >		icv_strip_curve ns must be even.</code>  model<code class= source >Model (n_points,nm) to correlate with strip at each point</code> <code class= source >		on the curve.  Must have nm &lt; ns.</code>  szero<code class= source >Zero-offset position in the strip.</code>  mzero<code class= source >Zero-offset position in the model.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Offset of best correlation at each point on the curve.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad.html", "icv_scan_strip_grad.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_grad.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad.html#icv_scan_strip_grad", "icv_scan_strip_grad", 'routine in <a href="obj/tools/icv/icv_scan_strip_grad.html">icv_scan_strip_grad.pro</a>', "icv_scan_strip_grad.pro", "", "icv_scan_strip_grad", "<code class= source >	At each point along an image strip, finds a sharp edge using the</code> <code class= source >	maximum-gradient method.</code>  ", "argcc<code class= source >Not used, hardwired to 0.9999999d.</code>  sigma<code class= source >Offset uncertainty for each point on the curve, computed as</code> <code class= source >		one half of the half-width of the gradient peak.</code>  norm<code class= source >If set, only the absolute value of the gradient is evaluated.</code>  strip<code class= source >Image strip (n_points,ns) to be scanned.  Output from</code> <code class= source >		icv_strip_curve ns must be even.</code>  model<code class= source >Not used.</code>  szero<code class= source >Zero-offset position in the strip.</code>  mzero<code class= source >Not used.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Offset of maximum gradient points at each point on the curve.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad_norm.html", "icv_scan_strip_grad_norm.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_grad_norm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_grad_norm.html#icv_scan_strip_grad_norm", "icv_scan_strip_grad_norm", 'routine in <a href="obj/tools/icv/icv_scan_strip_grad_norm.html">icv_scan_strip_grad_norm.pro</a>', "icv_scan_strip_grad_norm.pro", "", "icv_scan_strip_grad_norm", "<code class= source >	Calls icv_scan_strip_grad with /norm set.</code>  ", "argccsigmastrip<code class= source >Image strip (n_points,ns) to be scanned.  Output from</code> <code class= source >		icv_strip_curve ns must be even.</code>  model<code class= source >Not used.</code>  szero<code class= source >Zero-offset position in the strip.</code>  mzero<code class= source >Not used.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Offset of maximum gradient points at each point on the curve.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_half.html", "icv_scan_strip_half.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_half.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_half.html#icv_scan_strip_half", "icv_scan_strip_half", 'routine in <a href="obj/tools/icv/icv_scan_strip_half.html">icv_scan_strip_half.pro</a>', "icv_scan_strip_half.pro", "", "icv_scan_strip_half", "<code class= source >	At each point along an image strip, finds a sharp edge using the</code> <code class= source >	half-power method.</code>  ", "argccsigmacenterstrip<code class= source >Image strip (n_points,ns) to be scanned.  Output from</code> <code class= source >		icv_strip_curve ns must be even.</code>  model<code class= source >Not used.</code>  szero<code class= source >Zero-offset position in the strip.</code>  mzero<code class= source >Not used.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Offset of half-power points at each point on the curve.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_model.html", "icv_scan_strip_model.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_scan_strip_model.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_scan_strip_model.html#icv_scan_strip_model", "icv_scan_strip_model", 'routine in <a href="obj/tools/icv/icv_scan_strip_model.html">icv_scan_strip_model.pro</a>', "icv_scan_strip_model.pro", "", "icv_scan_strip_model", "<code class= source >	At each point along an image strip, determines the subpixel offset at</code> <code class= source >	which the correlation coefficient between a specified model and the</code> <code class= source >	image is maximum.</code>  <code class= source >	At every point on the curve, a correlation coefficient is computed</code> <code class= source >	for every offset at which the model completely overlays the strip.</code> <code class= source >	In other words, the model is swept across the strip.</code> <code class= source >	At each point, Lagrange interpolation is used on the three correlations</code> <code class= source >	surrounding the correlation peak to find the subpixel offset of maximum</code> <code class= source >	correlation.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ", "argccsigmacenterstrip<code class= source >Image strip (n_points,ns) to be scanned.  Output from</code> <code class= source >		icv_strip_curve ns must be even.</code>  model<code class= source >Model (n_points,nm) to correlate with strip at each point</code> <code class= source >		on the curve.  Must have nm &lt; ns.</code>  szero<code class= source >Zero-offset position in the strip.</code>  mzero<code class= source >Zero-offset position in the model.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Offset of best correlation at each point on the curve.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/icv/icv_strip_curve.html", "icv_strip_curve.pro", '.pro file in <a href="obj/tools/icv/dir-overview.html">obj/tools/icv/ directory</a>', "icv_strip_curve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/icv/icv_strip_curve.html#icv_strip_curve", "icv_strip_curve", 'routine in <a href="obj/tools/icv/icv_strip_curve.html">icv_strip_curve.pro</a>', "icv_strip_curve.pro", "", "icv_strip_curve", "<code class= source >	Using Lagrange interpolation, extracts an image strip of a specified</code> <code class= source >	width centered on the specified curve.</code>  ", "zerogrid_xgrid_ycd<code class= source >	Camera descriptor.</code>  image<code class= source >	Image from which to extract the strip.</code>  curve_pts<code class= source >Array (2, n_points) of image points making up the curve.</code>  width<code class= source >	Width of the strip in pixels.</code>  nD<code class= source >	Number of samples across the width of the strip.</code>  cos_alpha<code class= source >Array (n_points) of direction cosines computed by</code> <code class= source >			icv_compute_directions.</code>  sin_alpha<code class= source >Array (n_points) of direction sines computed by</code> <code class= source >			icv_compute_directions.</code>  ", "NV/LIB/TOOLS/ICV", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Image strip (n_points, nD).</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/illumination_fraction.html", "illumination_fraction.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "illumination_fraction.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/illumination_fraction.html#illumination_fraction", "illumination_fraction", 'routine in <a href="obj/tools/illumination_fraction.html">illumination_fraction.pro</a>', "illumination_fraction.pro", "", "illumination_fraction", "<code class= source >	Assuming the body gbx is a sphere, this routine computes the fraction of</code> <code class= source >	its disk that appears illuminated by the source ltd, as seen from the</code> <code class= source >	inertial position vectors v.</code>  ", "gbx<code class= source >Any subclass of GLOBE.</code>  ltd<code class= source >Any subclass of STAR representing the light source.</code>  v<code class= source >Array (nv,3) Inertial positions of viewer.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (nv) giving the illumination fraction for each gbx.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_ansa.html", "image_ansa.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_ansa.pro", "", "", "<code class= source >	Computes ring ansa true anomalies.</code>  ", "", "          -1", "<code class= source >       Written by:     Spitale</code>  ");
  

libdata[libdataItem++] = new Array("obj/tools/image_ansa_far.html", "image_ansa_far.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_ansa_far.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_ansa_far.html#image_ansa_far", "image_ansa_far", 'routine in <a href="obj/tools/image_ansa_far.html">image_ansa_far.pro</a>', "image_ansa_far.pro", "", "image_ansa_far", "<code class= source >	Computes ring ansa longitudes assuming observer is very far from the</code> <code class= source >	rings.</code>  ", "cd<code class= source >Camera descriptor.</code>  rd", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (2) of longitudes</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_azimuth.html", "image_azimuth.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_azimuth.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_azimuth.html#image_azimuth", "image_azimuth", 'routine in <a href="obj/tools/image_azimuth.html">image_azimuth.pro</a>', "image_azimuth.pro", "", "image_azimuth", "<code class= source >	Computes azimuth angle of projection of inertial vector v</code> <code class= source >	into the image plane.</code>  ", "cd<code class= source >Any subclass of GLOBE.</code>  v<code class= source >Inertial vector.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Image azimuth.  When the image is displayed with (0,0) at</code> <code class= source >	the top-left, the azimuth angle is measured counterclockwise from</code> <code class= source >	 up .</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_azimuth_pos.html", "image_azimuth_pos.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_azimuth_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_azimuth_pos.html#image_azimuth_pos", "image_azimuth_pos", 'routine in <a href="obj/tools/image_azimuth_pos.html">image_azimuth_pos.pro</a>', "image_azimuth_pos.pro", "", "image_azimuth_pos", "<code class= source >	Computes azimuth angle of projection of inertial position vector v</code> <code class= source >	into the image plane.</code>  ", "cd<code class= source >Any subclass of GLOBE.</code>  v<code class= source >Inertial position vector.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Image azimuth.  When the image is displayed with (0,0) at</code> <code class= source >	the top-left, the azimuth angle is measured counterclockwise from</code> <code class= source >	 up .</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_celestial_northangle.html", "image_celestial_northangle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_celestial_northangle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_celestial_northangle.html#image_celestial_northangle", "image_celestial_northangle", 'routine in <a href="obj/tools/image_celestial_northangle.html">image_celestial_northangle.pro</a>', "image_celestial_northangle.pro", "", "image_celestial_northangle", "<code class= source >	Computes the image azimuth (see image_azimuth.pro) of celestial north.</code>  ", "orientcd<code class= source >Camera descriptor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Angle in radians.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_interp_cam.html", "image_interp_cam.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_interp_cam.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_interp_cam.html#image_interp_cam", "image_interp_cam", 'routine in <a href="obj/tools/image_interp_cam.html">image_interp_cam.pro</a>', "image_interp_cam.pro", "", "image_interp_cam", "<code class= source >       Extracts a region from an image using the desired interpolation,</code> <code class= source >	accouting for the camera point-spread function is applicable.</code>  ", "cdvalidkinterpkmaxmaskzmaskimage<code class= source >Image array.</code>  grid_x<code class= source >The grid of x positions for interpolation</code>  grid_y<code class= source >The grid of y positions for interpolation</code>  args<code class= source >Arguments to pass to the interpolation function.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array of interpolated points at the (grid_x, grid_y) points.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_northangle.html", "image_northangle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_northangle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_northangle.html#image_northangle", "image_northangle", 'routine in <a href="obj/tools/image_northangle.html">image_northangle.pro</a>', "image_northangle.pro", "", "image_northangle", "<code class= source >	Computes the image azimuth (see image_azimuth.pro) of the north</code> <code class= source >	direction on the surface of the given body at the specified pixel</code> <code class= source >	location p.</code>  ", "validcd<code class= source >Camera descriptor.</code>  gbx<code class= source >Any subclass of GLOBE.</code>  p<code class= source >Array (2) giving the image point.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Angle in radians.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_origin.html", "image_origin.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_origin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_origin.html#image_origin", "image_origin", 'routine in <a href="obj/tools/composite/image_origin.html">image_origin.pro</a>', "image_origin.pro", "", "image_origin", "<code class= source >	Returns the origin of a map or camera image.</code>  ", "cd", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	2-element array giving the origin in the x and y directions.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/image_shift.html", "image_shift.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "image_shift.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/image_shift.html#image_shift", "image_shift", 'routine in <a href="obj/tools/image_shift.html">image_shift.pro</a>', "image_shift.pro", "", "image_shift", "<code class= source >	Shifts an image by a specified (non-integer) amount using</code> <code class= source >	interpolation.  If applicable, the camera pont-spread function</code> <code class= source >	is accounted for in the interpolation.</code>  ", "cdimage<code class= source >2-D array giving the image.</code>  dx<code class= source >Offset in the x direction.</code>  dy<code class= source >Offset in the y direction.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Shifted image.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_size.html", "image_size.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_size.html#image_size", "image_size", 'routine in <a href="obj/tools/composite/image_size.html">image_size.pro</a>', "image_size.pro", "", "image_size", "<code class= source >	Returns the size of a map or camera image.</code>  ", "cd", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	2-element array giving the size in the x and y directions.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_body.html", "image_to_body.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_body.html#image_to_body", "image_to_body", 'routine in <a href="obj/tools/composite/image_to_body.html">image_to_body.pro</a>', "image_to_body.pro", "", "image_to_body", "<code class= source >       Transforms points in image coordinates to body coordinates on the</code> <code class= source >	object.</code>  ", "hitbackallcd<code class= source >      Array of nt camera or map descriptor.</code>  bx<code class= source >      Array of nt body descriptor (subclass of GLOBE or DISK).</code>  p<code class= source >      Array (2 x nv x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of body-frame vectors.  Zero vectors are returned if a</code> <code class= source >	body point cannot be computed (e.g., the ray misses the planet).</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_disk.html", "image_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_disk.html#image_to_disk", "image_to_disk", 'routine in <a href="obj/tools/composite/image_to_disk.html">image_to_disk.pro</a>', "image_to_disk.pro", "", "image_to_disk", "<code class= source >       Transforms points in image coordinates to disk coordinates</code>  ", "hitvalidbody_ptscd<code class= source >Array of nt camera or map descriptors.</code>  dkx<code class= source >Array of nt object descriptors (subclass of DISK).</code>  p<code class= source >Array (2 x nv x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of disk positions.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_globe.html", "image_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_globe.html#image_to_globe", "image_to_globe", 'routine in <a href="obj/tools/composite/image_to_globe.html">image_to_globe.pro</a>', "image_to_globe.pro", "", "image_to_globe", "<code class= source >       Transforms points in image coordinates to body globe coordinates</code>  ", "body_ptsdiscriminantvalidcd<code class= source >      Array of nt camera or map descriptors.</code>  gbx<code class= source >     Array of nt object descriptors (of type GLOBE).</code>  p<code class= source >       Array (2 x nv x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of globe positions.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_inertial.html", "image_to_inertial.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_inertial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_inertial.html#image_to_inertial", "image_to_inertial", 'routine in <a href="obj/tools/composite/image_to_inertial.html">image_to_inertial.pro</a>', "image_to_inertial.pro", "", "image_to_inertial", "<code class= source >       Transforms points in image coordinates to unit vectors with</code> <code class= source >	inertial coordinates.</code>  ", "cd<code class= source >Array of nt camera descriptors.</code>  p<code class= source >Array (2 x nv x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of of inertial unit vectors.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_map.html", "image_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_map.html#image_to_map", "image_to_map", 'routine in <a href="obj/tools/composite/image_to_map.html">image_to_map.pro</a>', "image_to_map.pro", "", "image_to_map", "<code class= source >       Transforms points in image coordinates to map coordinates.</code>  ", "bx<code class= source >If md is not a map descriptor, bx gives a subclass of BODY</code> <code class= source >		needed for transforming surface to map coordinates.</code>  valid<code class= source >Indices of valid output points.</code>  body_pts<code class= source >Body coordinates of output points.</code>  md<code class= source >Array of nt map or camera descriptors.</code>  p<code class= source >Array (2 x nv x nt) of image points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of map points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_orbit.html", "image_to_orbit.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_orbit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_orbit.html#image_to_orbit", "image_to_orbit", 'routine in <a href="obj/tools/composite/image_to_orbit.html">image_to_orbit.pro</a>', "image_to_orbit.pro", "", "image_to_orbit", "<code class= source >	Computes orbital elements corresponding to image points, assuming</code> <code class= source >	a circular orbit.</code>  ", "GG_cd<code class= source >Array of nt camera or map descriptors.</code>  _gbx<code class= source >Array of nt globe descriptor describing the primary body.</code>  dkx0image_pts<code class= source >Array (1,3,nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	Array of nt disk descriptors reresenting the computed orbits.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_radec.html", "image_to_radec.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_radec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_radec.html#image_to_radec", "image_to_radec", 'routine in <a href="obj/tools/composite/image_to_radec.html">image_to_radec.pro</a>', "image_to_radec.pro", "", "image_to_radec", "<code class= source >       Transforms points in image coordinates to polar ra/dec coords</code> <code class= source >	w.r.t the inertial frame.</code>  ", "body_ptscd<code class= source >Array of nt camera descriptors.</code>  p<code class= source >Array (2 x nv x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of radec vectors in the cd BODY frame.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/image_to_surface.html", "image_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "image_to_surface.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/image_to_surface.html#image_to_surface", "image_to_surface", 'routine in <a href="obj/tools/composite/image_to_surface.html">image_to_surface.pro</a>', "image_to_surface.pro", "", "image_to_surface", "<code class= source >       Transforms points in image coordinates to surface coordinates.</code>  ", "body_ptsdiscriminanthitvalidcd<code class= source >     Array of nt camera or map descriptor</code>  bx<code class= source >     Array of nt object descriptors (subclass of BODY).</code>  p<code class= source >      Array (2 x nv x nt) of image points.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of surface points.  In the case of a camera descriptor, ray</code> <code class= source >	tracing is used.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/impact_param.html", "impact_param.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "impact_param.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/impact_param.html#impact_param", "impact_param", 'routine in <a href="obj/tools/impact_param.html">impact_param.pro</a>', "impact_param.pro", "", "impact_param", "<code class= source >	Computes the impact parameter of a vector originating at the</code> <code class= source >	given camera, relative to the given planet object.</code>  ", "pcd<code class= source >Camera descriptor.</code>  pd<code class= source >Planet descriptor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Shifted image.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/in_image.html", "in_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "in_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/in_image.html#in_image", "in_image", 'routine in <a href="obj/tools/in_image.html">in_image.pro</a>', "in_image.pro", "", "in_image", "<code class= source >	Determines which input points lie within an image described by the</code> <code class= source >	given camera descriptor.</code>  ", "xminxmaxyminymaxslopcornerscd<code class= source >Camera descriptor.</code>  _image_pts", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Subscripts of points that lie in the image.  -1 if there are none.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk.html", "inertial_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk.html#inertial_to_disk", "inertial_to_disk", 'routine in <a href="obj/tools/composite/inertial_to_disk.html">inertial_to_disk.pro</a>', "inertial_to_disk.pro", "", "inertial_to_disk", "<code class= source >       Transforms vectors in inertial coordinates to disk coordinates.</code>  ", "dkx<code class= source >Array of nt descriptors, subclass of DISK.</code>  v<code class= source >Array (nv x 3 x nt) of inertial vectors.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale, 2/2004</code>  <code class= source >       Array (nv x 3 x nt) of disk points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk_pos.html", "inertial_to_disk_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_disk_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_disk_pos.html#inertial_to_disk_pos", "inertial_to_disk_pos", 'routine in <a href="obj/tools/composite/inertial_to_disk_pos.html">inertial_to_disk_pos.pro</a>', "inertial_to_disk_pos.pro", "", "inertial_to_disk_pos", "<code class= source >       Transforms position vectors in inertial coordinates to disk</code> <code class= source >	coordinates.</code>  ", "dkx<code class= source >Array of nt descritors, subclass of DISK.</code>  v<code class= source >Array (nv x 3 x nt) of inertial vectors</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale, 3/2004</code>  <code class= source >       Array (nv x 3 x nt) of disk points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe.html", "inertial_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe.html#inertial_to_globe", "inertial_to_globe", 'routine in <a href="obj/tools/composite/inertial_to_globe.html">inertial_to_globe.pro</a>', "inertial_to_globe.pro", "", "inertial_to_globe", "<code class= source >       Transforms vectors in inertial coordinates to globe coordinates.</code>  ", "gbx<code class= source >Array of nt descriptors, subclass of globe.</code>  v<code class= source >Array (nv x 3 x nt) of inertial vectors.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale, 9/2012</code>  <code class= source >       Array (nv x 3 x nt) of globe points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe_pos.html", "inertial_to_globe_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_globe_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_globe_pos.html#inertial_to_globe_pos", "inertial_to_globe_pos", 'routine in <a href="obj/tools/composite/inertial_to_globe_pos.html">inertial_to_globe_pos.pro</a>', "inertial_to_globe_pos.pro", "", "inertial_to_globe_pos", "<code class= source >       Transforms position vectors in inertial coordinates to globe</code> <code class= source >	coordinates.</code>  ", "gbx<code class= source >Array of nt descritors, subclass of globe.</code>  v<code class= source >Array (nv x 3 x nt) of inertial vectors</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale, 9/2012</code>  <code class= source >       Array (nv x 3 x nt) of globe points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image.html", "inertial_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image.html#inertial_to_image", "inertial_to_image", 'routine in <a href="obj/tools/composite/inertial_to_image.html">inertial_to_image.pro</a>', "inertial_to_image.pro", "", "inertial_to_image", "<code class= source >       Transforms vectors in inertial coordinates to image coordinates</code>  ", "cd<code class= source >Array of nt camera descriptors.</code>  v<code class= source >Array (nv x 3 x nt) of inertial vectors</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array (2 x nv x nt) of image points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image_pos.html", "inertial_to_image_pos.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "inertial_to_image_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/inertial_to_image_pos.html#inertial_to_image_pos", "inertial_to_image_pos", 'routine in <a href="obj/tools/composite/inertial_to_image_pos.html">inertial_to_image_pos.pro</a>', "inertial_to_image_pos.pro", "", "inertial_to_image_pos", "<code class= source >       Transforms vectors in inertial coordinates to image coordinates</code>  ", "cd<code class= source >Array of nt camera descriptors.</code>  v<code class= source >Array (nv x 3 x nt) of inertial vectors</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array (2 x nv x nt) of image points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_chisq.html", "ipt_chisq.pro", '.pro file in <a href="obj/tools/ipt/dir-overview.html">obj/tools/ipt/ directory</a>', "ipt_chisq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_chisq.html#ipt_chisq", "ipt_chisq", 'routine in <a href="obj/tools/ipt/ipt_chisq.html">ipt_chisq.pro</a>', "ipt_chisq.pro", "", "ipt_chisq", "<code class= source >	Computes chi-squared value for given point fit parameters.</code>  ", "norm<code class= source >	If set, the returned value is normalized by dividing</code> <code class= source >			it by the number of degrees of freedom.</code>  dxy<code class= source >	Array (2) giving x- and y-offset solution.</code>  dtheta<code class= source >	Scalar giving theta-offset solution.</code>  fix<code class= source >	Array specifying which parameters to fix as</code> <code class= source >			[dx,dy,dtheta].</code>  pts_dx<code class= source >        Array (n_points) containing offset of actual</code> <code class= source >                       point from predicted point in x.</code>  pts_dy<code class= source >        Array (n_points) containing offset of actual</code> <code class= source >                       point from predicted point in y.</code>  pts<code class= source >           Array (2,n_points) of image coordinates corresponding</code> <code class= source >                       to actual point.</code>  axis<code class= source >	Array (2) giving image coordinates of rotation axis</code> <code class= source >			in the case of a 3-parameter fit.</code>  ", "UTIL/NV/LIB/TOOLS/IPT", "<code class= source > 	Written by:	Haemmerle, 12/1998</code>  <code class= source >	The chi-squared value is returned.</code> <code class= source > STATUS:</code> <code class= source >	Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_coeff.html", "ipt_coeff.pro", '.pro file in <a href="obj/tools/ipt/dir-overview.html">obj/tools/ipt/ directory</a>', "ipt_coeff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ipt/ipt_coeff.html#ipt_coeff", "ipt_coeff", 'routine in <a href="obj/tools/ipt/ipt_coeff.html">ipt_coeff.pro</a>', "ipt_coeff.pro", "", "ipt_coeff", "<code class= source >	Computes coefficients for the 2- or 3-parameter linear least-square fit.</code>  <code class= source >	Since the fit has been linearized, it can be written as a matrix</code> <code class= source >	equation:</code> <code class= source >				Mx = b,</code> <code class= source >	where x is the 3-element column vector [dx, dy, dtheta] of the</code> <code class= source >	independent variables. 	This routine computes the matrix M and the</code> <code class= source >	vector b.  Once these are known, mbfit can be used to solve the</code> <code class= source >	linear system.  Furthermore, since the fit is linear, a simultaneous</code> <code class= source >	fit can be performed by simply adding together any number of</code> <code class= source >	coefficient matrices and vectors, which can also be done using</code> <code class= source >	mbfit.</code>  <code class= source >	The fit associated with these coefficients has been linearized</code> <code class= source >	and is only valid for small corrections.  For larger corrections,</code> <code class= source >	this procedure can be iterated.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ", "M<code class= source >3x3 matrix of coefficients for the linear fit.</code>  b<code class= source >3-element column vector rhs of the linear fit.</code>  sigma<code class= source >Uncertainty in each point position.</code>  pts_x<code class= source >        Value containing offset of actual</code> <code class= source >			point from predicted point in x.</code>  pts_y<code class= source >         Value containing offset of actual</code> <code class= source >                       point from predicted point in y.</code>  pts<code class= source >        Array (2) of image coordinates corresponding</code> <code class= source >			to actual point.</code>  axis<code class= source >	Array (2) giving image coordinates of rotation axis</code> <code class= source >			in the case of a 3-parameter fit.</code>  ", "UTIL/NV/LIB/TOOLS/IPT", "<code class= source > 	Written by:	Haemmerle, 5/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/keyval_struct__define.html", "keyval_struct__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "keyval_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dat/keyval_struct__define.html#keyval_struct__define", "keyval_struct__define", 'routine in <a href="obj/dat/keyval_struct__define.html">keyval_struct__define.pro</a>', "keyval_struct__define.pro", "", "keyval_struct__define", "<code class= source >	Structure defining a keyword/value pair.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/ltcorr.html", "ltcorr.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ltcorr.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ltcorr.html#ltcorr", "ltcorr", 'routine in <a href="obj/tools/ltcorr.html">ltcorr.pro</a>', "ltcorr.pro", "", "ltcorr", "<code class= source >	Performs a light-travel-time correction on objects for which the</code> <code class= source >	correction has not already been performed.</code>  ", "cepsiloniterateinvertobs_bx<code class= source > Any subclass of BODY describing the observer.</code>  _targ_bx<code class= source >Array(nt) of any subclass of BODY describing the targets.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_assign.html", "map_assign.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_assign.html#map_assign", "map_assign", 'routine in <a href="obj/map/map_assign.html">map_assign.pro</a>', "map_assign.pro", "", "map_assign", "<code class= source >	Replaces fields in a MAP object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@map__keywords_tree.include", "NV/OBJ/MAP", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_center.html", "map_center.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_center.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_center.html#map_center", "map_center", 'routine in <a href="obj/map/map_center.html">map_center.pro</a>', "map_center.pro", "", "map_center", "<code class= source >	Returns the center for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nt) of centers associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_centric_to_graphic.html", "map_centric_to_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_centric_to_graphic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_centric_to_graphic.html#map_centric_to_graphic", "map_centric_to_graphic", 'routine in <a href="obj/map/map_centric_to_graphic.html">map_centric_to_graphic.pro</a>', "map_centric_to_graphic.pro", "", "map_centric_to_graphic", "<code class= source >	Converts latitudes from the planetocentric to the planetographic</code> <code class= source >	convention.</code>  ", "md<code class= source >Array (nt) of map descriptors.</code>  map_pts0", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map points in which the latitudes are</code> <code class= source >	planetographic.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_create_descriptors.html", "map_create_descriptors.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_create_descriptors.html#map_create_descriptors", "map_create_descriptors", 'routine in <a href="obj/map/map_create_descriptors.html">map_create_descriptors.pro</a>', "map_create_descriptors.pro", "", "map_create_descriptors", "<code class= source >	Init method for the MAP class.</code>  ", "crdmdn<code class= source >Number of descriptors to create.</code>  @map__keywords_tree.include", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Newly created or or freshly initialized disk descriptors, depending</code> <code class= source >	on the presence of the dkd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_east_to_west.html", "map_east_to_west.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_east_to_west.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_east_to_west.html#map_east_to_west", "map_east_to_west", 'routine in <a href="obj/map/map_east_to_west.html">map_east_to_west.pro</a>', "map_east_to_west.pro", "", "map_east_to_west", "<code class= source >	Converts longitudes from the eastward to the westward</code> <code class= source >	convention.</code>  ", "md<code class= source >Array (nt) of map descriptors.</code>  map_pts0", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/201y</code>  <code class= source >	Array (2,nv,nt) of map points in which the longitudes are</code> <code class= source >	westward.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_data.html", "map_fn_data.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_data.html#map_fn_data", "map_fn_data", 'routine in <a href="obj/map/map_fn_data.html">map_fn_data.pro</a>', "map_fn_data.pro", "", "map_fn_data", "<code class= source >	Returns the function data for a map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Adapted by:	Spitale, 7/2016; adapted from map_fn_data_p</code>  <code class= source >	Function data associated with the given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_image_to_map.html", "map_fn_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_image_to_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_image_to_map.html#map_fn_image_to_map", "map_fn_image_to_map", 'routine in <a href="obj/map/map_fn_image_to_map.html">map_fn_image_to_map.pro</a>', "map_fn_image_to_map.pro", "", "map_fn_image_to_map", "<code class= source >	Returns the name of the image-&gt;map function for each given map</code> <code class= source >	descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of image-&gt;map function names associated with each given</code> <code class= source >	map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_map_to_image.html", "map_fn_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_map_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_map_to_image.html#map_fn_map_to_image", "map_fn_map_to_image", 'routine in <a href="obj/map/map_fn_map_to_image.html">map_fn_map_to_image.pro</a>', "map_fn_map_to_image.pro", "", "map_fn_map_to_image", "<code class= source >	Returns the name of the map-&gt;image function for each given map</code> <code class= source >	descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of map-&gt;image function names associated with each given</code> <code class= source >	map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_fn_valid.html", "map_fn_valid.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_fn_valid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_fn_valid.html#map_fn_valid", "map_fn_valid", 'routine in <a href="obj/map/map_fn_valid.html">map_fn_valid.pro</a>', "map_fn_valid.pro", "", "map_fn_valid", "<code class= source >	Returns the name of the map-&gt;image validation function for each given</code> <code class= source >	map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of map-&gt;image validation function names associated with each given</code> <code class= source >	map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_get_grid_points.html", "map_get_grid_points.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_get_grid_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_get_grid_points.html#map_get_grid_points", "map_get_grid_points", 'routine in <a href="obj/map/map_get_grid_points.html">map_get_grid_points.pro</a>', "map_get_grid_points.pro", "", "map_get_grid_points", "<code class= source >	Generates a lat/lon grid of points.</code>  ", "lat<code class= source >Array giving the latitudes for each constant latitude line.</code>  lon<code class= source >Array giving the longitudes for each constant longitude line.</code>  nt<code class= source >Number of grids to produce.</code>  scan_lat<code class= source >Latitudes to scan for each constant longitude line.</code>  scan_lon<code class= source >Longitudes to scan for each constant latitude line.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (2,np,nt) of map coordinate points where np is the number of</code> <code class= source >	scan_lats times the number of scan_lons.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_get_ranges.html", "map_get_ranges.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_get_ranges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_get_ranges.html#map_get_ranges", "map_get_ranges", 'routine in <a href="obj/map/map_get_ranges.html">map_get_ranges.pro</a>', "map_get_ranges.pro", "", "map_get_ranges", "<code class= source >	Returns ranges of valid coordinates for the given MAP object.</code>  ", "md<code class= source > MAP descriptor.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2 x 2) giving the ranges in latitude, longitude.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_graphic.html", "map_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_graphic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_graphic.html#map_graphic", "map_graphic", 'routine in <a href="obj/map/map_graphic.html">map_graphic.pro</a>', "map_graphic.pro", "", "map_graphic", "<code class= source >	Returns the graphic flag for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of graphic flags associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_graphic_to_centric.html", "map_graphic_to_centric.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_graphic_to_centric.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_graphic_to_centric.html#map_graphic_to_centric", "map_graphic_to_centric", 'routine in <a href="obj/map/map_graphic_to_centric.html">map_graphic_to_centric.pro</a>', "map_graphic_to_centric.pro", "", "map_graphic_to_centric", "<code class= source >	Converts latitudes from the planetographic to the planetocentric</code> <code class= source >	convention.</code>  ", "md<code class= source >Array (nt) of map descriptors.</code>  map_pts0", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map points in which the latitudes are</code> <code class= source >	planetocentric.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map.html", "map_image_to_map.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map.html#map_image_to_map", "map_image_to_map", 'routine in <a href="obj/map/map_image_to_map.html">map_image_to_map.pro</a>', "map_image_to_map.pro", "", "map_image_to_map", "<code class= source >	Transforms the given image points to map coordinate points.</code>  ", "validmd_image_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_equatorial_ring.html", "map_image_to_map_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_equatorial_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_equatorial_ring.html#map_image_to_map_equatorial_ring", "map_image_to_map_equatorial_ring", 'routine in <a href="obj/map/map_image_to_map_equatorial_ring.html">map_image_to_map_equatorial_ring.pro</a>', "map_image_to_map_equatorial_ring.pro", "", "map_image_to_map_equatorial_ring", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using a rectangular projection.</code>  ", "validmdimage_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		lat = (y - origin[1])/a[0] + center[0]</code> <code class= source >		lon = (x - origin[0])/a[1] + center[1]</code> <code class= source >	where the latitude equation is solved iteratively.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_mercator.html", "map_image_to_map_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_mercator.pro", "", "", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using a mercator projection.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic.html", "map_image_to_map_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_orthographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic.html#map_image_to_map_orthographic", "map_image_to_map_orthographic", 'routine in <a href="obj/map/map_image_to_map_orthographic.html">map_image_to_map_orthographic.pro</a>', "map_image_to_map_orthographic.pro", "", "map_image_to_map_orthographic", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using an orthographic projection.</code>  ", "validmd_image_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in an orthographic</code> <code class= source >	projection.  This projection portrays a planet as seen from a</code> <code class= source >	great distance.  Scale is true only at the map center.  Areas</code> <code class= source >	are distorted, especially away from the map center.</code> <code class= source >	With:</code> <code class= source >	  R = min(size[0],size[1])/2 * scale,</code> <code class= source >	and:</code> <code class= source >	  rho = sqrt(x^2 + y^2),</code> <code class= source >	and:</code> <code class= source >	  c = asin(rho/R),</code> <code class= source >	the transformation is:</code> <code class= source >	  lat = asin( cos(c)*sin(center[0]) +</code> <code class= source >	                    y*sin(c)*cos(center[0])/rho ) / units[0]</code> <code class= source >	  lon = center[1] +</code> <code class= source >	          atan( x*sin(c)/(rho*cos(center[0])*cos(c) -</code> <code class= source >	                        y*sin(center[0])*sin(c)) ) + units[1]</code> <code class= source >	See [1], p. 150 for the mathematical derivation.</code> <code class= source >	[1] Snyder (1987)</code> <code class= source >	    Map projections -- A working manual</code> <code class= source >	    USGS professional paper 1395</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic_disk.html", "map_image_to_map_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_orthographic_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_orthographic_disk.html#map_image_to_map_orthographic_disk", "map_image_to_map_orthographic_disk", 'routine in <a href="obj/map/map_image_to_map_orthographic_disk.html">map_image_to_map_orthographic_disk.pro</a>', "map_image_to_map_orthographic_disk.pro", "", "map_image_to_map_orthographic_disk", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using an orthographic projection for a disk.</code>  ", "validmd_image_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in an orthographic disk</code> <code class= source >	projection.  This projection portrays a disk as seen from a</code> <code class= source >	great distance.  Scale is uniform, but it is only true if the</code> <code class= source >	projection is polar.  Likewise, areas are distorted for non-polar</code> <code class= source >	projections.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular.html", "map_image_to_map_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_rectangular.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular.html#map_image_to_map_rectangular", "map_image_to_map_rectangular", 'routine in <a href="obj/map/map_image_to_map_rectangular.html">map_image_to_map_rectangular.pro</a>', "map_image_to_map_rectangular.pro", "", "map_image_to_map_rectangular", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using a rectangular projection.</code>  ", "validmdimage_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		lat = (y - origin[1])/a[0] + center[0]</code> <code class= source >		lon = (x - origin[0])/a[1] + center[1]</code> <code class= source >	where the latitude equation is solved iteratively.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular_disk.html", "map_image_to_map_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_rectangular_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_rectangular_disk.html#map_image_to_map_rectangular_disk", "map_image_to_map_rectangular_disk", 'routine in <a href="obj/map/map_image_to_map_rectangular_disk.html">map_image_to_map_rectangular_disk.pro</a>', "map_image_to_map_rectangular_disk.pro", "", "map_image_to_map_rectangular_disk", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using a rectangular projection on a disk.</code>  ", "validmdimage_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		lat = (y - origin[1])/a[0] + center[0]</code> <code class= source >		lon = (x - origin[0])/a[1] + center[1]</code> <code class= source >	where the latitude equation is solved iteratively.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_ring.html", "map_image_to_map_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_image_to_map_ring.html#map_image_to_map_ring", "map_image_to_map_ring", 'routine in <a href="obj/map/map_image_to_map_ring.html">map_image_to_map_ring.pro</a>', "map_image_to_map_ring.pro", "", "map_image_to_map_ring", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using a rectangular projection.</code>  ", "validmdimage_pts<code class= source >Array (2,nv,nt) of map image points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		lat = (y - origin[1])/a[0] + center[0]</code> <code class= source >		lon = (x - origin[0])/a[1] + center[1]</code> <code class= source >	where the latitude equation is solved iteratively.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_image_to_map_stereographic.html", "map_image_to_map_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_image_to_map_stereographic.pro", "", "", "<code class= source >	Transforms the given image points to map coordinate points</code> <code class= source >	using an stereographic projection.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image.html", "map_map_to_image.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image.html#map_map_to_image", "map_map_to_image", 'routine in <a href="obj/map/map_map_to_image.html">map_map_to_image.pro</a>', "map_map_to_image.pro", "", "map_map_to_image", "<code class= source >	Transforms the given map points to map image points.</code>  ", "valid<code class= source >Indices of all input points that correspond to valid</code> <code class= source >		output image points.  If not set then all points are</code> <code class= source >		valid.</code>  nowrap<code class= source >If set, then points that lie outide the map will not be</code> <code class= source >		wrapped around to the other side.</code>  allmd_map_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (2,nv,nt) of map image points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_equatorial_ring.html", "map_map_to_image_equatorial_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_equatorial_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_equatorial_ring.html#map_map_to_image_equatorial_ring", "map_map_to_image_equatorial_ring", 'routine in <a href="obj/map/map_map_to_image_equatorial_ring.html">map_map_to_image_equatorial_ring.pro</a>', "map_map_to_image_equatorial_ring.pro", "", "map_map_to_image_equatorial_ring", "<code class= source >	Transforms the given map points to map image points using a</code> <code class= source >	rectangular projection.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map image points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		x = a[1] * (lon - center[1]) + origin[0]</code> <code class= source >		y = a[0] * (lat - center[0]) + origin[1]</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mercator.html", "map_map_to_image_mercator.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_mercator.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_mercator.html#map_map_to_image_mercator", "map_map_to_image_mercator", 'routine in <a href="obj/map/map_map_to_image_mercator.html">map_map_to_image_mercator.pro</a>', "map_map_to_image_mercator.pro", "", "map_map_to_image_mercator", "<code class= source >	Transforms the given map points to map image points using the</code> <code class= source >	mercator projection.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (2,nv,nt) of map coordinate points in a mercator projection.</code> <code class= source >	This projection results from projecting a sphere onto a cylinder</code> <code class= source >	that is tangent at the equator.  The scale is true along the equator</code> <code class= source >	only.  Areas are distorted, especially near the poles.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	and:</code> <code class= source >		e = sqrt(1 - (A/(B+C)/2)^2),</code> <code class= source >	where A, B, and C are the triaxial ellipsoid radii, the</code> <code class= source >	transformation is:</code> <code class= source >		x = a[1] * (lon - center[1]) + origin[0]</code> <code class= source >		y = a[0] * log( tan(pi/4 + lat/2) *</code> <code class= source >		  ( (1 - e*sin(lat))/(1 + e*sin(lat)) )^(e/2) ) + origin[1]</code> <code class= source >	See [1], p. 44 for the mathematical derivation.</code> <code class= source >	[1] Snyder (1987)</code> <code class= source >	    Map projections -- A working manual</code> <code class= source >	    USGS professional paper 1395</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic.html", "map_map_to_image_orthographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_orthographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic.html#map_map_to_image_orthographic", "map_map_to_image_orthographic", 'routine in <a href="obj/map/map_map_to_image_orthographic.html">map_map_to_image_orthographic.pro</a>', "map_map_to_image_orthographic.pro", "", "map_map_to_image_orthographic", "<code class= source >	Transforms the given map points to map image points using the</code> <code class= source >	orthographic projection.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (2,nv,nt) of map image points in an orthographic</code> <code class= source >	projection.  This projection portrays a planet as seen from a</code> <code class= source >	great distance.  Scale is true only at the map center.  Areas</code> <code class= source >	are distorted, especially away from the map center.</code> <code class= source >	With:</code> <code class= source >	  R = min(size[0],size[1])/2 * scale</code> <code class= source >	the transformation is:</code> <code class= source >	  x = R * cos(lat/units[0]) * sin(lon/units[1] 0 center[1]) + origin[0]</code> <code class= source >	  y = R *</code> <code class= source >	     ( cos(center[0])*sin(lat/units[0]) -</code> <code class= source >	        sin(center[0])*cos(lat/units[0])*cos(lon - center[1]) ) +</code> <code class= source >	                                                            origin[1]</code> <code class= source >	See [1], p. 149 for the mathematical derivation.</code> <code class= source >	[1] Snyder (1987)</code> <code class= source >	    Map projections -- A working manual</code> <code class= source >	    USGS professional paper 1395</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic_disk.html", "map_map_to_image_orthographic_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_orthographic_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_orthographic_disk.html#map_map_to_image_orthographic_disk", "map_map_to_image_orthographic_disk", 'routine in <a href="obj/map/map_map_to_image_orthographic_disk.html">map_map_to_image_orthographic_disk.pro</a>', "map_map_to_image_orthographic_disk.pro", "", "map_map_to_image_orthographic_disk", "<code class= source >	Transforms the given map points to map image points using the</code> <code class= source >	orthographic projection on a disk.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Array (2,nv,nt) of map image points in an orthographic disk</code> <code class= source >	projection.  This projection portrays a disk as seen from a</code> <code class= source >	great distance.  Scale is uniform, but it is only true if the</code> <code class= source >	projection is polar.  Likewise, areas are distorted for non-polar</code> <code class= source >	projections.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular.html", "map_map_to_image_rectangular.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_rectangular.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular.html#map_map_to_image_rectangular", "map_map_to_image_rectangular", 'routine in <a href="obj/map/map_map_to_image_rectangular.html">map_map_to_image_rectangular.pro</a>', "map_map_to_image_rectangular.pro", "", "map_map_to_image_rectangular", "<code class= source >	Transforms the given map points to map image points using a</code> <code class= source >	rectangular projection.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map image points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		x = a[1] * (lon - center[1]) + origin[0]</code> <code class= source >		y = a[0] * (lat - center[0]) + origin[1]</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular_disk.html", "map_map_to_image_rectangular_disk.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_rectangular_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_rectangular_disk.html#map_map_to_image_rectangular_disk", "map_map_to_image_rectangular_disk", 'routine in <a href="obj/map/map_map_to_image_rectangular_disk.html">map_map_to_image_rectangular_disk.pro</a>', "map_map_to_image_rectangular_disk.pro", "", "map_map_to_image_rectangular_disk", "<code class= source >	Transforms the given map points to map image points using a</code> <code class= source >	rectangular projection on a disk.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	Array (2,nv,nt) of map image points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		x = a[1] * (lon - center[1]) + origin[0]</code> <code class= source >		y = a[0] * (lat - center[0]) + origin[1]</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_ring.html", "map_map_to_image_ring.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_ring.html#map_map_to_image_ring", "map_map_to_image_ring", 'routine in <a href="obj/map/map_map_to_image_ring.html">map_map_to_image_ring.pro</a>', "map_map_to_image_ring.pro", "", "map_map_to_image_ring", "<code class= source >	Transforms the given map points to map image points using a</code> <code class= source >	rectangular projection.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map image points in a rectangular projection.</code> <code class= source >	In this projection, latitudes map linearly to the the y image</code> <code class= source >	direction, and longitudes map linearly to the x image direction.</code> <code class= source >	With:</code> <code class= source >		a = [size[1]/pi, size[0]/2pi] * scale * units,</code> <code class= source >	the transformation is:</code> <code class= source >		x = a[1] * (lon - center[1]) + origin[0]</code> <code class= source >		y = a[0] * (lat - center[0]) + origin[1]</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_map_to_image_stereographic.html", "map_map_to_image_stereographic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_map_to_image_stereographic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_map_to_image_stereographic.html#map_map_to_image_stereographic", "map_map_to_image_stereographic", 'routine in <a href="obj/map/map_map_to_image_stereographic.html">map_map_to_image_stereographic.pro</a>', "map_map_to_image_stereographic.pro", "", "map_map_to_image_stereographic", "<code class= source >	Transforms the given map points to map image points using the</code> <code class= source >	stereographic projection.</code>  ", "mdmap_pts<code class= source >Array (2,nv,nt) of map points.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nv,nt) of map image points in an stereographic</code> <code class= source >	projection.  This projection results from the projection through</code> <code class= source >	a sphere onto a plane, from a point on the surface of the sphere.</code> <code class= source >	Scale is true only at the map center.  Areas are distorted,</code> <code class= source >	especially away from the map center.</code> <code class= source >	With:</code> <code class= source >	  a = [size[0],size[1]]/4 * scale,</code> <code class= source >	and:</code> <code class= source >	  e = sqrt(1 - (A/(B+C)/2)^2),</code> <code class= source >	where A, B, and C are the triaxial ellipsoid radii, and:</code> <code class= source >	  lat0 = lat / units[0]</code> <code class= source >	  lon0 = lon / units[1]</code> <code class= source >	  m1 = cos(center[0]]) / sqrt(1 - e^2*sin(center[0])^2)</code> <code class= source >	  X = 2*atan(tan(pi/4 + lat/2) * $</code> <code class= source >	       ((1 - e*sin(lat0))/(1 + e*sin(lat0)))^(e/2)) - pi/2</code> <code class= source >	  X1 = 2*atan(tan(pi/4 + center[0]/2) *</code> <code class= source >	       ((1 - e*sin(center[0]))/(1 + e*sin(center[0])))^(e/2)) - pi/2d</code> <code class= source >	  A = 2*a*scale*m1 /</code> <code class= source >	   ( cos(X1)*(1 + sin(X1)*sin(X) + cos(X1)*cos(X)*cos(lon0 - center[1])) )</code> <code class= source >	the transformation is:</code> <code class= source >	  x = A * cos(X)*sin(lon0 - center[1]) + origin[0]</code> <code class= source >	  y = A * ( cos(X1)*sin(X) - sin(X1)*cos(X)*sin(lon0 - center[1]) ) +</code> <code class= source >	                                                              origin[1]</code> <code class= source >	See [1], p. 160 for the mathematical derivation.</code> <code class= source >	[1] Snyder (1987)</code> <code class= source >	    Map projections -- A working manual</code> <code class= source >	    USGS professional paper 1395</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_origin.html", "map_origin.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_origin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_origin.html#map_origin", "map_origin", 'routine in <a href="obj/map/map_origin.html">map_origin.pro</a>', "map_origin.pro", "", "map_origin", "<code class= source >	Returns the origin for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nt) of origins associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_pole.html", "map_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_pole.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_pole.html#map_pole", "map_pole", 'routine in <a href="obj/map/map_pole.html">map_pole.pro</a>', "map_pole.pro", "", "map_pole", "<code class= source >	Returns the pole for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/2016</code>  <code class= source >	Array (nt) of ominas_map_pole structs associated with each given map</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_projection.html", "map_projection.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_projection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_projection.html#map_projection", "map_projection", 'routine in <a href="obj/map/map_projection.html">map_projection.pro</a>', "map_projection.pro", "", "map_projection", "<code class= source >	Returns the projection name for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of projection names associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_query.html", "map_query.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_query.html#map_query", "map_query", 'routine in <a href="obj/map/map_query.html">map_query.pro</a>', "map_query.pro", "", "map_query", "<code class= source >	Returns the fields associated with a MAP object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@map__keywords_tree.include", "NV/OBJ/MAP", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_radii.html", "map_radii.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_radii.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_radii.html#map_radii", "map_radii", 'routine in <a href="obj/map/map_radii.html">map_radii.pro</a>', "map_radii.pro", "", "map_radii", "<code class= source >	Returns the rference radii for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (3,nt) of refernce radii associated with each given map</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_range.html", "map_range.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_range.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_range.html#map_range", "map_range", 'routine in <a href="obj/map/map_range.html">map_range.pro</a>', "map_range.pro", "", "map_range", "<code class= source >	Returns the range for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 7/2016</code>  <code class= source >	Array (2,2,nt) of ranges associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_replicate.html", "map_replicate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_replicate.html#map_replicate", "map_replicate", 'routine in <a href="obj/map/map_replicate.html">map_replicate.pro</a>', "map_replicate.pro", "", "map_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "md<code class= source > MAP descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_rotate.html", "map_rotate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_rotate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_rotate.html#map_rotate", "map_rotate", 'routine in <a href="obj/map/map_rotate.html">map_rotate.pro</a>', "map_rotate.pro", "", "map_rotate", "<code class= source >	Returns the rotate value for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of rotate values associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_scale.html", "map_scale.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_scale.html#map_scale", "map_scale", 'routine in <a href="obj/map/map_scale.html">map_scale.pro</a>', "map_scale.pro", "", "map_scale", "<code class= source >	Returns the scale factor for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nt) of scale factors associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_center.html", "map_set_center.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_center.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_center.html#map_set_center", "map_set_center", 'routine in <a href="obj/map/map_set_center.html">map_set_center.pro</a>', "map_set_center.pro", "", "map_set_center", "<code class= source >	Replaces the center for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  center<code class= source > Array (2,nt) of new map centers.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_fn_data.html", "map_set_fn_data.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_fn_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_fn_data.html#map_set_fn_data", "map_set_fn_data", 'routine in <a href="obj/map/map_set_fn_data.html">map_set_fn_data.pro</a>', "map_set_fn_data.pro", "", "map_set_fn_data", "<code class= source >	Replaces the function data for a map descriptor.</code>  ", "noeventmd<code class= source > Map descriptor.</code>  data<code class= source > New function data.</code>  ", "NV/LIB/MAP", "<code class= source > 	Adapted by:	Spitale, 7/2016; adapted from map_set_fn_data_p</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_graphic.html", "map_set_graphic.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_graphic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_graphic.html#map_set_graphic", "map_set_graphic", 'routine in <a href="obj/map/map_set_graphic.html">map_set_graphic.pro</a>', "map_set_graphic.pro", "", "map_set_graphic", "<code class= source >	Replaces the graphic flag for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  graphic<code class= source > Array (nt) of new graphic flags.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_origin.html", "map_set_origin.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_origin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_origin.html#map_set_origin", "map_set_origin", 'routine in <a href="obj/map/map_set_origin.html">map_set_origin.pro</a>', "map_set_origin.pro", "", "map_set_origin", "<code class= source >	Replaces the origin for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  origin<code class= source > Array (2,nt) of new map origins.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_pole.html", "map_set_pole.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_pole.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_pole.html#map_set_pole", "map_set_pole", 'routine in <a href="obj/map/map_set_pole.html">map_set_pole.pro</a>', "map_set_pole.pro", "", "map_set_pole", "<code class= source >	Replaces the pole for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  pole<code class= source > Array (nt) of new ominas_map_pole structs.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_projection.html", "map_set_projection.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_projection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_projection.html#map_set_projection", "map_set_projection", 'routine in <a href="obj/map/map_set_projection.html">map_set_projection.pro</a>', "map_set_projection.pro", "", "map_set_projection", "<code class= source >	Replaces the projection name for each given map descriptor.</code>  ", "noeventmd<code class= source >	 Array (nt) of map descriptors.</code>  projection<code class= source > Array (nt) of new projection names.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_radii.html", "map_set_radii.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_radii.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_radii.html#map_set_radii", "map_set_radii", 'routine in <a href="obj/map/map_set_radii.html">map_set_radii.pro</a>', "map_set_radii.pro", "", "map_set_radii", "<code class= source >	Replaces the reference radii for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  radii<code class= source > Array (3,nt) of new reference radii.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_range.html", "map_set_range.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_range.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_range.html#map_set_range", "map_set_range", 'routine in <a href="obj/map/map_set_range.html">map_set_range.pro</a>', "map_set_range.pro", "", "map_set_range", "<code class= source >	Replaces the range for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  range<code class= source > Array (2,2,nt) of new map ranges.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 7/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_rotate.html", "map_set_rotate.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_rotate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_rotate.html#map_set_rotate", "map_set_rotate", 'routine in <a href="obj/map/map_set_rotate.html">map_set_rotate.pro</a>', "map_set_rotate.pro", "", "map_set_rotate", "<code class= source >	Replaces the rotate value for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  rotate<code class= source > Array (nt) of new rotate values.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_scale.html", "map_set_scale.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_scale.html#map_set_scale", "map_set_scale", 'routine in <a href="obj/map/map_set_scale.html">map_set_scale.pro</a>', "map_set_scale.pro", "", "map_set_scale", "<code class= source >	Replaces the scale factor for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  scale<code class= source > Array (2,nt) of new scale factors.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_size.html", "map_set_size.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_size.html#map_set_size", "map_set_size", 'routine in <a href="obj/map/map_set_size.html">map_set_size.pro</a>', "map_set_size.pro", "", "map_set_size", "<code class= source >	Replaces the size for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  size<code class= source > Array (2,nt) of new map sizes.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_units.html", "map_set_units.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_units.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_units.html#map_set_units", "map_set_units", 'routine in <a href="obj/map/map_set_units.html">map_set_units.pro</a>', "map_set_units.pro", "", "map_set_units", "<code class= source >	Replaces the units for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  units<code class= source > Array (2,nt) of new map units.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_set_west.html", "map_set_west.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_set_west.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_set_west.html#map_set_west", "map_set_west", 'routine in <a href="obj/map/map_set_west.html">map_set_west.pro</a>', "map_set_west.pro", "", "map_set_west", "<code class= source >	Replaces the west flag for each given map descriptor.</code>  ", "noeventmd<code class= source > Array (nt) of map descriptors.</code>  west<code class= source > Array (nt) of new west flags.</code>  ", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/201y</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_size.html", "map_size.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_size.html#map_size", "map_size", 'routine in <a href="obj/map/map_size.html">map_size.pro</a>', "map_size.pro", "", "map_size", "<code class= source >	Returns the size for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nt) of sizes associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_disk.html", "map_to_disk.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_disk.html#map_to_disk", "map_to_disk", 'routine in <a href="obj/tools/composite/map_to_disk.html">map_to_disk.pro</a>', "map_to_disk.pro", "", "map_to_disk", "<code class= source >       Transforms points in map coordinates to disk coordinates.</code>  ", "md<code class= source >Array of nt map descriptors.</code>  dkdmap_pts<code class= source >      Array (2 x nv x nt) of map points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of disk coordinates, with the altitude coordinate set to</code> <code class= source >	zero.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_globe.html", "map_to_globe.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_globe.html#map_to_globe", "map_to_globe", 'routine in <a href="obj/tools/composite/map_to_globe.html">map_to_globe.pro</a>', "map_to_globe.pro", "", "map_to_globe", "<code class= source >       Transforms points in map coordinates to surface coordinates.</code>  ", "md<code class= source >Array of nt map descriptors.</code>  gbx<code class= source >Array of nt globe descriptors.</code>  map_pts<code class= source >Array (2 x nv x nt) of map points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of globe coordinates, with the altitude coordinate set to</code> <code class= source >	zero.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_image.html", "map_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_image.html#map_to_image", "map_to_image", 'routine in <a href="obj/tools/composite/map_to_image.html">map_to_image.pro</a>', "map_to_image.pro", "", "map_to_image", "<code class= source >       Transforms points from map coordinates to image coordinates.</code>  ", "body_pts<code class= source >Body coordinates of output points.</code>  valid<code class= source >	Indices of valid output points.</code>  alt<code class= source >	If set, atitudes are set to this value instead of 0.</code>  md<code class= source >Array of nt map descriptors describing the initial coordinate system.</code> <code class= source >		If bx is given, then this descriptor is not needed, though</code> <code class= source >		it may still be used to select between graphic/centric</code> <code class= source >		latitudes.</code>  cd<code class= source >Array of nt camera or map descriptor describing the final</code> <code class= source >		coordinate system.</code>  bx<code class= source >Array of nt Object descriptors (subclass of BODY).</code>  map_pts<code class= source >      Array (2 x nv x nt) of map points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of image points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/map_to_surface.html", "map_to_surface.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "map_to_surface.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/map_to_surface.html#map_to_surface", "map_to_surface", 'routine in <a href="obj/tools/composite/map_to_surface.html">map_to_surface.pro</a>', "map_to_surface.pro", "", "map_to_surface", "<code class= source >       Transforms points in map coordinates to surface coordinates.</code>  ", "alt<code class= source >If set, atitudes are set to this value instead of 0.</code>  md<code class= source >Array of nt map descriptors.</code>  bx<code class= source >Array of nt object descriptors (subclass of BODY.</code>  map_pts<code class= source >Array (2 x nv x nt) of map points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of surface coordinates, with the altitude coordinate</code> <code class= source >	set to zero.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_units.html", "map_units.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_units.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_units.html#map_units", "map_units", 'routine in <a href="obj/map/map_units.html">map_units.pro</a>', "map_units.pro", "", "map_units", "<code class= source >	Returns the units for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (2,nt) of units associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/map_units_disk.html", "map_units_disk.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "map_units_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/map_units_disk.html#map_units_disk", "map_units_disk", 'routine in <a href="obj/tools/map_units_disk.html">map_units_disk.pro</a>', "map_units_disk.pro", "", "map_units_disk", "<code class= source >	Computes units for a map descriptor given pixel scales for</code> <code class= source >	the map center.</code>  ", "resrad<code class= source >Scale (length/pixel) in radial direction.</code>  reslon<code class= source >Scale (radians/pixel) in longitude direction.</code>  md<code class= source >Map descriptor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (2) giving the map units.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_west.html", "map_west.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_west.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_west.html#map_west", "map_west", 'routine in <a href="obj/map/map_west.html">map_west.pro</a>', "map_west.pro", "", "map_west", "<code class= source >	Returns the west flag for each given map descriptor.</code>  ", "noeventmd", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/201y</code>  <code class= source >	Array (nt) of west flags associated with each given map descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/map_west_to_east.html", "map_west_to_east.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "map_west_to_east.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/map_west_to_east.html#map_west_to_east", "map_west_to_east", 'routine in <a href="obj/map/map_west_to_east.html">map_west_to_east.pro</a>', "map_west_to_east.pro", "", "map_west_to_east", "<code class= source >	Converts longitudes from the westward to the eastward</code> <code class= source >	convention.</code>  ", "md<code class= source >Array (nt) of map descriptors.</code>  map_pts0", "NV/LIB/MAP", "<code class= source > 	Written by:	Spitale, 8/201y</code>  <code class= source >	Array (2,nv,nt) of map points in which the longitudes are</code> <code class= source >	eastward.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/mask_globe.html", "mask_globe.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "mask_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/mask_globe.html#mask_globe", "mask_globe", 'routine in <a href="obj/tools/mask_globe.html">mask_globe.pro</a>', "mask_globe.pro", "", "mask_globe", "<code class= source >	Computes an image mask for a globe.</code>  ", "oversampleslopsubcd<code class= source >Camera descriptor.</code>  _gbx<code class= source >Any subclass of GLOBE.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Angle in radians.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/minmax_latlon.html", "minmax_latlon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "minmax_latlon.pro", "", "", "<code class= source >	Computes latitide/longitude ranges visible in a given camera.</code>  ", "", "          -1", "<code class= source >       Written by:     Spitale</code>  ");
  

libdata[libdataItem++] = new Array("sys/util/nv_clone.html", "nv_clone.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_clone.pro", "", "", "<code class= source >       Allocates a new object as a copy of the given (existing)</code> <code class= source >	object.  All pointers in the new object are newly allocated.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("sys/event/nv_compress_events.html", "nv_compress_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_compress_events.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_compress_events.html#nv_compress_events", "nv_compress_events", 'routine in <a href="sys/event/nv_compress_events.html">nv_compress_events.pro</a>', "nv_compress_events.pro", "", "nv_compress_events", "<code class= source >	Returns only unique events from the given buffer.</code>  ", "buf<code class= source >Array of nv_event_struct.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	All events in buf that are unique.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_copy.html", "nv_copy.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_copy.pro", "", "", "<code class= source >	Copies all fields from one descriptor to another.  New pointers</code> <code class= source >	are allocated only when the destination field is null.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale		3/2016</code>  ");
  

libdata[libdataItem++] = new Array("sys/util/nv_directive_stop__define.html", "nv_directive_stop__define.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_directive_stop__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_directive_stop__define.html#nv_directive_stop__define", "nv_directive_stop__define", 'routine in <a href="sys/util/nv_directive_stop__define.html">nv_directive_stop__define.pro</a>', "nv_directive_stop__define.pro", "", "nv_directive_stop__define", "<code class= source >	Structure defining the NV_STOP directive.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_event_struct__define.html", "nv_event_struct__define.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_event_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_event_struct__define.html#nv_event_struct__define", "nv_event_struct__define", 'routine in <a href="sys/event/nv_event_struct__define.html">nv_event_struct__define.pro</a>', "nv_event_struct__define.pro", "", "nv_event_struct__define", "<code class= source >	Structure defining the NV data event.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_flush.html", "nv_flush.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_flush.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_flush.html#nv_flush", "nv_flush", 'routine in <a href="sys/event/nv_flush.html">nv_flush.pro</a>', "nv_flush.pro", "", "nv_flush", "<code class= source >	Flushes the nv event buffer.</code>  <code class= source >	Events are compressed so that duplicate events are not reported.  Each</code> <code class= source >	unique handler is called once with all of the relevant events given.</code>  <code class= source >	nv_notify_block</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	nv_notify</code>  ", "clearevents<code class= source >If specified, these events are processed instead of those in</code> <code class= source >		the event buffer.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 11/2002</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_free.html", "nv_free.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_free.pro", "", "", "<code class= source >	Recursively frees a descriptor.  Pointers and structures are</code> <code class= source >	dereferenced and descended, freeing any pointers encountered.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code>  ");
  

libdata[libdataItem++] = new Array("sys/util/nv_help.html", "nv_help.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_help.pro", "", "", "<code class= source >	Prints information about various OMINAS objects.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 2/1998</code>  ");
  

libdata[libdataItem++] = new Array("sys/state/nv_init_state.html", "nv_init_state.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_init_state.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/state/nv_init_state.html#nv_init_state", "nv_init_state", 'routine in <a href="sys/state/nv_init_state.html">nv_init_state.pro</a>', "nv_init_state.pro", "", "nv_init_state", "<code class= source >	Initializes the NV state structure.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	New nv_state structure.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_message.html", "nv_message.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_message.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_message.html#nv_message", "nv_message", 'routine in <a href="sys/util/nv_message.html">nv_message.pro</a>', "nv_message.pro", "", "nv_message", "<code class= source >	Prints an error message and halts execution.</code>  <code class= source >Environment variables: </code> <code class= source >	NV_VERBOSITY:	Initial verbosity setting.</code>  ", "nameanonymouscontinueclearget_messageformatmessageexplanationcallbackcb_data_pdisconnectcb_tagverbosesilentstopstring<code class= source >Message to print.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	message:	If /get_message, this keyword will return the last</code> <code class= source >			message sent through nv_message.</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify.html", "nv_notify.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify.html#nv_notify", "nv_notify", 'routine in <a href="sys/event/nv_notify.html">nv_notify.pro</a>', "nv_notify.pro", "", "nv_notify", "<code class= source >	Notify nv system of an event on some set of descriptors.</code>  <code class= source >	By default, write events are buffered.  Handlers for write events are</code> <code class= source >	only called when /flush is specified.  For read events, all event</code> <code class= source >	handlers of the specified type are called as procedures with an</code> <code class= source > 	nv_event_struct as the argument.</code>  <code class= source >	nv_notify_block</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	nv_notify_register, nv_notify_unregister</code>  ", "type<code class= source >Type of event:</code> <code class= source >		 0 - set value</code> <code class= source >		 1 - get value</code> <code class= source >		This input can have only one element.  If not given, the</code> <code class= source >		event type is assumed to be 0.</code>  descflush<code class= source >Flush the write event buffer -- call the handlers for each</code> <code class= source >		unique event only once and clear the buffer.</code>  noevent<code class= source >If set, nothing is done.</code>  xd<code class= source >Descriptor for which an event has occurred.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 6/2002</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_list_struct__define.html", "nv_notify_list_struct__define.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_list_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_list_struct__define.html#nv_notify_list_struct__define", "nv_notify_list_struct__define", 'routine in <a href="sys/event/nv_notify_list_struct__define.html">nv_notify_list_struct__define.pro</a>', "nv_notify_list_struct__define.pro", "", "nv_notify_list_struct__define", "<code class= source >	Structure defining an entry in the NV event registry.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_register.html", "nv_notify_register.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_register.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_register.html#nv_notify_register", "nv_notify_register", 'routine in <a href="sys/event/nv_notify_register.html">nv_notify_register.pro</a>', "nv_notify_register.pro", "", "nv_notify_register", "<code class= source >	Register descriptor event handlers.</code>  <code class= source >	nv_notify_block</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	nv_notify_unregister</code>  ", "data<code class= source >	Arbitrary user data to associate with events on these</code> <code class= source >			descriptors.  A pointer to this data is allocated and</code> <code class= source >			returned in the 'data_p' field of the event structure.</code> <code class= source >			Note that only one descriptor xd may be specified</code> <code class= source >			per call when using this argument.</code>  scalar_data<code class= source >Scalar user data to associate with events on these</code> <code class= source >			descriptors.  This data is returned in the 'data'</code> <code class= source >			field of the event structure.</code>  compress<code class= source >Event compression flag.</code>  _xd<code class= source >	Array of descriptors.</code>  handler<code class= source >Name of event handler functions.  If only one element,</code> <code class= source >			then this function will be registered for every given</code> <code class= source >			descriptor.  Otherwise must have the same number of</code> <code class= source >			elements as xd.</code>  type<code class= source >	Type of data event to respond to:</code> <code class= source >			 0 - set value</code> <code class= source >			 1 - get value</code> <code class= source >			0 is default.  If only one element, then this type</code> <code class= source >			will be registered for every given descriptor.</code> <code class= source >			Otherwise must have the same number of elements as xd.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 6/2002</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_notify_unregister.html", "nv_notify_unregister.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_notify_unregister.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_notify_unregister.html#nv_notify_unregister", "nv_notify_unregister", 'routine in <a href="sys/event/nv_notify_unregister.html">nv_notify_unregister.pro</a>', "nv_notify_unregister.pro", "", "nv_notify_unregister", "<code class= source >	Unregister a descriptor event handler.</code>  <code class= source >	nv_notify_block</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	nv_notify_register</code>  ", "all<code class= source >	If set, all handlers are unregistered.</code>  xd<code class= source >	Descriptors for which to discontinue notification.</code>  handler<code class= source >If given, names of event handler functions to remove</code> <code class= source >			for each given descriptor.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale, 6/2002</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_ping.html", "nv_ping.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_ping.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_ping.html#nv_ping", "nv_ping", 'routine in <a href="sys/event/nv_ping.html">nv_ping.pro</a>', "nv_ping.pro", "", "nv_ping", "<code class= source >	Generates a write event on a set of descriptors.</code>  ", "noeventxdp", "NV/SYS", "<code class= source > 	Written by:	Spitale, 5/2014</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_protected.html", "nv_protected.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_protected.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_protected.html#nv_protected", "nv_protected", 'routine in <a href="sys/util/nv_protected.html">nv_protected.pro</a>', "nv_protected.pro", "", "nv_protected", "<code class= source >	Tests whether a structure or field is protected.  Protected fields</code> <code class= source >	are not freed by nv_free, nor are they descended by nv_free</code> <code class= source >	or nv_clone.</code>  ", "arg", "NV/SYS", "<code class= source > 	Written by:	Spitale, 7/2016</code>  <code class= source >	1 if protected, 0 if not.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_ptr_free.html", "nv_ptr_free.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_ptr_free.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_ptr_free.html#nv_ptr_free", "nv_ptr_free", 'routine in <a href="sys/util/nv_ptr_free.html">nv_ptr_free.pro</a>', "nv_ptr_free.pro", "", "nv_ptr_free", "<code class= source >	Wrapper to the IDL routine ptr_free.  In conjunction with nv_ptr_new,</code> <code class= source >	pointer allocations are tracked for debugging purposes.</code>  ", "p<code class= source >Pointer to free.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/util/nv_ptr_new.html", "nv_ptr_new.pro", '.pro file in <a href="sys/util/dir-overview.html">sys/util/ directory</a>', "nv_ptr_new.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/util/nv_ptr_new.html#nv_ptr_new", "nv_ptr_new", 'routine in <a href="sys/util/nv_ptr_new.html">nv_ptr_new.pro</a>', "nv_ptr_new.pro", "", "nv_ptr_new", "<code class= source >	Wrapper for te IDL function ptr_new.  In conjunction with nv_ptr_free,</code> <code class= source >	pointer allocations are tracked for debugging purposes.</code>  ", "allocate_heapno_copyx<code class= source >Data to point to.</code>  ", "NV/SYS", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Newly allocated pointer</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/state/nv_reset.html", "nv_reset.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_reset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/state/nv_reset.html#nv_reset", "nv_reset", 'routine in <a href="sys/state/nv_reset.html">nv_reset.pro</a>', "nv_reset.pro", "", "nv_reset", "<code class= source >	Resets the NV state.</code>  ", "", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_resume_events.html", "nv_resume_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_resume_events.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_resume_events.html#nv_resume_events", "nv_resume_events", 'routine in <a href="sys/event/nv_resume_events.html">nv_resume_events.pro</a>', "nv_resume_events.pro", "", "nv_resume_events", "<code class= source >	Resumes data event tracking.</code>  ", "", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/state/nv_state_struct__define.html", "nv_state_struct__define.pro", '.pro file in <a href="sys/state/dir-overview.html">sys/state/ directory</a>', "nv_state_struct__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/state/nv_state_struct__define.html#nv_state_struct__define", "nv_state_struct__define", 'routine in <a href="sys/state/nv_state_struct__define.html">nv_state_struct__define.pro</a>', "nv_state_struct__define.pro", "", "nv_state_struct__define", "<code class= source >	Structure defining the NV state.</code>  ", "", "NV/SYS", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("sys/event/nv_suspend_events.html", "nv_suspend_events.pro", '.pro file in <a href="sys/event/dir-overview.html">sys/event/ directory</a>', "nv_suspend_events.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("sys/event/nv_suspend_events.html#nv_suspend_events", "nv_suspend_events", 'routine in <a href="sys/event/nv_suspend_events.html">nv_suspend_events.pro</a>', "nv_suspend_events.pro", "", "nv_suspend_events", "<code class= source >	Suspends data event tracking.</code>  ", "", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/arr/ominas_array__define.html", "ominas_array__define.pro", '.pro file in <a href="obj/arr/dir-overview.html">obj/arr/ directory</a>', "ominas_array__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/arr/ominas_array__define.html#ominas_array__define", "ominas_array__define", 'routine in <a href="obj/arr/ominas_array__define.html">ominas_array__define.pro</a>', "ominas_array__define.pro", "", "ominas_array__define", "<code class= source >	Class structure for the ARRAY class.</code>  ", "", "NV/LIB/arr", "<code class= source > 	Written by:	Spitale, 10/2012</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/bod/ominas_body__define.html", "ominas_body__define.pro", '.pro file in <a href="obj/bod/dir-overview.html">obj/bod/ directory</a>', "ominas_body__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/bod/ominas_body__define.html#ominas_body__define", "ominas_body__define", 'routine in <a href="obj/bod/ominas_body__define.html">ominas_body__define.pro</a>', "ominas_body__define.pro", "", "ominas_body__define", "<code class= source >	Class structure for the BODY class.</code>  ", "", "NV/LIB/BOD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cam/ominas_camera__define.html", "ominas_camera__define.pro", '.pro file in <a href="obj/cam/dir-overview.html">obj/cam/ directory</a>', "ominas_camera__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cam/ominas_camera__define.html#ominas_camera__define", "ominas_camera__define", 'routine in <a href="obj/cam/ominas_camera__define.html">ominas_camera__define.pro</a>', "ominas_camera__define.pro", "", "ominas_camera__define", "<code class= source >	Class structure fo the CAMERA class.</code>  ", "", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html", "ominas_core__define.pro", '.pro file in <a href="obj/cor/dir-overview.html">obj/cor/ directory</a>', "ominas_core__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/cor/ominas_core__define.html#ominas_core__define", "ominas_core__define", 'routine in <a href="obj/cor/ominas_core__define.html">ominas_core__define.pro</a>', "ominas_core__define.pro", "", "ominas_core__define", "<code class= source >	Class structure for the CORE class.</code>  ", "", "NV/OBJ/COR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/ominas_data__define.html", "ominas_data__define.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "ominas_data__define.pro", "", "", "<code class= source >	Structure defining the data descriptor.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

libdata[libdataItem++] = new Array("obj/dsk/ominas_disk__define.html", "ominas_disk__define.pro", '.pro file in <a href="obj/dsk/dir-overview.html">obj/dsk/ directory</a>', "ominas_disk__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/dsk/ominas_disk__define.html#ominas_disk__define", "ominas_disk__define", 'routine in <a href="obj/dsk/ominas_disk__define.html">ominas_disk__define.pro</a>', "ominas_disk__define.pro", "", "ominas_disk__define", "<code class= source >	Class structure for the DISK class.</code>  ", "", "NV/LIB/DSK", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/glb/ominas_globe__define.html", "ominas_globe__define.pro", '.pro file in <a href="obj/glb/dir-overview.html">obj/glb/ directory</a>', "ominas_globe__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/glb/ominas_globe__define.html#ominas_globe__define", "ominas_globe__define", 'routine in <a href="obj/glb/ominas_globe__define.html">ominas_globe__define.pro</a>', "ominas_globe__define.pro", "", "ominas_globe__define", "<code class= source >	Class structure fo the GLOBE class.</code>  ", "", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/map/ominas_map__define.html", "ominas_map__define.pro", '.pro file in <a href="obj/map/dir-overview.html">obj/map/ directory</a>', "ominas_map__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/map/ominas_map__define.html#ominas_map__define", "ominas_map__define", 'routine in <a href="obj/map/ominas_map__define.html">ominas_map__define.pro</a>', "ominas_map__define.pro", "", "ominas_map__define", "<code class= source >	Class structure fo the MAP class.</code>  ", "", "NV/LIB/CAM", "<code class= source > 	Written by:	Spitale, 1/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/plt/ominas_planet__define.html", "ominas_planet__define.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "ominas_planet__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/ominas_planet__define.html#ominas_planet__define", "ominas_planet__define", 'routine in <a href="obj/plt/ominas_planet__define.html">ominas_planet__define.pro</a>', "ominas_planet__define.pro", "", "ominas_planet__define", "<code class= source >	Class structure for the PLANET class.</code>  ", "", "NV/LIB/PLT", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/ominas_point__define.html", "ominas_point__define.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "ominas_point__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/ominas_point__define.html#ominas_point__define", "ominas_point__define", 'routine in <a href="obj/pnt/ominas_point__define.html">ominas_point__define.pro</a>', "ominas_point__define.pro", "", "ominas_point__define", "<code class= source >	Structure for managing points.</code>  ", "", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pg_points_struct__define</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/ominas_ring__define.html", "ominas_ring__define.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "ominas_ring__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/ominas_ring__define.html#ominas_ring__define", "ominas_ring__define", 'routine in <a href="obj/rng/ominas_ring__define.html">ominas_ring__define.pro</a>', "ominas_ring__define.pro", "", "ominas_ring__define", "<code class= source >	Class structure for the RING class.</code>  ", "", "NV/LIB/RNG", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/ominas_solid__define.html", "ominas_solid__define.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "ominas_solid__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/ominas_solid__define.html#ominas_solid__define", "ominas_solid__define", 'routine in <a href="obj/sld/ominas_solid__define.html">ominas_solid__define.pro</a>', "ominas_solid__define.pro", "", "ominas_solid__define", "<code class= source >	Class structure fo the SOLID class.</code>  ", "", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/ominas_star__define.html", "ominas_star__define.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "ominas_star__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/ominas_star__define.html#ominas_star__define", "ominas_star__define", 'routine in <a href="obj/str/ominas_star__define.html">ominas_star__define.pro</a>', "ominas_star__define.pro", "", "ominas_star__define", "<code class= source >	Class structure for the STAR class.</code>  ", "", "NV/LIB/STR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/ominas_station__define.html", "ominas_station__define.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "ominas_station__define.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/ominas_station__define.html#ominas_station__define", "ominas_station__define", 'routine in <a href="obj/stn/ominas_station__define.html">ominas_station__define.pro</a>', "ominas_station__define.pro", "", "ominas_station__define", "<code class= source >	Class structure for the STATION class.</code>  ", "", "NV/LIB/STN", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_array.html", "pg_array.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_array.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_array.html#pg_array", "pg_array", 'routine in <a href="com/pg/pg_array.html">pg_array.pro</a>', "pg_array.pro", "", "pg_array", "<code class= source >	Computes image points for given array descriptors.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  ard<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of array.</code>  gbx<code class= source >Array (n_xd, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of GLOBE.</code>  dkx<code class= source >Array (n_xd, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of DISK.</code>  bx<code class= source >Array (n_xd, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of BODY, instead of gbx or dkx.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  clip<code class= source > If set points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 10/2012</code>  <code class= source >	Array (n_objects) of objects containing image points and</code> <code class= source >	the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_bad_data.html", "pg_bad_data.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_bad_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_bad_data.html#pg_bad_data", "pg_bad_data", 'routine in <a href="com/pg/pg_bad_data.html">pg_bad_data.pro</a>', "pg_bad_data.pro", "", "pg_bad_data", "<code class= source >	Locates areas of bad data values like saturation and dropouts.</code>  ", "dropout<code class= source >Value to use for dropouts.  Default is 0</code>  sat<code class= source >	If given, value above which to flag as saturated,</code> <code class= source >			inclusive.</code>  mask<code class= source >	Byte image of the same size as the input image</code> <code class= source >			in which nonzero pixel values indicate locations</code> <code class= source >			where problems should not be flagged.</code>  extend<code class= source >	Number of pixels away from masked pixels before</code> <code class= source >			locations may be flagged as spikes.</code>  edge<code class= source >	Regions closer than this to the edge of the image</code> <code class= source >			will be ignored.  Default is 0.</code>  subscripts<code class= source >Subscript of each bad point.</code>  dd<code class= source >	Data descriptor containing the image to be despiked.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 7/2013</code>  <code class= source >	POINT objects containing the detected bad points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_spikes</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_blemish.html", "pg_blemish.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_blemish.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_blemish.html#pg_blemish", "pg_blemish", 'routine in <a href="com/pg/pg_blemish.html">pg_blemish.pro</a>', "pg_blemish.pro", "", "pg_blemish", "<code class= source >	Removes blemishes from an image using interpolation.</code>  <code class= source >	Blemishes are modeled as ellipses.  Pixels interior to the ellipse</code> <code class= source >	are interpolated from those on the boundary.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_resloc, pg_linearize_image, pg_resfit</code>  ", "a<code class= source >	Semimajor axis of elliptical blemish model.  Default is</code> <code class= source >			5 pixels.</code>  b<code class= source >	Semiminor axis of elliptical blemish model.  Default is</code> <code class= source >			5 pixels.</code>  h<code class= source >	Angle of rotation (in radians) of smimajor axis from</code> <code class= source >			horizontal.  Default is 0.</code>  image<code class= source >	The corrected image.</code>  show<code class= source >	If set, the outlines of the blemishes are plotted on</code> <code class= source >			the current graphics window.</code>  dd<code class= source >	Data descriptor containing the image to be corrected.</code>  blem_ptd<code class= source >POINT object containing the known image</code> <code class= source >			coordinates of the blemishes.  If an array of</code> <code class= source >			objects is given, then the operation is</code> <code class= source >			performed repeatedly using each set of blemish</code> <code class= source >			coordinates.</code> <code class= source >			This argument can also be specified directly as an</code> <code class= source >			array of image points.</code>  nom_ptd", "NV/PG", "<code class= source > 	Written by:	Spitale, 5/2002</code>  <code class= source >	Data descriptor containing the corrected image.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_center.html", "pg_center.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_center.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_center.html#pg_center", "pg_center", 'routine in <a href="com/pg/pg_center.html">pg_center.pro</a>', "pg_center.pro", "", "pg_center", "<code class= source >	Computes image coordinates of the center of each object.</code>  ", "cd<code class= source >Array (nt) of camera descriptors.</code>  bx<code class= source >Array (n_objects, nt) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  clip<code class= source > If set points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array (n_objects) of POINT objets containing image points and</code> <code class= source >	the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_chisq.html", "pg_chisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_chisq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_chisq.html#pg_chisq", "pg_chisq", 'routine in <a href="com/pg/pg_chisq.html">pg_chisq.pro</a>', "pg_chisq.pro", "", "pg_chisq", "<code class= source >	Computes chi-squared value for given curve- or point-fit parameters.</code>  ", "axis_ptd<code class= source >POINT object containing a single image point</code> <code class= source >			to be used as the axis of rotation.</code>  fix<code class= source >	Array specifying which parameters to fix as</code> <code class= source >			[dx,dy,dtheta].</code>  dxy<code class= source >	2-element vector giving the translation as [dx,dy].</code>  dtheta<code class= source >	Rotation in radians.</code>  scan_ptd<code class= source >Array (n_curves) of POINT objects output from</code> <code class= source >			pg_cvscan or pg_ptscan containing scan data.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 10/2002</code>  <code class= source >	Normalized chi-square value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff,</code> <code class= source >	pg_ptchisq, pg_fit, pg_threshold</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cntrd.html", "pg_cntrd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cntrd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cntrd.html#pg_cntrd", "pg_cntrd", 'routine in <a href="com/pg/pg_cntrd.html">pg_cntrd.pro</a>', "pg_cntrd.pro", "", "pg_cntrd", "<code class= source >	Calculates the centroids centered near given features in</code> <code class= source >	an image.</code>  <code class= source >	Currently does not work for multiple time steps.</code>  <code class= source >	For each visible object, a centroid is calcualted using the</code> <code class= source >	astronlib cntrd routine.</code> <code class= source > SEE ALSO:</code> <code class= source >	ptscan, pg_ptscan, pg_ptcntrd</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ", "fwhm<code class= source >          Full-Width Half-maximum to use around expected point</code> <code class= source >                       location.  If not given, a default fwhm of 2 pixels</code> <code class= source >                       is used.</code>  edge<code class= source >          Distance from edge from which to ignore points.  If</code> <code class= source >                       not given, an edge distance of 0 is used.</code>  sigmin<code class= source >          If given, points are discarded if the sigma above</code> <code class= source >                       the mean for the centroid pixel is below this value.</code>  dd<code class= source >	Data descriptor</code>  object_ptd<code class= source >	Array (n_pts) of POINT objects giving the points.</code> <code class= source >			Only the image coordinates of the points need to be</code> <code class= source >			specified.</code>  ", "NV/PG", "<code class= source > 	Written by:	Haemmerle, 2/1999</code>  <code class= source >	An array of type POINT objects giving the detected position for</code> <code class= source >       each object.  The max values for each detection is</code> <code class= source >       saved in the data portion of object with tag 'scan_cc'.</code> <code class= source >       The x and y offset from the given position is also saved.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_coadd.html", "pg_coadd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_coadd.pro", "", "", "<code class= source >	Averages the given images and geometries.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 4/2014</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_core.html", "pg_core.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_core.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_core.html#pg_core", "pg_core", 'routine in <a href="com/pg/pg_core.html">pg_core.pro</a>', "pg_core.pro", "", "pg_core", "<code class= source >	Generates a dn profile through a cube, or stack of images.</code>  ", "cd<code class= source >Camera descriptor.  Needed for sinc interpolation. (to get PSF)</code>  gd<code class= source >  Optional generic descriptor containing cd.</code>  distance<code class= source > Array giving the distance, in pixels, along the profile.</code>  interp<code class= source >  Type of interpolation to use.  Options are:</code> <code class= source >               'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.</code>  arg_interp<code class= source >  Arguments to pass to the interpolation function.</code>  sigma<code class= source >  Array giving the standard deviation at each point in the</code> <code class= source >		profile.</code>  profile<code class= source >  The profile.</code>  image_pts<code class= source > Image point for each point along the profile.</code>  bg<code class= source >Uniform value to subtract from profile.</code>  dd<code class= source > Data descriptor(s).</code>  outline_ptd<code class= source >  POINT descriptor giving the outline of the region to plot,</code> <code class= source >                as produced by the pg_select_region.</code>  ", "NV/PG", "<code class= source >       Written by:     Spitale, 7/2016</code>  <code class= source >	Two data descriptors: the first contains the profile; the second contains</code> <code class= source >	the profile sigma.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_coregister.html", "pg_coregister.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_coregister.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_coregister.html#pg_coregister", "pg_coregister", 'routine in <a href="com/pg/pg_coregister.html">pg_coregister.pro</a>', "pg_coregister.pro", "", "pg_coregister", "<code class= source >	Using the given geometry information, shifts the given images so as</code> <code class= source >	to center the given bodies at the same pixel in each image, or aligns</code> <code class= source >	images based on pointing.</code>  <code class= source >	The given data and camera descriptors are modified: the images are</code> <code class= source >	shifted and the camera descriptor optic axes are changed accordingly.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "cd<code class= source >Array of camera descripors, one for each input image.</code>  bx<code class= source >Array of descriptors of any superclass of BODY, one for each</code> <code class= source >		input image.</code>  gd<code class= source >Generic descriptor containing the camera and body</code> <code class= source >		descriptors or an array of generic descriptors, one for each</code> <code class= source >		input image.</code>  shift<code class= source >Offset applied to each image.</code>  center<code class= source >Image coordinates at which to center each body.  By default,</code> <code class= source >		the average center among all the bodies is used.  If this input</code> <code class= source >		contains a single element, it is taken as the index of the</code> <code class= source >		input image to use as the reference.</code>  p<code class= source >Array (1,3) giving surface coordinates at which to center</code> <code class= source >		each body.</code>  xshift<code class= source >Additional image offset by which to shift each image.</code>  wrap<code class= source >If set shifted pixels are wrapped to the opposite side</code> <code class= source >		of the image.</code>  subpixel<code class= source >By default, each image is shifted by an integer number of</code> <code class= source >		  pixels in each direction. If this keyword is set, the</code> <code class= source >		  image is interpolated onto a new pixel grid such that the</code> <code class= source >		  sub-pixel shift is obtained.  (Not currently implemented)</code>  no_shiftdd<code class= source >Array of data descriptors giving images to shift.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 11/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_covariance.html", "pg_covariance.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_covariance.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_covariance.html#pg_covariance", "pg_covariance", 'routine in <a href="com/pg/pg_covariance.html">pg_covariance.pro</a>', "pg_covariance.pro", "", "pg_covariance", "<code class= source >	Computes a covariance matrix for the least-square fit specified by the</code> <code class= source >	input scan coefficients.</code>  <code class= source >	It is the caller's responsibility to ensure that all of the input</code> <code class= source >	coefficients were computed using with the same set of fixed parameters.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff,</code> <code class= source >	pg_cvchisq, pg_ptchisq, pg_threshold</code>  ", "statuscf<code class= source >Array of pg_fit_coeff_struct as produced by pg_cvscan_coeff or</code> <code class= source >		pg_ptscan_coeff.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 9/2002</code>  <code class= source >	Covariance matrix.  The diagonal elements are the variances in each fit</code> <code class= source >	parameter, the off-diagonal elements are the covariances.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_crop.html", "pg_crop.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_crop.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_crop.html#pg_crop", "pg_crop", 'routine in <a href="com/pg/pg_crop.html">pg_crop.pro</a>', "pg_crop.pro", "", "pg_crop", "<code class= source >       Crops an image and modifies that camera descriptor accordingly.</code>  ", "cd<code class= source >The optic axis of the camera descriptor is modified to</code> <code class= source >		correspond to the corrected image.</code>  gd<code class= source >    Generic descriptor to use instead of cd.</code>  image<code class= source >The cropped image</code>  cropdd<code class= source >       Data descriptor containing the image to be cropped.</code>  corner_ptd<code class= source >POINT object containing 2 points, giving the corners</code> <code class= source >		    for cropping.  May also be an array of 2 image points.</code>  ", "NV/PG", "<code class= source >       Written by:     Spitale; 6/2005</code>  <code class= source >	pg_crop, dd, cd=cd, [[100,200], [800,900]], im=im</code> <code class= source > STATUS:</code> <code class= source >       Complete.</code> <code class= source > NOTES:</code> <code class= source >	This routine should be modified to work with map descriptors as well.</code> <code class= source >       NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_crop_points.html", "pg_crop_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_crop_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_crop_points.html#pg_crop_points", "pg_crop_points", 'routine in <a href="com/pg/pg_crop_points.html">pg_crop_points.pro</a>', "pg_crop_points.pro", "", "pg_crop_points", "<code class= source >	Hides image points that lie outside the field of view.</code>  <code class= source >	The given POINT object is modified.</code> <code class= source > STATUS:</code> <code class= source >	xx</code>  ", "cd<code class= source >Camera descriptor, used to determine image dimenesions.</code>  slop<code class= source >Number of pixels outside image to include.  Defautl is 1.</code>  indices<code class= source >Indices of retained points.</code>  ptd<code class= source >POINT object containing points to be cropped.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale; 5/2005</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cull_bodies.html", "pg_cull_bodies.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cull_bodies.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cull_bodies.html#pg_cull_bodies", "pg_cull_bodies", 'routine in <a href="com/pg/pg_cull_bodies.html">pg_cull_bodies.pro</a>', "pg_cull_bodies.pro", "", "pg_cull_bodies", "<code class= source >	Removes (and frees) bodies in a given array.</code>  ", "namebx<code class= source >Array of descriptors.</code>  sel", "NV/PG", "<code class= source > 	Written by:	Spitale, 7/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cursor.html", "pg_cursor.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cursor.pro", "", "", "<code class= source >	Allows the user to obtain information about image pixels selected</code> <code class= source >	using the mouse in the current graphics window.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 3/2002</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_cusps.html", "pg_cusps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cusps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cusps.html#pg_cusps", "pg_cusps", 'routine in <a href="com/pg/pg_cusps.html">pg_cusps.pro</a>', "pg_cusps.pro", "", "pg_cusps", "<code class= source >	Computes image points at the limb/terminator cusps for each given</code> <code class= source >	globe object.</code>  <code class= source >	This program uses an iterative scheme to find the two points on</code> <code class= source >	the surface of the globe where the surface normal is simultaneously</code> <code class= source >	perpendicular to the vectors from the camera and the light source.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "cd<code class= source > Array (n_timesteps) of camera descriptors.</code>  od<code class= source > Array (n_timesteps) of descriptors for the observer,</code> <code class= source >		 default is ltd if gd given.</code>  gbx<code class= source > Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		 which must be a subclass of GLOBE.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  epsilon<code class= source >Maximum angular error in the result.  Default is 1e-3.</code>  reveal<code class= source > Normally, points computed for objects whose opaque flag</code> <code class= source >		 is set are made invisible.  /reveal suppresses this behavior.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 12/2010</code>  <code class= source >	Array (n_objects) of POINT objects containing image</code> <code class= source >	points and the corresponding inertial vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvchisq.html", "pg_cvchisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvchisq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvchisq.html#pg_cvchisq", "pg_cvchisq", 'routine in <a href="com/pg/pg_cvchisq.html">pg_cvchisq.pro</a>', "pg_cvchisq.pro", "", "pg_cvchisq", "<code class= source >	Computes chi-squared value for given curve fit parameters.</code>  <code class= source >	The caller is responsible for ensuring that the input parameters are</code> <code class= source >	consistent with those used with other programs like pg_fit.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff,</code> <code class= source >	pg_ptchisq, pg_fit, pg_threshold</code>  ", "axis_ptd<code class= source >POINT containing a single image  point</code> <code class= source >			to be used as the axis of rotation.</code>  fix<code class= source >	Array specifying which parameters to fix as</code> <code class= source >			[dx,dy,dtheta].</code>  dxy<code class= source >	2-element vector giving the translation as [dx,dy].</code>  dtheta<code class= source >	Rotation in radians.</code>  scan_ptd<code class= source >Array (n_curves) of POINT output from</code> <code class= source >			pg_cvscan containing scanned image points as well as</code> <code class= source >			other necessary scan data.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 6/1998</code>  <code class= source >	Chi-square value.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvscan.html", "pg_cvscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvscan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvscan.html#pg_cvscan", "pg_cvscan", 'routine in <a href="com/pg/pg_cvscan.html">pg_cvscan.pro</a>', "pg_cvscan.pro", "", "pg_cvscan", "<code class= source >	Attempts to find points of highest correlation with a given model along</code> <code class= source >	curves in an image.</code>  <code class= source >	Currently does not work for multiple time steps.</code>  <code class= source >	Normal sines and cosines are computed using icv_compute_directions.</code> <code class= source >	These directions are input to icv_strip_curve along with the image</code> <code class= source >	in order to extract an image strip to be scanned.  icv_scan_strip is</code> <code class= source >	then used to find the optimum scan offsets and icv_convert_scan_offsets</code> <code class= source >	is used to obtain image coordinates corresponding to each scan offset.</code> <code class= source >	See the documentation for each of those routines for more details.</code>  ", "algorithm<code class= source >Name of alrogithm to use to detect the edge.</code> <code class= source >			Choices are 'MODEL', 'GRAD', and 'HALF'.</code> <code class= source >			Default is 'MODEL'.</code>  cdbxgdmodel_p<code class= source >Array (n_curves) of pointers to model arrays.  Each</code> <code class= source >			model array has dimensions (n_points,nm), where n_points</code> <code class= source >			is the number of points in the curve and nm is the</code> <code class= source >			number of points in the model.  Thus, a model may be</code> <code class= source >			specified for each point on the curve.  Default</code> <code class= source >			model is edge_model_atan().</code>  mzero<code class= source >	Array (n_curves) or (n_curves,n_points) of zero-point</code> <code class= source >			offsets for each model in model_p.  mzero must be</code> <code class= source >			specified if model_p is given.</code>  dir<code class= source >	If given the scan will be performed in this direction</code> <code class= source >			instead of normal to the curve.  Must be a 2-element</code> <code class= source >			unit vector.</code>  width<code class= source >	Number of pixels to scan on either side of the curve.</code> <code class= source >			Default is 20.</code>  edge<code class= source >	Distance from the edge of the image within which</code> <code class= source >			curve points will not be scanned.  Default is 0.</code>  arg<code class= source >	Argument passed to the edge detection routine.</code> <code class= source >			For the GRAD algorithm, this argument specifies</code> <code class= source >			whether each edge is interior (arg=1) or</code> <code class= source >			exterior (arg=0).</code>  scan_ptd<code class= source >If given, these previously scanned points are updated</code> <code class= source >			to be consistent with the given data points.  The image</code> <code class= source >			is not scanned.</code>  dd<code class= source >	Data descriptor</code>  object_ptd", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	The following command scans for a limb in the image contained in the</code> <code class= source >	given data descriptor, dd:</code> <code class= source >	scan_ptd = pg_cvscan(dd, limb_ptd, width=40, edge=20)</code> <code class= source >	In this call, limb_ptd is a POINT containing computed limb</code> <code class= source >	points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq,</code> <code class= source >	pg_fit, pg_threshold</code> <code class= source >	Array (n_curves) of POINT objects containing resulting image points,</code> <code class= source >	as well as additional scan data to be used by pg_cvscan_coeff and</code> <code class= source >	possibly other programs.  The scan data is as follows:</code> <code class= source >		 tag			 description</code> <code class= source >	 	-----			-------------</code> <code class= source >		scan_cos		Cosine of normal at each point.</code> <code class= source >		scan_sin		Sine of normal at each point.</code> <code class= source >		scan_offsets		Raw offsets from computed curve.</code> <code class= source >		scan_cc			Correlation coefficient for each scanned</code> <code class= source >					point.</code> <code class= source >		scan_sigma		Scan offset uncertainties.</code> <code class= source >		scan_model_xpts		Model points corresponding to each</code> <code class= source >		scan_model_ypts		 scanned point</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_cvscan_coeff.html", "pg_cvscan_coeff.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_cvscan_coeff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_cvscan_coeff.html#pg_cvscan_coeff", "pg_cvscan_coeff", 'routine in <a href="com/pg/pg_cvscan_coeff.html">pg_cvscan_coeff.pro</a>', "pg_cvscan_coeff.pro", "", "pg_cvscan_coeff", "<code class= source >	Computes linear least-squares coefficients for a fit to the image</code> <code class= source >	coordinate translation and rotation that matches a computed curve to</code> <code class= source >	a scanned curve in an image.</code>  <code class= source >	Currently does not work for multiple time steps.</code>  <code class= source >	pg_cvscan_coeff extracts the scan data from the given</code> <code class= source >	scan_ptd structure and uses icv_coeff to compute the coefficients.</code> <code class= source >	See the documentation for that routine for details.</code>  ", "axis_ptd<code class= source >POINT containing a single image  point</code> <code class= source >			to be used as the axis of rotation in the fit for</code> <code class= source >			every curve.</code>  fix<code class= source >	Array specifying which parameters to fix in the</code> <code class= source >			fit as [dx,dy,dtheta].</code>  scan_ptd<code class= source >Array (n_curves) of POINT output from</code> <code class= source >			pg_cvscan containing scanned image points as well as</code> <code class= source >			other necessary scan data.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	The following command uses scan data from pg_cvscan to compute</code> <code class= source >	least square coefficients for a fit such that only dx and dtheta</code> <code class= source >	will be allowed to vary:</code> <code class= source >	cvscan_cf = pg_cvscan_coeff(scan_ptd, axis=center_ptd, fix=[1])</code> <code class= source >	In this call, scan_ptd is a POINT containing the scan data</code> <code class= source >	from pg_cvscan and center_ptd is a POINT giving the center</code> <code class= source >	of the planet as computed by pg_center.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq,</code> <code class= source >	pg_fit, pg_threshold</code> <code class= source >	Array (n_curves) of pg_fit_coeff_struct containing coefficients for</code> <code class= source >	the least-square fit to be input to pg_fit.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_data_adjust.html", "pg_data_adjust.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_data_adjust.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_data_adjust.html#pg_data_adjust", "pg_data_adjust", 'routine in <a href="com/pg/pg_data_adjust.html">pg_data_adjust.pro</a>', "pg_data_adjust.pro", "", "pg_data_adjust", "<code class= source >	Allows the user to adjust data values using the mouse.  A rectangle</code> <code class= source >	is selected height (positve or negative) gives the data value adjustment.</code> <code class= source >	Works for 1-D or 2-D data sets.</code>  ", "silentdd<code class= source >Data descriptor.</code>  ", "NV/PG", "<code class= source >      NONE</code> <code class= source > ORIGINAL AUTHOR : J. Spitale ; 2/2014</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_despike.html", "pg_despike.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_despike.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_despike.html#pg_despike", "pg_despike", 'routine in <a href="com/pg/pg_despike.html">pg_despike.pro</a>', "pg_despike.pro", "", "pg_despike", "<code class= source >	Removes previously-located spurious features like cosmic-ray hits.</code>  <code class= source >	pg_despike replaces the values of the desired pixels with those</code> <code class= source >	computed by smoothing the input image using a box filter of size</code> <code class= source >	'scale' repeatedly, 'n' times.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_spikes</code>  ", "image<code class= source >	The corrected image.</code>  scale<code class= source >	Typical size of features to be removed.  Default</code> <code class= source >			is 10.</code> <code class= source >	n=n:		Number of timers to repeat the box filter.  Default</code> <code class= source >			is 5.</code>  nkernel<code class= source >	If set, this kernel is used to weight the replacement</code> <code class= source >			of all pixels in a box of size scale around each</code> <code class= source >			spike point, instead of replacing only the spike</code> <code class= source >			point.  If this is a scalar, then this is taken as the</code> <code class= source >			width of a Gaussian kernel.</code>  noclonedd<code class= source >	Data descriptor containing the image to be despiked.</code>  spike_ptd<code class= source >POINT specifying the points to replace;</code> <code class= source >			typically computed by pg_spikes.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/2004</code>  <code class= source >	Data descriptor containing the corrected image.  If /noclone</code> <code class= source >	is not set, set input data descriptor is modified.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_disk.html", "pg_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_disk.html#pg_disk", "pg_disk", 'routine in <a href="com/pg/pg_disk.html">pg_disk.pro</a>', "pg_disk.pro", "", "pg_disk", "<code class= source >	Computes image points on the inner and outer edges of each given disk</code> <code class= source >	object at all given time steps.</code>  ", "cd<code class= source > Array (n_timesteps) of camera descriptors.</code>  dkx<code class= source > Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		 which must be a subclass of DISK.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code> <code class= source >	inner/outer: If either of these keywords are set, then only</code> <code class= source >	             that edge is computed.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  clip<code class= source > If set points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  innerouternpoints<code class= source >Number of points to compute around each edge.  Default is</code> <code class= source >		 1000.</code>  reveal<code class= source > Normally, points computed for objects whose opaque flag</code> <code class= source >		 is set are made invisible.  /reveal suppresses this behavior.</code>  count<code class= source >Number of descriptors returned.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array (2*n_objects) of POINT containing image points and</code> <code class= source >	the corresponding inertial vectors.  The output array is arranged as</code> <code class= source >	[inner, outer, inner, outer, ...] in the order that the disk</code> <code class= source >	descriptors are given in the dkx argument.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_drag.html", "pg_drag.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_drag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_drag.html#pg_drag", "pg_drag", 'routine in <a href="com/pg/pg_drag.html">pg_drag.pro</a>', "pg_drag.pro", "", "pg_drag", "<code class= source >	Allows the user to graphically translate and rotate an array of points</code> <code class= source >	using the mouse.</code>  <code class= source >	cursor_move is used to perfform the drag.  See that routine for more</code> <code class= source >	detail.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_move</code>  ", "drawxor_graphics<code class= source >If set, grahics are drawn using the XOR function.</code>  dtheta<code class= source >	Dragged rotation in radians.</code>  axis_ptd<code class= source >POINT containing a single image point</code> <code class= source >			to be used as the axis of rotation.</code>  sample<code class= source >	Sampling interval for drag graphics.  The input</code> <code class= source >			points are subsampled at this interval so that the</code> <code class= source >			dragging can be done smoothly.  Default is 10.</code>  move<code class= source >	If set, object_ptd will be modified on return using</code> <code class= source >			pg_move.</code>  symbol<code class= source >	If set, the symbol number will be passed to cursor_move</code> <code class= source >			so something other than a period can be used to mark</code> <code class= source >			points.</code>  silent<code class= source >	If set, turns off the notification that cursor</code> <code class= source >                       movement is required.</code>  color<code class= source >	Drawing color.  Default is ctyellow.</code>  fndataobject_ptd<code class= source >Array (n_objects) of POINT containing the</code> <code class= source >			image points to be dragged.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code> <code class= source >      Modified by:     Dyer Lytle, Vance Haemmerle 11/1998</code>  <code class= source >	2-element array giving the drag translation as [dx,dy].</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_drag_shadow_plane.html", "pg_drag_shadow_plane.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_drag_shadow_plane.pro", "", "", "<code class= source >	Allows the user to graphically rotate a plane passing through the</code> <code class= source >	center of a planet by dragging the shadow cast by the planet on the</code> <code class= source >	plane using the mouse.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 2/2012</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_draw.html", "pg_draw.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw.html#pg_draw", "pg_draw", 'routine in <a href="com/pg/pg_draw.html">pg_draw.pro</a>', "pg_draw.pro", "", "pg_draw", "<code class= source >	Calls pg_draw_point or pg_draw_vector depending on the input arrays.</code> <code class= source >	pg_draw_point is called is only one argument is given.  Otherwise,</code> <code class= source >	it assumed that a source and target are given and pg_draw_vector is</code> <code class= source >	called.</code>  ", "literalcolorsshadespsymspsizesplabelsxormodecsizescthickswnumlabel_shadelabel_pointsthicklineprintcdgdcorientlengthsalignnoshortensolidfixedheadswinglengthgraphicslabel_colorshade_thresholdobject_ptd<code class= source >Array of POINT containing image points</code> <code class= source >			to be plotted in the current data coordinate system.</code> <code class= source >			Or inertial vectors to be used as vector sources.</code> <code class= source >			May also be an array of image points or inertial</code> <code class= source >			vectors.</code>  target_ptd<code class= source >Array of POINTs giving the inertial</code> <code class= source >			positions of vector targets.  May also be an</code> <code class= source >			array of inertial vectors.  If this argument is</code> <code class= source >			present, then vectors are drawn instead of points.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 9/2005</code>  <code class= source >	NONE</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_draw_point.html", "pg_draw_point.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw_point.pro", "", "", "<code class= source >	Draws points from the given POINT on the current graphics</code> <code class= source >	window using the current data coordinate system.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1/1998 (pg_draw)</code> <code class= source >	Renamed pg_draw_point: Spitale, 9/2005</code>  <code class= source >	The following command draws and labels a lavender 'limb' and a red</code> <code class= source >	'ring' (assuming that the points have already been computed):</code> <code class= source >	pg_draw_point, [limb_ptd, ring_ptd], color=[ctpurple(), ctred()], $</code> <code class= source >	         plabels=['LIMB','RING']</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> ");
  

libdata[libdataItem++] = new Array("com/pg/pg_draw_vector.html", "pg_draw_vector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_draw_vector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_draw_vector.html#pg_draw_vector", "pg_draw_vector", 'routine in <a href="com/pg/pg_draw_vector.html">pg_draw_vector.pro</a>', "pg_draw_vector.pro", "", "pg_draw_vector", "<code class= source >         Draws vectors on an image from a source towards a</code> <code class= source >         target. Very useful for locating off-image objects</code> <code class= source >         (planets, say) in an image for referencing.  By default,</code> <code class= source >         vectors are foreshortened to their projections onto the image</code> <code class= source >         plane so that vectors with large  out-of-plane components</code> <code class= source >         will be shorter.  (This can be deactivated with the</code> <code class= source >         /noshorten keyword.)  Also by default, vectors that point</code> <code class= source >         away from the camera will be drawn as dotted lines while</code> <code class= source >         vectors which point towards the camera will be drawn solid.</code> <code class= source >         (This can be controlled with the /solid keyword.)</code>  ", "cdddgdliteral<code class= source >All of the following input keywords accept an array</code> <code class= source >			where each element corresponds to an element in the</code> <code class= source >			object_ptd array.  By default, if the keyword array is</code> <code class= source >			shorter than the object_ptd array, then the last element</code> <code class= source >	  		is used to fill out the array.  /literal suppresses</code> <code class= source >			this behavior and causes unspecified elements to</code> <code class= source >			take their default values</code>  lengths<code class= source >       Lengths of the vectors.  (Default: 50 pixels)</code>  plabels<code class= source >        Text with which to label vectors.  (Default:</code> <code class= source >                       no label)</code>  colors<code class= source >        Colors to use in drawing.  (Default: current</code> <code class= source >                       default color)</code>  thick<code class= source >        Line thicknesses.  (Default: 1)</code>  csizes<code class= source >     Character sizes for plabels.  (Default: 1)</code>  wnumnoshorten<code class= source >    If set, vectors will not be foreshortened</code> <code class= source >                       depending on how much they point into/out</code> <code class= source >                       of the image plane.</code>  solid<code class= source >        All lines are to be drawn solid (linestyle=0)</code> <code class= source >                       rather than allow vectors pointing into the</code> <code class= source >                       image plane to be dotted.</code>  fixedheads<code class= source >    If set, arrowheads will not be scaled to</code> <code class= source >                        match the foreshortening of the vector.</code>  winglengthdraw_wnumshadeslabel_shadelabel_colorshade_thresholdsourcetarget", "NV/PG", "<code class= source >     Written: John W. Weiss, 5/05</code> <code class= source >     Consolidated some functionality into plot_arrow; Spitale 9/2005</code>  <code class= source >       Say moon_points is a POINT object containing the center</code> <code class= source >       data for the four Galilean satellites and jupiter_points has</code> <code class= source >       Jupiter's center data.  Then</code>        <span class= code-prompt >IDL&gt;</span> pg_draw_vector, moon_points, jupiter_points, colors=[100, $ <code class= source >             150, 200, 250], thick=1.25, length=70, plabels= Jupiter , $</code> <code class= source >             csizes=1.5</code> <code class= source >       will draw vectors from each towards the planet.  Conversely,</code>        <span class= code-prompt >IDL&gt;</span> pg_draw_vector, jupiter_points, moon_points, colors=[100, $ <code class= source >             150, 200, 250], thick=1.25, length=70, plabels=[ Io ,  Europa , $</code> <code class= source >              Ganymede ,  Callisto ], csizes=1.5</code> <code class= source >       will draw vectors from Jupiter's center towards each moon,</code> <code class= source >       labelling each by the moon's name.</code> ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_edges.html", "pg_edges.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_edges.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_edges.html#pg_edges", "pg_edges", 'routine in <a href="com/pg/pg_edges.html">pg_edges.pro</a>', "pg_edges.pro", "", "pg_edges", "<code class= source >	Scans an image for candidate edge points.</code>  <code class= source >	At each pixel in the image, an activity is computed (see activity.pro).</code> <code class= source >	Points with activity greater than the threshold value are accepted.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff, pg_ptchisq,</code> <code class= source >	pg_fit, pg_threshold</code>  ", "threshold<code class= source >Minimum activity to accept as an edge point.</code>  edge<code class= source >	Distance from the edge of the image within which</code> <code class= source >			curve points will not be scanned.  Default is 0.</code>  npoints<code class= source >Maximum number of points to return.</code>  gatelowpass<code class= source >If given, the image is smoothed with a kernel of</code> <code class= source >			this size.</code>  dd<code class= source >	Data descriptor</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 4/2002</code>  <code class= source >	POINT giving the resulting edge points.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_exclude_points.html", "pg_exclude_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_exclude_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_exclude_points.html#pg_exclude_points", "pg_exclude_points", 'routine in <a href="com/pg/pg_exclude_points.html">pg_exclude_points.pro</a>', "pg_exclude_points.pro", "", "pg_exclude_points", "<code class= source >	xx</code>  <code class= source >Environment variables: </code> <code class= source >	xx:	xx</code> <code class= source >	xx:	xx</code>  <code class= source >	xx:	xx</code> <code class= source >	xx:	xx</code>  <code class= source >	xx</code>  <code class= source >	xx</code>  <code class= source >	xx</code>  ", "radiusptdxptd", "NV/PG", "<code class= source > 	Written by:	xx, xx/xx/xxxx</code>  <code class= source >	xx</code> <code class= source > STATUS:</code> <code class= source >	xx</code> <code class= source > SEE ALSO:</code> <code class= source >	xx, xx, xx</code> <code class= source >	xx</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_farfit.html", "pg_farfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_farfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_farfit.html#pg_farfit", "pg_farfit", 'routine in <a href="com/pg/pg_farfit.html">pg_farfit.pro</a>', "pg_farfit.pro", "", "pg_farfit", "<code class= source >	Searches for the offset (dx,dy) that gives the best agreement between</code> <code class= source >	two uncorrelated sets of image points.</code>  <code class= source >	pg_farfit is a wrapper for the routine correlate_points.  See the</code> <code class= source >	documentation for that routine for details on the fitting procedure</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_edges correlate_points</code>  ", "nsamples<code class= source >Number of samples in each direction in the grid search.</code> <code class= source >			See image_correlate.</code>  show<code class= source >	If specified, the search is displayed in the current</code> <code class= source >			graphics window.  This value can be specified as a</code> <code class= source >			2-element array giving the size of the displayed image.</code>  bin<code class= source >	Initial bin size for point densities.  Default is 50</code> <code class= source >			pixels.</code>  max_density<code class= source >Maximum model point density.  Default = 5.</code>  region<code class= source >	Size of region to scan, centered at offset [0,0].  If not</code> <code class= source >			specified, the entire image is scanned.</code>  sigma<code class= source >	2-element array giving the width of the correlation</code> <code class= source >			peak in each direction.</code>  cc<code class= source >	Cross correlation of final result.</code>  mcc<code class= source >	Corss correlation at the model points.</code>  bias<code class= source >	If given, solutions are biased toward the initial</code> <code class= source >			guess using a weighting function of the form:</code> <code class= source >				exp(-r^2/2*bias),</code> <code class= source >			where r is the distance between from the initial</code> <code class= source >			guess.</code>  nosearch<code class= source >If set, no search is performed.  An offset of [0,0]</code> <code class= source >			is returned.</code>  dd<code class= source >	Data descriptor.</code>  base_ptd<code class= source >POINT giving a set of points to fit to.</code> <code class= source >			This input may be produced by pg_edges, for example.</code>  model_ptd<code class= source >Array of POINT giving model points (computed</code> <code class= source >			limb points for example).</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 4/2002</code>  <code class= source >	2-element array giving the fit offset as [dx,dy].</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_fit.html", "pg_fit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_fit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_fit.html#pg_fit", "pg_fit", 'routine in <a href="com/pg/pg_fit.html">pg_fit.pro</a>', "pg_fit.pro", "", "pg_fit", "<code class= source >	Performs a simultaneous 1-,2-, or 3-parameter linear least-squares fit</code> <code class= source >	using the given coefficients.</code>  <code class= source >	It is the caller's responsibility to ensure that all of the input</code> <code class= source >	coefficients were computed using with the same set of fixed parameters.</code>  <code class= source >	pg_fit extracts the fit coefficients from cf and inputs them to mbfit</code> <code class= source >	to perform a simultatneous least square fit using all of the</code> <code class= source >	coefficients.  See the documentation for that routine for more detail.</code>  ", "dthetacf<code class= source >Array of pg_fit_coeff_struct as produced by pg_cvscan_coeff or</code> <code class= source >		pg_ptscan_coeff.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	The following commands perform a simultaneous least square fit to</code> <code class= source >	a limb, ring and star field with all parameters free:</code> <code class= source >	cvscan_ptd = pg_cvscan(dd, [limb_ptd,ring_ptd], width=40, edge=20)</code> <code class= source >	ptscan_ptd = pg_ptscan(dd, [star_ptd], width=40, edge=20)</code> <code class= source >	cvscan_cf = pg_cvscan_coeff(cvscan_ptd, axis=center_ptd)</code> <code class= source >	ptscan_cf = pg_ptscan_coeff(ptscan_ptd, axis=center_ptd)</code> <code class= source >	dxy = pg_fit([cvscan_cf,ptscan_cf], dtheta=dtheta)</code> <code class= source >	In this example, center_ptd, limb_ptd, ring_ptd, and star_ptd are assumed</code> <code class= source >	to have been previously computed using the appropriate routines.</code> <code class= source >	Note that since this is a linear fit, the input systems may have been</code> <code class= source >	linearized and it may be necessary to iterate this procedure.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff,</code> <code class= source >	pg_cvchisq, pg_ptchisq, pg_threshold</code> <code class= source >	2-element array giving the fit offset as [dx,dy].</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_footprint.html", "pg_footprint.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_footprint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_footprint.html#pg_footprint", "pg_footprint", 'routine in <a href="com/pg/pg_footprint.html">pg_footprint.pro</a>', "pg_footprint.pro", "", "pg_footprint", "<code class= source >	Computes the footprint of a camera on a given body.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  bx<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  clip<code class= source > If set, points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  sample<code class= source > Sampling rate; default is 1 pixel.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 5/2014</code>  <code class= source >	Array (n_objects) of POINT containing image points and</code> <code class= source >	the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_arrays.html", "pg_get_arrays.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_arrays.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_arrays.html#pg_get_arrays", "pg_get_arrays", 'routine in <a href="com/pg/pg_get_arrays.html">pg_get_arrays.pro</a>', "pg_get_arrays.pro", "", "pg_get_arrays", "<code class= source >	Obtains a array descriptor for the given data descriptor.</code>  <code class= source >	If /override, then a array descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "odbxard<code class= source >	Input array descriptors; used by some translators.</code>  _extraoverride<code class= source >Create a data descriptor and initilaize with the</code> <code class= source >			given values.  Translators will not be called.</code>  verbatim<code class= source >If set, the descriptors requested using name</code> <code class= source >			are returned in the order requested.  Otherwise, the</code> <code class= source >			order is determined by the translators.</code>  count<code class= source >Number of descriptors returned</code>  arg1<code class= source >Data descriptor or transient translator argument.  In the</code> <code class= source >		latter case, a string containing keywords and values to be</code> <code class= source >		passed directly to the translators as if they appeared as</code> <code class= source >		arguments in the translators table.  Keywords passed using</code> <code class= source >		this mechanism take precedence over keywords appearing in</code> <code class= source >		the translators table.  If no data descriptor is given,</code> <code class= source >		one may be constructed using DATA keywords (see below).  The</code> <code class= source >		newly created data descriptor is freed unless this argument</code> <code class= source >		is an undefined named variable, in which case the new</code> <code class= source >		descriptor is returned in this variable.</code>  arg2<code class= source >Transient translator argument, if present.</code>  @arr__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 10/2012</code>  <code class= source >	Array of array descriptors, 0 if an error occurs.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_cameras.html", "pg_get_cameras.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_cameras.html#pg_get_cameras", "pg_get_cameras", 'routine in <a href="com/pg/pg_get_cameras.html">pg_get_cameras.pro</a>', "pg_get_cameras.pro", "", "pg_get_cameras", "<code class= source >	Obtains a camera descriptor for the given data descriptor.</code>  <code class= source >	If /override, then a camera descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except cam_name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If cam_name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "cd<code class= source >	Input camera descriptors; used by some translators.</code>  odpd_extraoverride<code class= source >Create a data descriptor and initilaize with the</code> <code class= source >			given values.  Translators will not be called.</code>  verbatim<code class= source >If set, the descriptors requested using cam_name</code> <code class= source >			are returned in the order requested.  Otherwise, the</code> <code class= source >			order is determined by the translators.</code>  default_orient<code class= source >Default orientation matrix to use if camera</code> <code class= source >			orientation is not available.  If not specified,</code> <code class= source >			the identity matrix is used.</code> <code class= source >	CAMERA Keywords</code> <code class= source >	---------------</code> <code class= source >	All CAMERA override keywords are accepted.  See cam__keywords.include.</code> <code class= source >	If 'name' is specified, then only descriptors with those names are</code> <code class= source >	returned.</code> <code class= source >	DATA Keywords</code> <code class= source >	-------------</code> <code class= source >	All DATA override keywords are accepted.  See dat__keywords.include.</code>  no_defaultcount<code class= source >Number of descriptors returned</code>  arg1<code class= source >Data descriptor or transient translator argument.  In the</code> <code class= source >		latter case, a string containing keywords and values to be</code> <code class= source >		passed directly to the translators as if they appeared as</code> <code class= source >		arguments in the translators table.  Keywords passed using</code> <code class= source >		this mechanism take precedence over keywords appearing in</code> <code class= source >		the translators table.  If no data descriptor is given,</code> <code class= source >		one may be constructed using DATA keywords (see below).  The</code> <code class= source >		newly created data descriptor is freed unless this argument</code> <code class= source >		is an undefined named variable, in which case the new</code> <code class= source >		descriptor is returned in this variable.</code>  arg2<code class= source >Transient translator argument, if present.</code>  @cam__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code> <code class= source >	Modified:	Spitale, 8/2001</code>  <code class= source >	Array of camera descriptors, 0 if an error occurs.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_celestial_sphere.html", "pg_get_celestial_sphere.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_celestial_sphere.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_celestial_sphere.html#pg_get_celestial_sphere", "pg_get_celestial_sphere", 'routine in <a href="com/pg/pg_get_celestial_sphere.html">pg_get_celestial_sphere.pro</a>', "pg_get_celestial_sphere.pro", "", "pg_get_celestial_sphere", "<code class= source >	Obtains a globe descriptor describing the celestial sphere.</code>  ", "radius<code class= source > Radius to use for the globe.  Default is 1d30.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 7/2015</code>  <code class= source >	Globe descriptor with inertial body descriptor and very large radii.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_maps.html", "pg_get_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_maps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_maps.html#pg_get_maps", "pg_get_maps", 'routine in <a href="com/pg/pg_get_maps.html">pg_get_maps.pro</a>', "pg_get_maps.pro", "", "pg_get_maps", "<code class= source >	Obtains a map descriptor for the given data descriptor.</code>  <code class= source >	If /override, then a map descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "md<code class= source >	Input map descriptors; used by some translators.</code>  gbxdkxbx_extraoverride<code class= source >Create a data descriptor and initilaize with the</code> <code class= source >			given values.  Translators will not be called.</code>  verbatim<code class= source >If set, the descriptors requested using name</code> <code class= source >			are returned in the order requested.  Otherwise, the</code> <code class= source >			order is determined by the translators.</code>  count<code class= source >Number of descriptors returned</code>  arg1<code class= source >Data descriptor or transient translator argument.  In the</code> <code class= source >		latter case, a string containing keywords and values to be</code> <code class= source >		passed directly to the translators as if they appeared as</code> <code class= source >		arguments in the translators table.  Keywords passed using</code> <code class= source >		this mechanism take precedence over keywords appearing in</code> <code class= source >		the translators table.  If no data descriptor is given,</code> <code class= source >		one may be constructed using DATA keywords (see below).  The</code> <code class= source >		newly created data descriptor is freed unless this argument</code> <code class= source >		is an undefined named variable, in which case the new</code> <code class= source >		descriptor is returned in this variable.</code>  arg2<code class= source >Transient translator argument, if present.</code>  @map__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code> <code class= source >	Modified:	Spitale, 8/2001</code>  <code class= source >	Array of map descriptors, 0 if an error occurs.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_planets.html", "pg_get_planets.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_planets.pro", "", "", "<code class= source >	Obtains planet descriptors for the given data descriptor.</code>  <code class= source >	If /override, then a planet descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1998</code> <code class= source >	Modified:	Spitale, 8/2001</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_rings.html", "pg_get_rings.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_rings.pro", "", "", "<code class= source >	Obtains ring descriptors for the given data descriptor.</code>  <code class= source >	If /override, then a ring descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1998</code> <code class= source >	Modified:	Spitale, 8/2001</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_sky.html", "pg_get_sky.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_sky.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_sky.html#pg_get_sky", "pg_get_sky", 'routine in <a href="com/pg/pg_get_sky.html">pg_get_sky.pro</a>', "pg_get_sky.pro", "", "pg_get_sky", "<code class= source >	Obtains a globe descriptor describing the sky.</code>  ", "radius<code class= source > Radius to use for the globe.  Default is 15 billion light years.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 7/2015</code>  <code class= source >	Globe descriptor with inertial body descriptor and very large radius.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_get_stars.html", "pg_get_stars.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_stars.pro", "", "", "<code class= source >	Obtain star descriptors for the given data descriptor.</code>  <code class= source >	If /override, then a star descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 1998</code> <code class= source >	Modified:	Spitale, 8/2001</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_get_stations.html", "pg_get_stations.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_get_stations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_get_stations.html#pg_get_stations", "pg_get_stations", 'routine in <a href="com/pg/pg_get_stations.html">pg_get_stations.pro</a>', "pg_get_stations.pro", "", "pg_get_stations", "<code class= source >	Obtains a station descriptor for the given data descriptor.</code>  <code class= source >	If /override, then a station descriptor is created and initialized</code> <code class= source >	using the specified values.  Otherwise, the descriptor is obtained</code> <code class= source >	through the translators.  Note that if /override is not used,</code> <code class= source >	values (except name) can still be overridden by specifying</code> <code class= source >	them as keyword parameters.  If name is specified, then</code> <code class= source >	only descriptors corresponding to those names will be returned.</code>  ", "odbxstd<code class= source >	Input station descriptors; used by some translators.</code>  _extraoverride<code class= source >Create a data descriptor and initilaize with the</code> <code class= source >			given values.  Translators will not be called.</code>  verbatim<code class= source >If set, the descriptors requested using name</code> <code class= source >			are returned in the order requested.  Otherwise, the</code> <code class= source >			order is determined by the translators.</code>  count<code class= source >Number of descriptors returned</code>  arg1<code class= source >Data descriptor or transient translator argument.  In the</code> <code class= source >		latter case, a string containing keywords and values to be</code> <code class= source >		passed directly to the translators as if they appeared as</code> <code class= source >		arguments in the translators table.  Keywords passed using</code> <code class= source >		this mechanism take precedence over keywords appearing in</code> <code class= source >		the translators table.  If no data descriptor is given,</code> <code class= source >		one may be constructed using DATA keywords (see below).  The</code> <code class= source >		newly created data descriptor is freed unless this argument</code> <code class= source >		is an undefined named variable, in which case the new</code> <code class= source >		descriptor is returned in this variable.</code>  arg2<code class= source >Transient translator argument, if present.</code>  @stn__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/2009</code>  <code class= source >	Array of station descriptors, 0 if an error occurs.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_grid.html", "pg_grid.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_grid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_grid.html#pg_grid", "pg_grid", 'routine in <a href="com/pg/pg_grid.html">pg_grid.pro</a>', "pg_grid.pro", "", "pg_grid", "<code class= source >	Computes image points on a surface coordinate grid.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  gbx<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of GLOBE.</code>  dkx<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of DISK.</code>  bx<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of BODY.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  lat<code class= source >Array giving grid-line latitudes in radians.</code>  lon<code class= source >Array giving grid-line longitudes in radians.</code>  nlat<code class= source >Number of equally-spaced latitude lines to generate if keyword</code> <code class= source >		lat not given.  Default is 12.</code>  nlon<code class= source >Number of equally-spaced longitude lines to generate if keyword</code> <code class= source >		lon not given.  Default is 12.</code>  flat<code class= source >This reference latitude line will be one of the latitude lines generated</code> <code class= source >		if nlat is specified.  Default is zero.</code>  flon<code class= source >This reference longitude line will be one of the longitude lines generated</code> <code class= source >		if nlon is specified.  Default is zero.</code>  npoints<code class= source >Number of points to compute in each latitude or longitude line,</code> <code class= source >		 per 2*pi radians; default is 360.</code>  clip<code class= source > If set points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  slat<code class= source >Latitudes to compute on each longitude circle.</code>  slon<code class= source >Longitudes to compute on each latitude circle.</code>  count<code class= source >Number of descriptors returned.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array of POINT containing image points and the corresponding inertial</code> <code class= source >	vectors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_hide.html", "pg_hide.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_hide.pro", "", "", "<code class= source >	Hides the given points with respect to each given object and observer</code> <code class= source >	using the hide methods of the given bodies.</code>  <code class= source >	The flags arrays in point_ptd are modified.</code>  <code class= source >	For each object in point_ptd, hidden points are computed and</code> <code class= source >	PTD_MASK_INVISIBLE in the POINT is set.  No points are</code> <code class= source >	removed from the array.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 3/2017, generalized pg_hide_globe and pg_hide_disk</code>  <code class= source >	The following command hides all points which are behind a planet as</code> <code class= source >	seen by the camera:</code> <code class= source >	pg_hide, point_ptd, cd=cd, bx=pd</code> <code class= source >	In this call, pd is a planet descriptor, and cd is a camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_hide_limb</code> ");
  

libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html", "pg_image_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_image_sector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_image_sector.html#pg_image_sector", "pg_image_sector", 'routine in <a href="com/pg/pg_image_sector.html">pg_image_sector.pro</a>', "pg_image_sector.pro", "", "pg_image_sector", "<code class= source >	Allows the user to select a rectangular image region, with an</code> <code class= source >	arbitrary tilt, by clicking and dragging.  A rectangle is selected</code> <code class= source >	using the left mouse button and a line of zero width is selected</code> <code class= source >	using the right moise button.</code>  ", "sample<code class= source >    Pixel grid sampling to use instead of 1.</code>  win_num<code class= source >    Window number of IDL graphics window in which to select</code> <code class= source >                   box, default is current window.</code>  width<code class= source >    Width of box instead of letting the user select.</code>  restore<code class= source >    Do not leave the box in the image.</code>  p0<code class= source >    First corner of box.  If set, then the routine immediately</code> <code class= source >                   begins to drag from that point until a button is released.</code>  p1<code class= source >    Endpoint.  If given, p0 must also be given and is taken</code> <code class= source >                   as the starting point for a line along which to scan.</code> <code class= source >                   In this case, the user does not select the box manually.</code> <code class= source >                   Scan width is one pixel unless 'width' is specified,</code> <code class= source >                   and is centered on the line from p0 to p1.</code>  xor_graphics<code class= source >    If set, the sector outline is drawn and erased using xor</code> <code class= source >                   graphics instead of a pixmap.</code>  color<code class= source >    Color to use for rectangle, default is !color.</code>  silent<code class= source >    If set, messages are suppressed.</code>  corners<code class= source >    If set, then p0 and p1 are taken as the corners of</code> <code class= source >                   the box, and the user is not prompted to select one.</code>  ", "NV/PG", "<code class= source >      POINT containing points on the sector outline.  The point</code> <code class= source >      spacing is determined by the sample keyword.</code> <code class= source > ORIGINAL AUTHOR : J. Spitale ; 6/2005</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb.html", "pg_limb.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb.html#pg_limb", "pg_limb", 'routine in <a href="com/pg/pg_limb.html">pg_limb.pro</a>', "pg_limb.pro", "", "pg_limb", "<code class= source >	Computes image points on the limb of each given globe object.</code>  <code class= source >	By definition, the surface normal at a point on the limb of a body is</code> <code class= source >	perpendicular to a vector from the observer to that same point, so the</code> <code class= source >	dot product of the two vectors is zero.  This program uses an iterative</code> <code class= source >	scheme to find points onthe surface at which this dot product is less</code> <code class= source >	than epsilon.</code>  ", "cd<code class= source > Array (n_timesteps) of camera descriptors.</code>  od<code class= source > Array (n_timesteps) of descriptors of objects</code> <code class= source >		 which must be a subclass of BODY.  These objects are used</code> <code class= source >		 as the observer from which limb is computed.  If no observer</code> <code class= source >		 descriptor is given, the camera descriptor is used.</code>  gbx<code class= source > Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		 which must be a subclass of GLOBE.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  clip<code class= source > If set points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  npoints<code class= source >Number of points to compute.  Default is 1000.</code>  epsilon<code class= source >Maximum angular error in the result.  Default is 1e-3.</code>  reveal<code class= source > Normally, points computed for objects whose opaque flag</code> <code class= source >		 is set are made invisible.  /reveal suppresses this behavior.</code>  count<code class= source >Number of descriptors returned.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	The following command computes points on the planet which lie on the</code> <code class= source >	terminator:</code> <code class= source >	term_ptd = pg_limb,(cd=cd, gbx=pd, od=sd)</code> <code class= source >	In this call, pd is a planet descriptor, cd is a camera descriptor,</code> <code class= source >	and sd is a star descriptor (i.e., the sun).</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source >	Array (n_objects) of POINT containing image</code> <code class= source >	points and the corresponding inertial vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector.html", "pg_limb_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector.html#pg_limb_sector", "pg_limb_sector", 'routine in <a href="com/pg/pg_limb_sector.html">pg_limb_sector.pro</a>', "pg_limb_sector.pro", "", "pg_limb_sector", "<code class= source >	Allows the user to select an image sector along lines of constant</code> <code class= source > 	azimuth and altitude above a planet by clicking and dragging.</code>  ", "cd<code class= source >    Camera descriptor.</code>  gbx<code class= source >    Globe descriptor for the planet whose limb is to be</code> <code class= source >                   scanned.</code>  gd<code class= source >    Generic descriptor containnig the above descriptors.</code>  lonsample<code class= source >    Sets the grid sampling in pixels.  Default is one.</code>  win_num<code class= source >    Window number of IDL graphics window in which to select</code> <code class= source >                   box, default is current window.</code>  restore<code class= source >    Do not leave the box in the image.</code>  p0<code class= source >    First corner of box.  If set, then the routine immediately</code> <code class= source >                   begins to drag from that point until a button is released.</code>  xor_graphics<code class= source >    If set, the sector outline is drawn and erased using xor</code> <code class= source >                   graphics instead of a pixmap.</code>  color<code class= source >    Color to use for rectangle, default is !color.</code>  silent<code class= source >    If set, messages are suppressed.</code>  nodsk<code class= source >    If set, skyplane disk image points will not be included</code> <code class= source >                   in the output POINT.</code>  dkd<code class= source >     Disk desriptor in the skyplane, centered on the planet</code> <code class= source >                   with 0 axis along the skyplane projection of the north</code> <code class= source >                   pole.  For use with pg_profile_ring.</code>  altitudes<code class= source >Array giving altitude at each sample.</code>  azimuths<code class= source >Array giving azimuth at each sample.</code>  limb_pts_body<code class= source >Body coordinates of each limb points on planet surface.</code>  cw<code class= source >    If set, azimuths are assumed to increase in the clockwise</code> <code class= source >                   direction.</code>  ", "NV/PG", "<code class= source >      POINT containing points on the sector outline.  The point</code> <code class= source >      spacing is determined by the sample keyword.  The POINT object</code> <code class= source >      also contains the disk coordinate for each point, relative to the</code> <code class= source >      returned disk descriptor, and the user fields 'nrad' and 'nlon'</code> <code class= source >      giving the number of points in altitude and azimuth.</code> <code class= source > KNOWN BUGS:</code> <code class= source >	The sector flips when it hits zero azimuth rather than retaining a</code> <code class= source >	consistent sense.</code> <code class= source > MODIFICATION HISTORY :</code> <code class= source >	Spitale; 8/2006		original version</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_altaz.html", "pg_limb_sector_altaz.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_altaz.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_altaz.html#pg_limb_sector_altaz", "pg_limb_sector_altaz", 'routine in <a href="com/pg/pg_limb_sector_altaz.html">pg_limb_sector_altaz.pro</a>', "pg_limb_sector_altaz.pro", "", "pg_limb_sector_altaz", "<code class= source >	Constructs a limb sector outline for use with pg_profile_ring given</code> <code class= source >	altitude and azimuth bounds.</code>  ", "cd<code class= source >    Camera descriptor.</code>  gbx<code class= source >    Globe descriptor giving the planet about whose limb</code> <code class= source >                   the scan will be extracted.</code>  gd<code class= source >    Generic descriptor containing the above descriptors.</code>  dkd<code class= source >    Disk descriptor in the skyplane, centered on the planet</code> <code class= source >                   with 0 axis along the skyplane projection of the north</code> <code class= source >                   pole.  For use with pg_profile_ring.</code>  sample<code class= source >    Sets the grid sampling in pixels.  Default is one.</code>  nodsk<code class= source >    If set, skyplane disk image points will not be included</code> <code class= source >                   in the output POINT.</code>  altitudes<code class= source >Array giving altitude at each sample.</code>  azimuths<code class= source >Array giving azimuth at each sample.</code>  limb_pts_body<code class= source >Body coordinates of each limb points on planet surface.</code>  cw<code class= source >    If set, azimuths are assumed to increase in the clockwise</code> <code class= source >                   direction.</code>  naz<code class= source >    Total number of samples in the azimuthal direction.</code> <code class= source >                   Determined by the 'sample' keyword by default.</code>  nalt<code class= source >    Total number of samples in the altitude direction.</code> <code class= source >                   Determined by the 'sample' keyword by default.</code>  graphic<code class= source >    If set, the sector is computed in the planetographic</code> <code class= source >                   sense, i.e., lines of constant azimuth extend along</code> <code class= source >                   the local surface normal direction instead of the radial</code> <code class= source >                   direction.</code>  alt<code class= source >2-elements array giving the lower and upper altitude bounds</code> <code class= source >		for the sector.</code>  _az<code class= source >2-elements array giving the lower and upper azimuth bounds</code> <code class= source >		for the sector in radians, reliative to the skyplane</code> <code class= source >		projection of the planet's north pole.</code>  ", "NV/PG", "<code class= source >      POINT containing points on the sector outline.  The point</code> <code class= source >      spacing is determined by the sample keyword.  The POINT objects</code> <code class= source >      also contains the disk coordinate for each point, relative to the</code> <code class= source >      returned disk descriptor, and the user fields 'nrad' and 'nlon'</code> <code class= source >      giving the number of points in altitude and azimuth.</code> <code class= source > KNOWN BUGS:</code> <code class= source >	The sector flips when it hits zero azimuth rather than retaining a</code> <code class= source >	consistent sense.</code> <code class= source > ORIGINAL AUTHOR :</code> <code class= source >	Spitale; 8/2006</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_linear.html", "pg_limb_sector_linear.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_linear.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_linear.html#pg_limb_sector_linear", "pg_limb_sector_linear", 'routine in <a href="com/pg/pg_limb_sector_linear.html">pg_limb_sector_linear.pro</a>', "pg_limb_sector_linear.pro", "", "pg_limb_sector_linear", "<code class= source >	Constructs a limb sector outline for use with pg_profile_image, given</code> <code class= source >	altitude and length bounds.  The sector is rectangular, being tangent</code> <code class= source >	to the limb at a given azimuth.</code>  ", "cd<code class= source >    Camera descriptor.</code>  gbx<code class= source >    Globe descriptor giving the planet about whose limb</code> <code class= source >                   the scan will be extracted.</code>  gd<code class= source >    Generic descriptor containig the above descriptors.</code>  sample<code class= source >    Sets the grid sampling in pixels.  Default is one.</code>  altitudes<code class= source >Array giving altitude at each sample.</code>  rims<code class= source >Array giving azimuth at each sample.</code>  nrim<code class= source >    Total number of samples in the scan direction.</code> <code class= source >                   Determined by the 'sample' keyword by default.</code>  nalt<code class= source >    Total number of samples in the altitude direction.</code> <code class= source >                   Determined by the 'sample' keyword by default.</code>  graphic<code class= source >    If set, the sector is computed in the planetographic</code> <code class= source >                   sense, i.e., lines of constant azimuth extend along</code> <code class= source >                   the local surface normal direction instead of the radial</code> <code class= source >                   direction.</code>  alt<code class= source >2-elements array giving the lower and upper altitude bounds</code> <code class= source >		for the sector.</code>  _rim<code class= source >2-element array giving the image-coordinate cylidrical coordinates</code> <code class= source >		of the the ends of the sector.</code>  az0<code class= source >Azimuth of the sector tangent point.</code>  ", "NV/PG", "<code class= source >      POINT object containing points on the sector outline.  The point</code> <code class= source >      spacing is determined by the sample keyword.  The POINT object</code> <code class= source >      also contains the user fields 'nl' and 'nw' giving the number of points</code> <code class= source >      in altitude and r.</code> <code class= source > KNOWN BUGS:</code> <code class= source >	The sector flips when it hits zero azimuth rather than retaining a</code> <code class= source >	consistent sense.</code> <code class= source > ORIGINAL AUTHOR :</code> <code class= source >	Spitale; 1/2009</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_limb_sector_oblique.html", "pg_limb_sector_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_limb_sector_oblique.pro", "", "", "<code class= source >	Allows the user to select an image sector along lines of constant</code> <code class= source > 	azimuth and altitude above a planet by clicking and dragging.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_linearize_image.html", "pg_linearize_image.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_linearize_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_linearize_image.html#pg_linearize_image", "pg_linearize_image", 'routine in <a href="com/pg/pg_linearize_image.html">pg_linearize_image.pro</a>', "pg_linearize_image.pro", "", "pg_linearize_image", "<code class= source >	Reprojects an image onto a linear scale.</code>  <code class= source >	The input image is divided into pieces and tranformed one piece at</code> <code class= source >	a time.  There are two modes of operation: If nmp and scp are</code> <code class= source >	given, then the image is transformed using them as control points.</code> <code class= source >	Otherwise, the image is transformed using whatever camera transformation</code> <code class= source >	is specified in the camera descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Control-point scheme not yet implemented.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_resfit, pg_resloc</code>  ", "cd<code class= source >Camera descriptor describing the image to be reprojected.</code>  gd<code class= source >Generic descriptor containing the above descriptor.</code>  fcp<code class= source >Focal coordinates of known reseau locations.</code>  scp<code class= source >Image coordinates in input image of detected reseau marks</code> <code class= source >		corresponding to those given by nmp.</code>  scale<code class= source >2-element array giving the camera scale (radians/pixel)</code> <code class= source >		in each direction for the reprojected image.  If not given, the</code> <code class= source >		scale of the input image is used.</code>  oaxis<code class= source >2-element array giving the image coordinates of the optic axis</code> <code class= source >		in the reprojected image.  If not given, the center of</code> <code class= source >		the reprojected image is used.</code>  size<code class= source >2-element array giving the size of the reprojected image.  If</code> <code class= source >		not given, the size of the input image is used.</code>  pc_xsize<code class= source >Y-Size of each image piece.  Default is 200 pixels.</code>  pc_ysizeimage<code class= source >The output image, which is also placed in the data descriptor.</code>  interp<code class= source >Type of interpolation to use.  Options are:</code> <code class= source >		'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.</code>  dd<code class= source >Data descriptor containing image to be reprojected.</code>  new_cd", "NV/PG", "<code class= source > 	Written by:	Spitale, 5/2002</code>  <code class= source >	Data descriptor containing the reprojected image.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_load_maps.html", "pg_load_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_load_maps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_load_maps.html#pg_load_maps", "pg_load_maps", 'routine in <a href="com/pg/pg_load_maps.html">pg_load_maps.pro</a>', "pg_load_maps.pro", "", "pg_load_maps", "<code class= source >	Loads maps and descriptors from a map directory.</code>  <code class= source >Environment variables: </code> <code class= source >	PG_MAPS:</code> <code class= source >		Sets the map directory; overrides the dir keyword.  Maps are</code> <code class= source >		organized into subdirectories named for each body.</code>   ", "md<code class= source >Map descriptor for each map.</code>  bx<code class= source >Body descriptors indicating which maps to load.</code>  ddprojection<code class= source >		If set, only maps with this projection will be returned.</code>  mapdir", "NV/PG", "<code class= source > 	Written by:	Spitale  7/2015</code>  <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source >	Data descriptor containing the rendered image.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_map.html", "pg_map.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_map.html#pg_map", "pg_map", 'routine in <a href="com/pg/pg_map.html">pg_map.pro</a>', "pg_map.pro", "", "pg_map", "<code class= source >	Generates map projections.</code>  ", "md<code class= source >Map descriptor describing the projection.</code>  cd<code class= source >Camera descriptor describing the image to be projected.</code>  bx<code class= source >Subclass of BODY giving the body to be projected.  Can be</code> <code class= source >		GLOBE or RING.  Only bodies whose names match that in the</code> <code class= source >		map descriptor are mapped.</code>  gbx<code class= source >Globe descriptor describing the body to be projected.</code> <code class= source >		This argument is kept for compatibility with earlier</code> <code class= source >		code.  It is recommended that you use the 'bx' argument</code> <code class= source >		instead.</code>  dkx<code class= source >Disk descriptor describing the body to be projected.</code> <code class= source >		This argument is kept for compatibility with earlier</code> <code class= source >		code.  It is recommended that you use the 'bx' argument</code> <code class= source >		instead.</code>  ltd<code class= source >Star descriptor for a light source.  If given, points behind the</code> <code class= source >		terminator are excluded.</code>  gd<code class= source >Generic descriptor.  If given, the above descriptor inputs</code> <code class= source >		are taken from the corresponding fields of this structure</code> <code class= source >		instead of from those keywords.</code>  hide_fn<code class= source >		String giving the name of a function whose purpose</code> <code class= source >		is to exclude hidden points from the map.  Options are:</code> <code class= source >		   pm_hide_ring</code> <code class= source >		   pm_hide_globe</code> <code class= source >		   pm_rm_globe_shadow</code> <code class= source >		   pm_rm_globe</code>  hide_bx<code class= source >		Array of BODY objects for the hide functions; one per</code> <code class= source >		function.</code>  map<code class= source >For convenience, the generated map is returned here as</code> <code class= source >		well as in the returned data descriptor.</code>  aux_names<code class= source >		Array (naux) giving udata names for additional data</code> <code class= source >		descriptor planes to reproject.  The dimensions of these</code> <code class= source >		planes must be the same as the image.</code> <code class= source >	pc_xsize, pc_ysize:</code> <code class= source >		The map is generated in pieces of size pc_xsize</code> <code class= source >		x pc_ysize.   Default is 100 x 100 pixels.</code>  pc_xsizepc_ysizebounds<code class= source >		Projection bounds specified as [lat0, lat1, lon0, lon1].</code>  interp<code class= source >Type of interpolation, see image_interp_cam.</code>  arg_interp<code class= source >Interpolation argument, see image_interp_cam.</code>  offset<code class= source >Offset in [lat,lon] to apply to map coordinates before</code> <code class= source >		projecting.</code>  edge<code class= source >Minimum proximity to image edge.  Default is 0.</code>  shear_fnshear_datasmooth<code class= source >If set, the input image is smoothed before reprojection.</code>  roi<code class= source >Subscripts in the output map specifying the map region</code> <code class= source >		to project, instead of the whole thing.</code>  test_factor<code class= source >If set, a test map, reduced in size by this factor,</code> <code class= source >			is projected to determine the roi.  For maps with</code> <code class= source >			large blank areas, this may speed up the projection</code> <code class= source >			greatly.</code>  dd<code class= source >Data descriptor containing image to be projected.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code> <code class= source >	Modified:	Daiana DiNino; 7, 2011 : test_factor</code>  <code class= source >	Data descriptor containing the output map.  The instrument field is set</code> <code class= source >	to 'MAP'.  User data arrays are created for the reprojected aux_names</code> <code class= source >	arrays.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_mosaic</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_mask.html", "pg_mask.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mask.pro", "", "", "<code class= source >	Uses the given geometry to compute an image mask for all objects</code> <code class= source >	in a scene.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 4/2004</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_measure.html", "pg_measure.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_measure.pro", "", "", "<code class= source >	Allows the user to measure quantities between two points in an</code> <code class= source >	image using the mouse in the current graphics window.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 3/2002</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_mosaic.html", "pg_mosaic.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_mosaic.pro", "", "", "<code class= source >	Combines two or more maps into one.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale 1/2002</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_move.html", "pg_move.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_move.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_move.html#pg_move", "pg_move", 'routine in <a href="com/pg/pg_move.html">pg_move.pro</a>', "pg_move.pro", "", "pg_move", "<code class= source >	Translates and rotates the given points.</code>  ", "axis_ptd<code class= source >POINT containing a single image point</code> <code class= source >			to be used as the axis of rotation.</code>  object_ptd<code class= source >Array (n_objects) of POINT containing the</code> <code class= source >			image points to be moved.</code>  dxy<code class= source >	2-element array specifying the translation as [dx,dy].</code>  dtheta<code class= source >	Rotation angle in radians.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	object_ptd:	The input points are be modified on return.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_nearest_points.html", "pg_nearest_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_nearest_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_nearest_points.html#pg_nearest_points", "pg_nearest_points", 'routine in <a href="com/pg/pg_nearest_points.html">pg_nearest_points.pro</a>', "pg_nearest_points.pro", "", "pg_nearest_points", "<code class= source >	xx</code>  <code class= source >Environment variables: </code> <code class= source >	xx:	xx</code> <code class= source >	xx:	xx</code>  <code class= source >	xx:	xx</code> <code class= source >	xx:	xx</code>  <code class= source >	xx</code>  <code class= source >	xx</code>  <code class= source >	xx</code>  ", "object_ptd_ptd", "NV/PG", "<code class= source > 	Written by:	xx, xx/xx/xxxx</code>  <code class= source >	xx</code> <code class= source > STATUS:</code> <code class= source >	xx</code> <code class= source > SEE ALSO:</code> <code class= source >	xx, xx, xx</code> <code class= source >	xx</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_northangle.html", "pg_northangle.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_northangle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_northangle.html#pg_northangle", "pg_northangle", 'routine in <a href="com/pg/pg_northangle.html">pg_northangle.pro</a>', "pg_northangle.pro", "", "pg_northangle", "<code class= source >	Computes the angle between the image-coordinate y-axis and the</code> <code class= source >	projected z-axis of the given body.  Increasing angle corresponds to</code> <code class= source >	clockwise rotation in the image.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  bx<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 11/2001</code>  <code class= source >	Array (n_objects) of double giving the northangles in radians.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_occult_points.html", "pg_occult_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_occult_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_occult_points.html#pg_occult_points", "pg_occult_points", 'routine in <a href="com/pg/pg_occult_points.html">pg_occult_points.pro</a>', "pg_occult_points.pro", "", "pg_occult_points", "<code class= source >	Determines whether each given point is occulted by the given object</code> <code class= source >	relative to the given observer.</code>  <code class= source >	Occulted points are flagged as invisible.</code> <code class= source > STATUS: Complete</code>  ", "od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the light descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  bx<code class= source >Array (nbx, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY describing the occulting</code> <code class= source >		bodies.</code>  gd<code class= source >Generic descriptor.  If given, the od and bx inputs</code> <code class= source >		are taken from the corresponding fields of this structure</code> <code class= source >		instead of from those keywords.</code>  object_ptd<code class= source >Array of POINT containing inertial vectors</code> <code class= source >			to occult.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 9/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom.html", "pg_photom.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom.html#pg_photom", "pg_photom", 'routine in <a href="com/pg/pg_photom.html">pg_photom.pro</a>', "pg_photom.pro", "", "pg_photom", "<code class= source >	Photometric image correction for disk or globe objects.</code>  ", "outline_ptd<code class= source >POINT with image points outlining the</code> <code class= source >			region of the image to correct.  To correct the entire</code> <code class= source >			planet, this input could be generated using pg_limb().</code> <code class= source >			If this keyword is not given, the entire image is used.</code>  cd<code class= source >Camera descriptor</code>  gbx<code class= source >Globe descriptor</code>  dkx<code class= source >Disk descriptor</code>  ltd<code class= source >Sun descriptor</code>  gd<code class= source >Generic descriptor.  If present, cd, dkx, and gbx are taken</code> <code class= source >		from here if contained.</code>  refl_fn<code class= source >String naming reflectance function to use.  Default is</code> <code class= source >			'pht_minneart'.</code>  phase_fn<code class= source >String naming phase function to use.  Default is none.</code>  refl_parmphase_parmemm_out<code class= source >Image emission angles.</code>  inc_out<code class= source >Image incidence angles.</code>  phase_out<code class= source >Image phase angles.</code>  overwrite<code class= source >If set, the output descriptor is the input descriptor</code> <code class= source >			with the relevant fields modified.</code>  dd<code class= source >Data descriptor containing image to correct.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 6/2004</code>  <code class= source >	Data descriptor containing the corrected image.  The photometric angles</code> <code class= source >	emm, inc, and phase are placed in the user data arrays with the tags</code> <code class= source >	'EMM', 'INC', and 'PHASE' respectively.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom_disk.html", "pg_photom_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom_disk.html#pg_photom_disk", "pg_photom_disk", 'routine in <a href="com/pg/pg_photom_disk.html">pg_photom_disk.pro</a>', "pg_photom_disk.pro", "", "pg_photom_disk", "<code class= source >	Photometric image correction for disk objects.</code>  ", "outline_ptd<code class= source >POINT with image points outlining the</code> <code class= source >			region of the image to correct.  To correct the entire</code> <code class= source >			disk, this input could be generated using pg_ring().</code> <code class= source >			If this keyword is not given, the entire image is used.</code> <code class= source >			If two arrays are given, they are taken as the inner</code> <code class= source >			and outer boundaries.</code>  cd<code class= source >Camera descriptor</code>  dkx<code class= source >Disk descriptor</code>  ltd<code class= source >Light descriptor</code>  gd<code class= source >Generic descriptor.  If present, cd and dkx are taken from</code> <code class= source >		here if contained.</code>  refl_fn<code class= source >String naming reflectance function to use.  Default is</code> <code class= source >			'pht_minneart'.</code>  phase_fn<code class= source >String naming phase function to use.  Default is none.</code>  refl_parmphase_parmemm_out<code class= source >Image emission angles.</code>  inc_out<code class= source >Image incidence angles.</code>  phase_out<code class= source >Image phase angles.</code>  overwrite<code class= source >If set, the output descriptor is the input descriptor</code> <code class= source >			with the relevant fields modified.</code>  dd<code class= source >Data descriptor containing image to correct.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/2002 (pg_photom)</code> <code class= source >	 Spitale, 6/2004:	changed to pg_photom_disk</code>  <code class= source >	New data descriptor containing the corrected image.  The photometric</code> <code class= source >	angles emm, inc, and phase are placed in the user data arrays with</code> <code class= source >	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is</code> <code class= source >	set, the nw descriptor is a clone of the input descriptor, with the</code> <code class= source >	relevant fields modified.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_photom_globe.html", "pg_photom_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_photom_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_photom_globe.html#pg_photom_globe", "pg_photom_globe", 'routine in <a href="com/pg/pg_photom_globe.html">pg_photom_globe.pro</a>', "pg_photom_globe.pro", "", "pg_photom_globe", "<code class= source >	Photometric image correction for globe objects.</code>  ", "outline_ptd<code class= source >POINT with image points outlining the</code> <code class= source >			region of the image to correct.  To correct the entire</code> <code class= source >			planet, this input could be generated using pg_limb().</code> <code class= source >			If this keyword is not given, the entire image is used.</code>  cd<code class= source >Camera descriptor</code>  gbx<code class= source >Globe descriptor</code>  ltd<code class= source >Light descriptor</code>  gd<code class= source >Generic descriptor.  If present, cd and gbx are taken from</code> <code class= source >		here if contained.</code>  refl_fn<code class= source >String naming reflectance function to use.  Default is</code> <code class= source >			'pht_refl_minneart'.</code>  phase_fn<code class= source >String naming phase function to use.  Default is none.</code>  refl_parmphase_parmemm_out<code class= source >Image emission angles.</code>  inc_out<code class= source >Image incidence angles.</code>  phase_out<code class= source >Image phase angles.</code>  overwrite<code class= source >If set, the output descriptor is the input descriptor</code> <code class= source >			with the relevant fields modified.</code>  dd<code class= source >Data descriptor containing image to correct.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/2002 (pg_photom)</code> <code class= source >	 Spitale, 6/2004:	changed to pg_photom_globe</code>  <code class= source >	New data descriptor containing the corrected image.  The photometric</code> <code class= source >	angles emm, inc, and phase are placed in the user data arrays with</code> <code class= source >	the tags'EMM', 'INC', and 'PHASE' respectively.  Unless /overwrite is</code> <code class= source >	set, the nw descriptor is a clone of the input descriptor, with the</code> <code class= source >	relevant fields modified.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html", "pg_profile_image.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_profile_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_image.html#pg_profile_image", "pg_profile_image", 'routine in <a href="com/pg/pg_profile_image.html">pg_profile_image.pro</a>', "pg_profile_image.pro", "", "pg_profile_image", "<code class= source >	Generates a dn profile along a line in an image.</code>  ", "cd<code class= source >Camera descriptor.  Needed for sinc interpolation. (to get PSF)</code>  gd<code class= source >  Optional generic descriptor containing cd.</code>  distance<code class= source > Array giving the distance, in pixels, along the profile.</code>  interp<code class= source >  Type of interpolation to use.  Options are:</code> <code class= source >               'nearest', 'mean', 'bilinear', 'cubic', 'sinc'.</code>  arg_interp<code class= source >  Arguments to pass to the interpolation function.</code>  sigma<code class= source >  Array giving the standard deviation at each point in the</code> <code class= source >		profile.</code>  profile<code class= source >  The profile.</code>  image_pts<code class= source > Image point for each point along the profile.</code>  bg<code class= source >Uniform value to subtract from profile.</code>  dd<code class= source >Data descriptor.</code>  outline_ptd<code class= source >  POINT giving the outline of the region to plot,</code> <code class= source >               as produced by the pg_image_sector.</code>  ", "NV/PG", "<code class= source >       Written by:     Spitale, 6/2005</code>  <code class= source >	Two data descriptors: the first contains the profile; the second contains</code> <code class= source >	the profile sigma.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_profile_ring.html", "pg_profile_ring.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_profile_ring.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_profile_ring.html#pg_profile_ring", "pg_profile_ring", 'routine in <a href="com/pg/pg_profile_ring.html">pg_profile_ring.pro</a>', "pg_profile_ring.pro", "", "pg_profile_ring", "<code class= source >	Generates radial or longitudinal ring profiles from the given image</code> <code class= source >	using an image outline.</code>  <code class= source >	The image points of the sector outline are first calculated.  If</code> <code class= source >       /outline is selected then this is output.  If not, then the</code> <code class= source >       /azimuthal keyword determines if this is a radius or longitude</code> <code class= source >       profile.  The radius and longitude spacing for profile is then is</code> <code class= source >       determined. If n_lon or n_rad is given, then these are used.  If not,</code> <code class= source >       then the outline is used to determine the spacing in radius and</code> <code class= source >       longitude so that the maximum spacing is a pixel.  If oversamp is</code> <code class= source >       given then the number of samples is multiplied by this factor.</code> <code class= source >       Then the image is sampled with this radius x longitude grid and</code> <code class= source >       the dn interpolated with the routine image_interp at each point.</code> <code class= source >       The dn's are then averaged along the requested profile direction.</code> <code class= source >       If /bin keyword is selected then the image is not interpolated but</code> <code class= source >       rather each pixel is binned in a histogram with the calculated</code> <code class= source >       spacing.</code>  ", "cd<code class= source >Camera descriptor.</code>  dkx<code class= source >  Disk descriptor.</code>  gd<code class= source >  Generic descriptor, if used, cd and dkx taken from it unless</code> <code class= source >               overriden by cd and dkx arguments.</code>  azimuthal<code class= source >  If set, the plot is longitudinal instead of radial.</code>  sigma<code class= source >  Array giving the standard deviation at each point in the</code> <code class= source >		profile.</code>  width<code class= source >  Array giving the width of the scan, in pixels along the</code> <code class= source >               averaging direction, at each point in the profile.</code>  nn<code class= source >  Number of image samples averaged into each profile point.</code>  bin<code class= source >   If set, pixels in sector are binned according to</code> <code class= source >               radius or longitude rather than dn averaged at equal</code> <code class= source >               radius or longitude spacing</code>  dsk_pts<code class= source >Array of disk coordinates corresponding to each value in the</code> <code class= source >		returned dn profile.</code>  im_pts<code class= source >Array of image coordinates corresponding to each value in the</code> <code class= source >		returned dn profile.</code>  interp<code class= source >   Type of interpolation to use: 'nearest', 'bilinear', 'cubic',</code> <code class= source >               or 'sinc'.  'sinc' is the default.</code>  arg_interp<code class= source >  Arguments to pass to the interpolation function.</code>  profile<code class= source >  The profile.</code>  bg<code class= source >Uniform value to subtract from profile.</code>  dd<code class= source >Data descriptor.</code>  outline_ptd<code class= source >   POINT giving the outline of the sector to plot,</code> <code class= source >                      as produced by the pg_ring_sector.</code>  ", "NV/PG", "<code class= source >       Written by:     Vance Haemmerle & Spitale, 6/1998</code> <code class= source >	Modified to use outline_ptd instead of (rad,lon): Spitale 5/2005</code>  <code class= source >     lon = [175.,177.]</code> <code class= source >     rad = [65000000.,138000000.]</code> <code class= source >     outline_ptd = pg_ring_sector(cd=cd, dkx=rd, rad=rad, lon=lon)</code> <code class= source >     pg_draw, outline_ptd</code> <code class= source >     profile = pg_profile_ring(dd, cd=cd, dkx=rd, $</code> <code class= source >                                          outline_ptd, dsk_pts=dsk_pts)</code> <code class= source >     window, /free, xs=500, ys=300</code> <code class= source >     plot, dsk_pts[*,0], profile</code> <code class= source >	Two data descriptors: the first contains the profile; the second contains</code> <code class= source >	the profile sigma.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptassoc.html", "pg_ptassoc.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptassoc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptassoc.html#pg_ptassoc", "pg_ptassoc", 'routine in <a href="com/pg/pg_ptassoc.html">pg_ptassoc.pro</a>', "pg_ptassoc.pro", "", "pg_ptassoc", "<code class= source >	Associates points between two arrays by searching for the most</code> <code class= source >	frequent offset between the two.</code>  <code class= source >	Points are associated by searching for the most frequent offset</code> <code class= source >	between scan points and model points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvscan_coeff, pg_ptscan, pg_ptscan_coeff,</code> <code class= source >	pg_cvchisq, pg_ptchisq, pg_threshold</code>  ", "radiusdxymaxcountscan_ptd<code class= source >POINT(s) containing first array, typically</code> <code class= source >			an array of candidate points detected in an image.</code>  model_ptd<code class= source >POINT(s) containing the second array, typically</code> <code class= source >			an array of computed model points.</code>  assoc_model_ptd", "NV/PG", "<code class= source > 	Written by:	Spitale, 3/2004</code>  <code class= source >	POINT containing an associated scan point for each output</code> <code class= source >	model point in assoc_model_ptd.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptchisq.html", "pg_ptchisq.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptchisq.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptchisq.html#pg_ptchisq", "pg_ptchisq", 'routine in <a href="com/pg/pg_ptchisq.html">pg_ptchisq.pro</a>', "pg_ptchisq.pro", "", "pg_ptchisq", "<code class= source >	Computes chi-squared value for given point fit parameters.</code>  <code class= source >	The caller is responsible for ensuring that the input parameters are</code> <code class= source >	consistent with those used with other programs like pg_fit.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_cvscan, pg_cvscan_coeff, pg_cvchisq, pg_ptscan, pg_ptscan_coeff,</code> <code class= source >	pg_ptchisq, pg_fit, pg_threshold</code>  ", "axis_ptd<code class= source >POINT containing a single image  point</code> <code class= source >			to be used as the axis of rotation.</code>  fix<code class= source >	Array specifying which parameters to fix as</code> <code class= source >			[dx,dy,dtheta].</code>  dxy<code class= source >	2-element vector giving the translation as [dx,dy].</code>  dtheta<code class= source >	Rotation in radians.</code>  scan_ptd<code class= source >Array (n_points) of POINT output from</code> <code class= source >			pg_ptscan containing scanned image points as well as</code> <code class= source >			other necessary scan data.</code>  ", "NV/PG", "<code class= source > 	Written by:	Haemmerle, 12/1998</code>  <code class= source >	Single chi-square values for totality of points.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptcntrd.html", "pg_ptcntrd.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptcntrd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptcntrd.html#pg_ptcntrd", "pg_ptcntrd", 'routine in <a href="com/pg/pg_ptcntrd.html">pg_ptcntrd.pro</a>', "pg_ptcntrd.pro", "", "pg_ptcntrd", "<code class= source >	Attempts to find points of highest correlation with a given model</code> <code class= source >	centered near given features in an image, then returns the centroid.</code>  <code class= source >	xx</code>  <code class= source >	Currently does not work for multiple time steps.</code>  <code class= source >	For each visible object, a section of the image of size width +</code> <code class= source >       the size of the model is extracted and sent to routine ptloc to</code> <code class= source >       find the pixel offset with the highest correlation with the given</code> <code class= source >       model. Then call astrolib routine cntrd to return centroid.</code>  ", "model<code class= source >         Point spread model to be used in correlation.  If</code> <code class= source >                       not given a default gaussian is used.</code>  width<code class= source >         Width to search around expected point location.  If</code> <code class= source >                       not given, a default width of 20 pixels is used.</code>  edge<code class= source >          Distance from edge from which to ignore points.  If</code> <code class= source >                       not given, an edge distance of 0 is used.</code>  ccmin<code class= source >         If given, points are discarded if the correlation</code> <code class= source >                       is below this value.</code>  gdmax<code class= source >         If given, points are discarded if the gradiant of</code> <code class= source >                       the correlation function is higher than this value.</code>  dd<code class= source >	Data descriptor</code>  object_ptd<code class= source >	Array (n_pts) of POINT giving the points.</code> <code class= source >			Only the image coordinates of the points need to be</code> <code class= source >			specified.</code>  ", "NV/PG", "<code class= source > 	Written by:	Haemmerle, 5/1998</code>  <code class= source >	To find stellar positions with a correlation higher than 0.6...</code> <code class= source >       star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm</code> <code class= source >       ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)</code> <code class= source > SEE ALSO:</code> <code class= source >	ptscan, pg_ptscan</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code> <code class= source >	An array of type POINT giving the detected position for</code> <code class= source >       each object.  The correlation coeff values for each detection is</code> <code class= source >       saved in the data portion of POINT with tag 'scan_cc'.</code> <code class= source >       The x and y offset from the given position is also saved.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptfarscan.html", "pg_ptfarscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptfarscan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptfarscan.html#pg_ptfarscan", "pg_ptfarscan", 'routine in <a href="com/pg/pg_ptfarscan.html">pg_ptfarscan.pro</a>', "pg_ptfarscan.pro", "", "pg_ptfarscan", "<code class= source >	Attempts to find all occurrences of a model in an image.</code>  ", "namemodel<code class= source >         Point spread model to be used in correlation.  If</code> <code class= source >                       not given a default gaussian is used.</code>  edge<code class= source >          Distance from edge from which to ignore points.  If</code> <code class= source >                       not given, an edge distance of 0 is used.</code>  ccmin<code class= source >         Minimum correlation to consider in search.  Default</code> <code class= source >			is 0.8.</code>  gdmax<code class= source >         If given, points where the gradient of the</code> <code class= source >                       correlation function is higher than this value</code> <code class= source >			are not considered in the search.</code>  smooth<code class= source >	If given, the input image is smoothed using</code> <code class= source >			this width before any further processing.</code>  wmod<code class= source >	x, ysize of default gaussian model.</code>  wpsf<code class= source >	Half width of default gaussian psf model.</code>  sky<code class= source >	If set, it is assumed that the image contains only</code> <code class= source >			point sources and sky.  Any object more than nsig</code> <code class= source >			standard deviations above the image mean are</code> <code class= source >			selected as candidates.</code>  nsig<code class= source >	For use with the /sky option, standard deviation</code> <code class= source >			threshold for detecting point sources.</code>  median<code class= source >	If given, the input image is filtered using</code> <code class= source >			a median filter of this width before any further</code> <code class= source >			processing.</code>  mask<code class= source >	If set, an attempt is made to mask out extended</code> <code class= source >			objects before performing the scan</code>  extend<code class= source >	If nonzero, star masks are extended by this</code> <code class= source >			many pixels in all directions.</code>  nmax<code class= source >	Max. number of point sources to return.  If more</code> <code class= source >			are found, nsig is raised until thiws is satisified.</code>  chifitdd<code class= source >	Data descriptor</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale 2/2004</code>  <code class= source >	An array of type POINT giving the detected position for</code> <code class= source >       each object.  The correlation coeff value for each detection is</code> <code class= source >       saved in the data portion of POINT with tag 'scan_cc'.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_ptscan</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptscan.html", "pg_ptscan.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptscan.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptscan.html#pg_ptscan", "pg_ptscan", 'routine in <a href="com/pg/pg_ptscan.html">pg_ptscan.pro</a>', "pg_ptscan.pro", "", "pg_ptscan", "<code class= source >	Attempts to find points of highest correlation with a given model</code> <code class= source >	centered near given features in an image.</code>  <code class= source >	Currently does not work for multiple time steps, only considers</code> <code class= source >	one point per given POINT.</code>  <code class= source >	For each visible object, a section of the image of size width +</code> <code class= source >       the size of the model is extracted and sent to routine ptloc to</code> <code class= source >       find the pixel offset with the highest correlation with the given</code> <code class= source >       model.</code>  ", "model<code class= source >         Point spread model to be used in correlation.  If</code> <code class= source >                       not given a default gaussian is used.</code>  radius<code class= source >	Width outside of which to exclude detections whose</code> <code class= source >			offset varies too far from the most frequent offset.</code> <code class= source >			Detections with offsets outside this radius receive</code> <code class= source >			correlation coefficients of zero.</code>  width<code class= source >         Width to search around expected point location.  If</code> <code class= source >                       not given, a default width of 20 pixels is used.</code>  edge<code class= source >          Distance from edge from which to ignore points.  If</code> <code class= source >                       not given, an edge distance of 0 is used.</code>  ccmin<code class= source >         If given, points are discarded if the correlation</code> <code class= source >                       is below this value.</code>  gdmax<code class= source >         If given, points are discarded if the gradiant of</code> <code class= source >                       the correlation function is higher than this value.</code>  smooth<code class= source >	If given, the input image is smoothed using</code> <code class= source >			this width before any further processing.</code>  showwmod<code class= source >	x, ysize of default gaussian model.</code>  wpsf<code class= source >	Half-width of default gaussian psf model.</code>  median<code class= source >	If given, the input image is filtered using</code> <code class= source >			a median filter of this width before any further</code> <code class= source >			processing.</code>  chisqmax<code class= source >Max chisq between the model and the image.</code>  cc_outroundspikedd<code class= source >	Data descriptor</code>  object_ptd<code class= source >	Array (n_pts) of POINT giving the points.</code> <code class= source >			Only the image coordinates of the points need to be</code> <code class= source >			specified.</code>  ", "NV/PG", "<code class= source > 	Written by:	Haemmerle, 5/1998</code> <code class= source >	Modified:	Spitale 9/2002 -- added twice model width to search</code> <code class= source >			width.</code>  <code class= source >	To find stellar positions with a correlation higher than 0.6...</code> <code class= source >       star_ptd=pg_center(bx=sd, gd=gd) & pg_hide, star_ptd, gd=gd, /rm</code> <code class= source >       ptscan_ptd=pg_ptscan(dd, star_ptd, edge=30, width=40, ccmin=0.6)</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_ptfarscan</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code> <code class= source >	An array of type POINT giving the detected position for</code> <code class= source >       each object.  The correlation coeff value for each detection is</code> <code class= source >       saved in the data portion of POINT with tag 'scan_cc'.</code> <code class= source >       The x and y offset from the given position is also saved.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ptscan_coeff.html", "pg_ptscan_coeff.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ptscan_coeff.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ptscan_coeff.html#pg_ptscan_coeff", "pg_ptscan_coeff", 'routine in <a href="com/pg/pg_ptscan_coeff.html">pg_ptscan_coeff.pro</a>', "pg_ptscan_coeff.pro", "", "pg_ptscan_coeff", "<code class= source >	Computes linear least-squares coefficients for a fit to the image</code> <code class= source >	coordinate offset which matches a point to a feature in an image.</code>  <code class= source >       pg_ptscan_coeff extracts the scan data from the given</code> <code class= source >       scan_ptd structure and uses ipt_coeff to compute the coefficients.</code> <code class= source >       See the documentation for that routine for details.</code>  ", "axis_ptd<code class= source >      POINT containing a single image point</code> <code class= source >                       to be used as the axis of rotation in the fit for</code> <code class= source >                       every point.</code>  fix<code class= source >           Array specifying which parameters to fix in the</code> <code class= source >                       fit as [dx,dy,dtheta].;</code>  model_ptdpts_ptd<code class= source >       Array (n_pts) of POINT output from</code> <code class= source >                       pg_ptscan containing image points as well as</code> <code class= source >                       other necessary data.;</code>  ", "NV/PG", "<code class= source > 	Written by:	Haemmerle, 5/1998</code>  <code class= source >       The following command uses data from pg_ptscan to compute</code> <code class= source >       least square coefficients for a fit such that only dx and dtheta</code> <code class= source >       will be allowed to vary:</code> <code class= source >       optic_ptd = pnt_create_descriptors(points=cam_oaxis(cd))</code> <code class= source >       ptscan_cf = pg_ptscan_coeff(pts_ptd, axis=optic_ptd, fix=[1])</code> <code class= source >       In this call, pts_ptd is a POINT containing the point data</code> <code class= source >       from pg_ptscan and optic_ptd is a POINT giving the optic axis</code> <code class= source >       of the camera as computed by cam_oaxis.</code> <code class= source > STATUS:</code> <code class= source >	Complete.</code> <code class= source >       Array (n_pts) of pg_fit_coeff_struct containing coefficients for</code> <code class= source >       the least-square fit to be input to pg_fit.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_arrays.html", "pg_put_arrays.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_arrays.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_arrays.html#pg_put_arrays", "pg_put_arrays", 'routine in <a href="com/pg/pg_put_arrays.html">pg_put_arrays.pro</a>', "pg_put_arrays.pro", "", "pg_put_arrays", "<code class= source >	Outputs array descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	CameStarra descriptors are passed to the translators.  Any star</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps</code>  ", "ard<code class= source >Star descriptors to output.</code> <code class= source >	arr_*:		All star override keywords are accepted.</code>  odsdd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @arr__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 3/2017</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_cameras.html", "pg_put_cameras.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_cameras.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_cameras.html#pg_put_cameras", "pg_put_cameras", 'routine in <a href="com/pg/pg_put_cameras.html">pg_put_cameras.pro</a>', "pg_put_cameras.pro", "", "pg_put_cameras", "<code class= source >	Outputs camera descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	Camera descriptors are passed to the translators.  Any camera</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_maps</code>  ", "cd<code class= source >Camera descriptors to output.</code> <code class= source >	cam_*:		All camera override keywords are accepted.</code>  dd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @cam__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_maps.html", "pg_put_maps.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_maps.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_maps.html#pg_put_maps", "pg_put_maps", 'routine in <a href="com/pg/pg_put_maps.html">pg_put_maps.pro</a>', "pg_put_maps.pro", "", "pg_put_maps", "<code class= source >	Outputs map descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	Map descriptors are passed to the translators.  Any map</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_planets, pg_put_rings, pg_put_stars, pg_put_cameras</code>  ", "md<code class= source >Map descriptors to output.</code> <code class= source >	map_*:		All map override keywords are accepted.</code>  dd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @map__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_planets.html", "pg_put_planets.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_planets.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_planets.html#pg_put_planets", "pg_put_planets", 'routine in <a href="com/pg/pg_put_planets.html">pg_put_planets.pro</a>', "pg_put_planets.pro", "", "pg_put_planets", "<code class= source >	Outputs planet descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	Planet descriptors are passed to the translators.  Any planet</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_cameras, pg_put_rings, pg_put_stars, pg_put_maps</code>  ", "pd<code class= source >Planet descriptors to output.</code> <code class= source >	plt_*:		All planet override keywords are accepted.</code>  odsraw<code class= source >	If set, no aberration corrections are performed.</code>  dd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @plt__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_rings.html", "pg_put_rings.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_rings.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_rings.html#pg_put_rings", "pg_put_rings", 'routine in <a href="com/pg/pg_put_rings.html">pg_put_rings.pro</a>', "pg_put_rings.pro", "", "pg_put_rings", "<code class= source >	Outputs ring descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	Ring descriptors are passed to the translators.  Any ring</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_planets, pg_put_cameras, pg_put_stars, pg_put_maps</code>  ", "rd<code class= source >Ring descriptors to output.</code> <code class= source >	rng_*:		All ring override keywords are accepted.</code>  odsdd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @rng__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_stars.html", "pg_put_stars.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_stars.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_stars.html#pg_put_stars", "pg_put_stars", 'routine in <a href="com/pg/pg_put_stars.html">pg_put_stars.pro</a>', "pg_put_stars.pro", "", "pg_put_stars", "<code class= source >	Outputs star descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	CameStarra descriptors are passed to the translators.  Any star</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps</code>  ", "sd<code class= source >Star descriptors to output.</code> <code class= source >	str_*:		All star override keywords are accepted.</code>  odsdd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @str__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_put_stations.html", "pg_put_stations.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_put_stations.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_put_stations.html#pg_put_stations", "pg_put_stations", 'routine in <a href="com/pg/pg_put_stations.html">pg_put_stations.pro</a>', "pg_put_stations.pro", "", "pg_put_stations", "<code class= source >	Outputs station descriptors through the translators.</code>  <code class= source >	Translator-dependent.  The data descriptor may be affected.</code>  <code class= source >	CameStarra descriptors are passed to the translators.  Any star</code> <code class= source >	keywords are used to override the corresponding quantities in the</code> <code class= source >	output descriptors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_put_planets, pg_put_rings, pg_put_cameras, pg_put_maps</code>  ", "std<code class= source >Star descriptors to output.</code> <code class= source >	stn_*:		All star override keywords are accepted.</code>  odsdd<code class= source >Data descriptor.</code>  trs<code class= source >String containing keywords and values to be passed directly</code> <code class= source >		to the translators as if they appeared as arguments in the</code> <code class= source >		translators table.  These arguments are passed to every</code> <code class= source >		translator called, so the user should be aware of possible</code> <code class= source >		conflicts.  Keywords passed using this mechanism take</code> <code class= source >		precedence over keywords appearing in the translators table.</code>  @stn__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 3/2017</code>  <code class= source >	NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_range.html", "pg_range.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_range.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_range.html#pg_range", "pg_range", 'routine in <a href="com/pg/pg_range.html">pg_range.pro</a>', "pg_range.pro", "", "pg_range", "<code class= source >	Computes distance between the centers of two bodies.</code>  ", "bx1<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  bx2<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 11/2001</code>  <code class= source >	Array (n_objects) doubles giving the ranges.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ray.html", "pg_ray.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ray.pro", "", "", "<code class= source >	Computes image points on each specified ray.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 9/2012</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection.html", "pg_reflection.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection.html#pg_reflection", "pg_reflection", 'routine in <a href="com/pg/pg_reflection.html">pg_reflection.pro</a>', "pg_reflection.pro", "", "pg_reflection", "<code class= source >	Computes image coordinates of given inertial vectors projected onto</code> <code class= source >	surface of the given disks and globes with respect to the given</code> <code class= source >	observer.  Returns only the closest reflection point for each objoect</code> <code class= source >	point.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the light descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  dkx<code class= source >Array (n_disks, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of DISK.</code>  gbx<code class= source >Array (n_globes, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of GLOBE.</code>  bx<code class= source >Array (n_disks, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code> <code class= source >	  All other keywords are passed directly to pg_reflection_globe</code> <code class= source >	  and pg_reflection_disk and are documented with those programs.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  revealclipnocullallobject_ptd<code class= source >Array of POINT containing inertial vectors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	Array (n_disks,n_objects) of POINT containing image</code> <code class= source >	points and the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Soon to be replaced by a new program that merges pg_reflection_globe and</code> <code class= source >	pg_reflection_disk.  The API for the new routine may be slightly different.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_reflection_disk, pg_reflection_globe, pg_reflection_points</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection_disk.html", "pg_reflection_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection_disk.html#pg_reflection_disk", "pg_reflection_disk", 'routine in <a href="com/pg/pg_reflection_disk.html">pg_reflection_disk.pro</a>', "pg_reflection_disk.pro", "", "pg_reflection_disk", "<code class= source >	Computes image coordinates of given inertial vectors reflected onto</code> <code class= source >	surface of the given disk with respect to the given observer.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the camera descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  dkx<code class= source >Array (n_disks, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of DISK.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  nocullall_ptdreveal<code class= source > Normally, disks whose opaque flag is set are ignored.</code> <code class= source >		 /reveal suppresses this behavior.</code>  clip<code class= source > If set reflection points are cropped to within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  object_ptd<code class= source >Array of POINT containing inertial vectors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/2002</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reflection_globe.html", "pg_reflection_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reflection_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reflection_globe.html#pg_reflection_globe", "pg_reflection_globe", 'routine in <a href="com/pg/pg_reflection_globe.html">pg_reflection_globe.pro</a>', "pg_reflection_globe.pro", "", "pg_reflection_globe", "<code class= source >	Computes image coordinates of the given inertial vectors projected onto</code> <code class= source >	surface of the given globe with respect to the given observer.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the light descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  gbx<code class= source >Array (n_globes, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of GLOBE.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  nocullreveal<code class= source > Normally, disks whose opaque flag is set are ignored.</code> <code class= source >		 /reveal suppresses this behavior.</code>  clip<code class= source > If set reflection points are cropped to within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  nosolve<code class= source >If set, reflection points are not computed.</code>  object_ptd<code class= source >Array of POINT containing inertial vectors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 6/2016</code>  <code class= source >	Array (n_globes,n_objects) of POINT containing image</code> <code class= source >	points and the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Soon to be obsolete.  This program will be merged with pg_reflection_disk</code> <code class= source >	to make a more general program, which will replace pg_reflection.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_reflection, pg_reflection_disk, pg_reflection_points</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_render.html", "pg_render.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_render.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_render.html#pg_render", "pg_render", 'routine in <a href="com/pg/pg_render.html">pg_render.pro</a>', "pg_render.pro", "", "pg_render", "<code class= source >	Performs rendering on an array of bodies.</code>   ", "cd<code class= source >      Camera descriptor.</code>  ltd<code class= source >        Star descriptor for the Sun.</code>  skdbx<code class= source >      Array of object descriptors; must be a subclass of BODY.</code>  ddmap<code class= source >       Array of data descriptors containing the body maps,</code> <code class= source >	              one for each body.  If not given, maps are loaded using</code> <code class= source >		      pg_load_maps.</code>  md<code class= source >          Array of map descriptors for each ddmap.</code>  dd<code class= source >	Data descriptor containing a generic descriptor to use</code> <code class= source >			if gd not given.</code>  gd<code class= source >	Generic descriptor.  If given, the descriptor inputs</code> <code class= source >			are taken from this structure if not explicitly given.</code>  sample<code class= source >      Amount by which to subsample pixels.</code>  pc_size<code class= source >     To save memory, the projection is performed in pieces</code> <code class= source >	              of this size.  Default is 65536.</code>  showpht_min<code class= source >     Minimum value to assign to photometric output.</code>  no_phtmap<code class= source >       2-D array containing the rendered scene.</code>  standoff<code class= source >    If given, secondary vectors are advanced by this distance</code> <code class= source >	              before tracing in order to avoid hitting target bodies</code> <code class= source >	              through round-off error.</code>  limit_source<code class= source >If set, secondary vectors originating on a given</code> <code class= source >	              body are not considered for targets that are the</code> <code class= source >	              same body.  Default is on.</code>  nodd<code class= source >        If set, no data descrptor is produced.  The return value</code> <code class= source >	              is zero and the rendering is returned via the IMAGE</code> <code class= source >	              keyword.</code>  psf<code class= source >         If set, the rendering is convolved with a point-spread</code> <code class= source >	              function.  If /psf, then the PSF is obtained via cd; if</code> <code class= source >	              psf is a 2D array, then is is used as the PSF.</code>  npsf<code class= source >        Width of psf array to use if PSF is obtained via cd.</code> <code class= source >	              Default is 10.</code>  numbra<code class= source >      Number of rays to trace to the secondary bodies.</code> <code class= source >	              Default is 1.  The first ray is traced to the body</code> <code class= source >	              center; wach additional ray is traced to a random point</code> <code class= source >	              within the body.</code>  no_secondary<code class= source >If set, no secondary ray tracing is performed,</code> <code class= source >	              resulting in no shadows.</code>  image_ptd<code class= source >   POINT or array with image points</code> <code class= source >	              specifying the grid to trace.  If not set, the entire</code> <code class= source >	              image described by cd is used.  The array can have</code> <code class= source >	              dimensions of (2,np) or (2,nx,ny).  If the latter,</code> <code class= source >	              the output map will have dimensions (nx,ny).  Note</code> <code class= source >	              that a PSF cannot be applied if nx and ny are not known.</code>  mask_width<code class= source >  Width of trace mask.  Default is 512.  If set to zero,</code> <code class= source >	              no masking is performed.</code>  no_maps<code class= source >     If set, maps are not loaded.</code>  no_mask<code class= source >     If set, a mask is not used.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale</code>  <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source >	Data descriptor containing the rendered image.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_renderfit.html", "pg_renderfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_renderfit.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_renderfit.html#pg_renderfit", "pg_renderfit", 'routine in <a href="com/pg/pg_renderfit.html">pg_renderfit.pro</a>', "pg_renderfit.pro", "", "pg_renderfit", "<code class= source >	Searches for the offset (dx,dy) that gives the best agreement between</code> <code class= source >	two uncorrelated sets of image points.</code>  <code class= source >	pg_renderfit finds the offset that gives the best correlation between</code> <code class= source >	the given image and a simulated image.</code> <code class= source > STATUS:</code> <code class= source >	Some bugs.  One problem is that the current search grid wraps pixels</code> <code class= source >	instead of truncating them.  This causes problems for images where</code> <code class= source >	a large body is not entirly within the FOV.</code> <code class= source > NOTES:</code> <code class= source >	This could be improved by iterating, starting with a broader, more</code> <code class= source >	coarsely sampled scene.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_farfit</code>  ", "cd<code class= source >		Camera descriptor.</code>  ltd<code class= source >	Sun descriptor.</code>  bx<code class= source >	Array of body descriptors describing objects in the scene.</code>  show<code class= source >	If specified, some graphics are displayed illustrating</code> <code class= source >			aspects of the search.</code>  fovdd<code class= source >	Data descriptor.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/2017</code>  <code class= source >	2-element array giving the fit offset as [dx,dy].</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_repoint.html", "pg_repoint.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_repoint.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_repoint.html#pg_repoint", "pg_repoint", 'routine in <a href="com/pg/pg_repoint.html">pg_repoint.pro</a>', "pg_repoint.pro", "", "pg_repoint", "<code class= source >	Modifies the camera orientation matrix based on the given image</code> <code class= source >	coordinate translation and rotation.</code>  <code class= source >	pg_repoint adds its name to the task list of each given camera</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_fit, pg_drag</code>  ", "cd<code class= source > If given, the camera descriptor is modified with a new</code> <code class= source >		 orientation matrix.</code>  gd<code class= source > If given in this way, the camera descriptor contained in the</code> <code class= source >		 generic descriptor is modified with a new orientation matrix.</code>  axis_ptd<code class= source >POINT containing a single image point</code> <code class= source >		 to be used as the axis of rotation.  Default is the camera</code> <code class= source >		 optic axis.</code>  bore_cd<code class= source > Array (nt) of camera descriptors from which to copy the</code> <code class= source >		  new orientation instead of using dxy, dtheta, and axis_ptd.</code>  bore_rot<code class= source >If given, the orientation from bore_cd will be rotated</code> <code class= source >		  using this rotation matrix (3,3) before being copied.</code>  bore_dxy<code class= source >Boresight offset in pixels.</code>  absolute<code class= source >If set, the dxy argument represents an absolute image</code> <code class= source >		  position rather than an offset.</code>  north<code class= source >  If set, orientations set by vector input are aligned</code> <code class= source >		  with celestial north.  Otherwise the original north alignment</code> <code class= source >		  is retained.</code>  _arg<code class= source >	Array (2,1,nt) or (2,1) specifying the translation as</code> <code class= source >			[dx,dy] in pixels.</code> <code class= source >				or</code> <code class= source >			Array of POINT objects; mainly useful with the /absolute</code> <code class= source >			option.</code> <code class= source >				or</code> <code class= source >			Array of new pointing vectors (1,3,nt).</code>  _dtheta<code class= source >	Array (nt) specfying the rotation angle in radians.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_reposition.html", "pg_reposition.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_reposition.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_reposition.html#pg_reposition", "pg_reposition", 'routine in <a href="com/pg/pg_reposition.html">pg_reposition.pro</a>', "pg_reposition.pro", "", "pg_reposition", "<code class= source >	Modifies the body position based on the given offset and observer.</code>  <code class= source >	pg_reposition modifies bx and adds its name to the task list of each given</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "bx<code class= source >Array (nt) of body descriptors to translate.</code>  od<code class= source >Observer descriptor; specifies the body frame for the</code> <code class= source >		translation vector.</code>  ref_bx<code class= source >Body descriptor giving reference position for directional</code> <code class= source >		keywords.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  toward<code class= source >Body should be translated toward ref_bx (default).</code>  away<code class= source >Body should be translated away from ref_bx.</code>  at<code class= source >Body should be placed at the position of ref_bx.</code>  along<code class= source >Index of bx axis along which to translate.</code>  absolute<code class= source >		If set, dv is taken as an absolute position instead of an</code> <code class= source >		offset.</code>  _dv<code class= source >	Array (nv,3,nt) specifying the translation vector.</code> <code class= source >			The components are assumed to be given wrt to the</code> <code class= source >			inertial frame unless od is given.  In that case</code> <code class= source >			dv is interpreted as a vector in the body frame of od.</code> <code class= source >			For convenience, if dv is given in the nonstandard form</code> <code class= source >			of a 3-element array, it is reinterpreted as a column</code> <code class= source >			vector (1,3).</code> <code class= source >			If ref_bx is given, then dv is interpreted as a distance</code> <code class= source >			and the direction is constructed from one of the directional</code> <code class= source >			keywords below.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 3/2007</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_resfit.html", "pg_resfit.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_resfit.pro", "", "", "<code class= source >	Computes polynomial coefficients for a camera distortion model by</code> <code class= source >	comparing detected reseaus with the known focal plane locations.</code>  <code class= source >	First, candidate reseaus are associated with nominal reseaus by</code> <code class= source >	choosing the candidate with the highest correlation coefficient</code> <code class= source >	within a given number of pixels surrounding each known reseau.</code> <code class= source >	Next, coefficients for a polynomial of order n are derived using a</code> <code class= source >	least-squares fit.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_resloc, pg_linearize_image, pg_blemish</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 5/2002</code>  ");
  

libdata[libdataItem++] = new Array("com/pg/pg_residuals.html", "pg_residuals.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_residuals.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_residuals.html#pg_residuals", "pg_residuals", 'routine in <a href="com/pg/pg_residuals.html">pg_residuals.pro</a>', "pg_residuals.pro", "", "pg_residuals", "<code class= source >	Computes residuals value for given curve- or point-fit parameters.</code>  ", "scan_ptd<code class= source >Array (n_curves) of POINT output from</code> <code class= source >			pg_cvscan or pg_ptscan containing scan data.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale</code>  <code class= source >	Array (2,n_curves) of residuals.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_resloc.html", "pg_resloc.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_resloc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_resloc.html#pg_resloc", "pg_resloc", 'routine in <a href="com/pg/pg_resloc.html">pg_resloc.pro</a>', "pg_resloc.pro", "", "pg_resloc", "<code class= source >	Scans an image for candidate reseau marks.</code>  <code class= source >	A correlation map is computed across image.  Candidates reseau marks</code> <code class= source >	are identified as local maxima in the correlation map by accepting</code> <code class= source >	points where the correlation is above the specified threshold and</code> <code class= source >	where the gradient of the correlation map is below the specified</code> <code class= source >	threshold.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_resfit, modloc</code>  ", "edge<code class= source > Distance from edge within which points are ignored.</code>  model<code class= source > 2-D array giving a model of the reseau image.  Default model</code> <code class= source >		is an inverted Gaussian.</code>  ccmin<code class= source > Minimum correlation coefficient to accept.  Default is 0.8 .</code>  gdmax<code class= source > Maximum gradiant of correlation coefficient to accept.</code> <code class= source >		Default is 0.25</code>  nom_ptd<code class= source >If given, reseau marks are searched for only within the</code> <code class= source >		given radius about each nominal point.</code>  radius<code class= source >Radius about no_ptd to search.  Default is ten pixels.</code>  dd<code class= source >Data descriptor containing the image to scan.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1998</code>  <code class= source >	Points structure containing the image coordinates of each candidiate</code> <code class= source >	reseau mark and the corresponding correlation coefficients.  If not</code> <code class= source >	marks are found, zero is returned.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_retarg.html", "pg_retarg.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_retarg.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_retarg.html#pg_retarg", "pg_retarg", 'routine in <a href="com/pg/pg_retarg.html">pg_retarg.pro</a>', "pg_retarg.pro", "", "pg_retarg", "<code class= source >	Modifies the camera orientation such that the optic axis points</code> <code class= source >	along a given vector, or toward a specified body.</code>  <code class= source >	pg_retarg modifies cd and adds its name to the task list of each given</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "cd<code class= source > Camera descriptor to repoint.</code>  bx<code class= source > Body descriptor at which to point.</code>  ref_bxdd<code class= source > Data descriptor containing a generic descriptor to use</code> <code class= source >		 if gd not given.</code>  gd<code class= source > Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		 are taken from this structure if not explicitly given.</code>  toward<code class= source >Camera should be pointed toward bx (default).</code>  away<code class= source >  Camera should be pointed away from bx.</code>  along<code class= source >  Index of bx axis along which to point.</code>  v<code class= source >Inertial vector giving new optic axis direction.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 3/2007</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector.html", "pg_ring_sector.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector.pro", "", "", "<code class= source >	Allows the user to select a ring sector by clicking and dragging.</code> <code class= source >	With the left button, the sector is defined along lines of constant</code> <code class= source >	radius and longitude.  With the right button, the sides of the sector</code> <code class= source >	are perpendicular to the projected radial direction.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box.html", "pg_ring_sector_box.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box.pro", "", "", "<code class= source >	Allows the user to select a box to use with pg_profile_ring.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_oblique.html", "pg_ring_sector_box_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box_oblique.pro", "", "", "<code class= source >	Allows the user to select an oblique box to use with pg_profile_ring.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_box_ortho.html", "pg_ring_sector_box_ortho.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_box_ortho.pro", "", "", "<code class= source >	Allows the user to select a box to use with pg_profile_ring.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_oblique.html", "pg_ring_sector_oblique.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_oblique.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_oblique.html#pg_ring_sector_oblique", "pg_ring_sector_oblique", 'routine in <a href="com/pg/pg_ring_sector_oblique.html">pg_ring_sector_oblique.pro</a>', "pg_ring_sector_oblique.pro", "", "pg_ring_sector_oblique", "<code class= source >	Allows the user to select a ring sector by clicking and dragging.</code> <code class= source >	The top and bottom of the sector are defined along lines of constant</code> <code class= source >	radius, while the sides are perpendicular to the image-projected</code> <code class= source >	radial direction.</code>  ", "cd<code class= source >    Camera descriptor.</code>  dkx<code class= source >    Disk descriptor describing the ring.</code>  gd<code class= source >    Generic descriptor containnig the above descriptors.</code>  lonsample<code class= source >    Grid sampling, default is 1.</code>  win_num<code class= source >    Window number of IDL graphics window in which to select</code> <code class= source >                   box, default is current window.</code>  restore<code class= source >    Do not leave the box in the image.</code>  slope<code class= source >    This keyword allows the longitude to vary from the</code> <code class= source >                   perpendicular direction as a function of radius as:</code> <code class= source >                   lon = slope*(rad - rad0).</code>  p0<code class= source >    First corner of box.  If set, then the routine immediately</code> <code class= source >                   begins to drag from that point until a button is released.</code>  xor_graphics<code class= source >    If set, the sector outline is drawn and erased using xor</code> <code class= source >                   graphics instead of a pixmap.</code>  color<code class= source >    Color to use for rectangle, default is !color.</code>  silent<code class= source >    If set, messages are suppressed.</code>  nodsk<code class= source >    If set, image points will not be included in the output</code> <code class= source >                   POINT.</code>  ", "NV/PG", "<code class= source >      POINT containing points on the sector outline.  The point</code> <code class= source >      spacing is determined by the sample keyword.  The POINT object</code> <code class= source >      also contains the disk coordinate for each point and the user fields</code> <code class= source >      'nrad' and 'nlon' giving the number of points in radius and longitude.</code> <code class= source > KNOWN BUGS:</code> <code class= source >	The sector flips when it hits zero azimuth rather than retaining a</code> <code class= source >	consistent sense.</code> <code class= source > ORIGINAL AUTHOR : J. Spitale ; 5/2005</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_perp.html", "pg_ring_sector_perp.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_perp.pro", "", "", "<code class= source >	Allows the user to select a ring sector by clicking and dragging.</code> <code class= source >	The top and bottom of the sector are defined along lines of constant</code> <code class= source >	radius, while the sides are perpendicular to the image-projected</code> <code class= source >	radial direction.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_rad.html", "pg_ring_sector_rad.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_rad.pro", "", "", "<code class= source >	Allows the user to select a ring sector by clicking and dragging.</code> <code class= source >	The sector is defined along lines of constant radius and longitude.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_ring_sector_radlon.html", "pg_ring_sector_radlon.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_ring_sector_radlon.pro", "", "", "<code class= source >	Constructs a ring sector outline for use with pg_profile_ring given</code> <code class= source >	radius and longitude bounds.</code>  ", "", "          -1", "");
  

libdata[libdataItem++] = new Array("com/pg/pg_rm_points.html", "pg_rm_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_rm_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_rm_points.html#pg_rm_points", "pg_rm_points", 'routine in <a href="com/pg/pg_rm_points.html">pg_rm_points.pro</a>', "pg_rm_points.pro", "", "pg_rm_points", "<code class= source >	xx</code>  <code class= source >Environment variables: </code> <code class= source >	xx:	xx</code> <code class= source >	xx:	xx</code>  <code class= source >	xx:	xx</code> <code class= source >	xx:	xx</code>  <code class= source >	xx</code>  <code class= source >	xx</code>  <code class= source >	xx</code>  ", "radiusptdxptd", "NV/PG", "<code class= source > 	Written by:	xx, xx/xx/xxxx</code>  <code class= source >	xx</code> <code class= source > STATUS:</code> <code class= source >	xx</code> <code class= source > SEE ALSO:</code> <code class= source >	xx, xx, xx</code> <code class= source >	xx</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select.html", "pg_select.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select.html#pg_select", "pg_select", 'routine in <a href="com/pg/pg_select.html">pg_select.pro</a>', "pg_select.pro", "", "pg_select", "<code class= source >	Allows the user to select objects in an image using the mouse.</code>  ", "silent<code class= source >	If set, turns off the notification that cursor</code> <code class= source >			movement is required.</code>  region<code class= source >	If set, the user selects a region in the image.</code> <code class= source >			This is the default.</code>  points<code class= source >	If set, the user selects points.</code>  dd<code class= source >Data descriptor containing the image.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array of subscripts of all image points which lie within the selected</code> <code class= source >	region.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_trim</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_bodies.html", "pg_select_bodies.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_bodies.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_bodies.html#pg_select_bodies", "pg_select_bodies", 'routine in <a href="com/pg/pg_select_bodies.html">pg_select_bodies.pro</a>', "pg_select_bodies.pro", "", "pg_select_bodies", "<code class= source >	Selects bodies based on given criteria.</code>  ", "od<code class= source >	Observer descriptor; some selections require a</code> <code class= source >			CAMERA, others will work with any subclass of BODY.</code> <code class= source >	Descriptor Select Keywords</code> <code class= source >	--------------------------</code> <code class= source >	Descriptor select keywords are combined with OR logic.</code> <code class= source >	  fov/cov:	Select all planets that fall within this many fields of</code> <code class= source >			view (fov) (+/- 10%) from the center of view (cov).</code> <code class= source >			Default cov is the camera optic axis.</code>  prefix_extrabx<code class= source >	Array of descriptors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2017</code>  <code class= source >	Array of subscripts for the descriptors in bx corresponding to the</code> <code class= source >	specified criteria.  !null if no selection criteria were applied.</code> <code class= source > SEE ALSO:</code> <code class= source > 	pg_cull_bodies</code> <code class= source > STATUS:</code> <code class= source >	Starred keywords are not yet implemented.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_points.html", "pg_select_points.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_points.html#pg_select_points", "pg_select_points", 'routine in <a href="com/pg/pg_select_points.html">pg_select_points.pro</a>', "pg_select_points.pro", "", "pg_select_points", "<code class= source >	Allows the user to select points in an image using the mouse.</code>  ", "psym<code class= source >		Plotting symbol to use for the points.</code>  noverbose<code class= source >	If set, turns off the notification that cursor</code> <code class= source >			movement is required.</code>  color<code class= source >	Color to use for graphics overlays.</code>  p0<code class= source >	Initial point, instead of user selection.</code>  one<code class= source >	If set, the routine will exit after selecting one point.</code>  number<code class= source >	If set, each point will be labeled with a number.</code>  cancelled<code class= source >Set if routine is caused to return by the cancel button.</code>  ptd_output<code class= source >If set, a POINT object is returned instead</code> <code class= source >			of a points array.</code>  dd<code class= source >Data descriptor containing the image.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 9/2001</code>  <code class= source >  To print the coordinates of each point as the user selects them, use:</code> <code class= source >   can=0 & while(NOT can) do print, pg_select_points(dd, /one, /nov, can=can)</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source >	Array of image points (2,n).</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_select_region.html", "pg_select_region.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_select_region.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_select_region.html#pg_select_region", "pg_select_region", 'routine in <a href="com/pg/pg_select_region.html">pg_select_region.pro</a>', "pg_select_region.pro", "", "pg_select_region", "<code class= source >	Allows the user to select regions in an image using the mouse.</code>  ", "color<code class= source >	Color to use for graphics overlays.</code>  select_button<code class= source >Index of button to use as the select button instead</code> <code class= source >			of the left button (1).</code>  cancel_button<code class= source >Index of mouse button to be used as a cancel</code> <code class= source >			button instead of left+middle, (3).</code>  end_button<code class= source >Index of button to use as the end button instead</code> <code class= source >			of the right button (4).</code>  silent<code class= source >	If set, turns off the notification that cursor</code> <code class= source >			movement is required.</code>  p0<code class= source >	First point of line.  If set, then the routine</code> <code class= source >			immediately begins to drag from that point until a</code> <code class= source >			button is released.</code>  autoclose<code class= source >If set, the region is automaticaly closed when the</code> <code class= source >			end button is pressed.</code>  points<code class= source >	If set, the selected points are returned instead</code> <code class= source >			of enclosed indices.</code>  noclosedatabox<code class= source >	If set, a rectanguar region is selected.</code>  image_ptsdd<code class= source >Data descriptor containing an image.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	Array of subscripts of all image points which lie within the selected</code> <code class= source >	region.  -1 is returned if the cancel button is pressed.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_trim</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow.html", "pg_shadow.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow.html#pg_shadow", "pg_shadow", 'routine in <a href="com/pg/pg_shadow.html">pg_shadow.pro</a>', "pg_shadow.pro", "", "pg_shadow", "<code class= source >	Computes image coordinates of given inertial vectors projected onto</code> <code class= source >	surface of the given disks and globes with respect to the given</code> <code class= source >	observer.  Returns only the closest shadow point for each objoect</code> <code class= source >	point.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the light descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  dkx<code class= source >Array (n_disks, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of DISK.</code>  gbx<code class= source >Array (n_globes, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of GLOBE.</code>  bx<code class= source >Array (n_disks, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code> <code class= source >	  All other keywords are passed directly to pg_shadow_globe</code> <code class= source >	  and pg_shadow_disk and are documented with those programs.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  revealclipnocullallepsilonnosolveobject_ptd<code class= source >Array of POINT containing inertial vectors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/2002</code>  <code class= source >	Array (n_disks,n_objects) of POINT containing image</code> <code class= source >	points and the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Soon to be replaced by a new program that merges pg_shadow_globe and</code> <code class= source >	pg_shadow_disk.  The API for the new routine may be slightly different.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_shadow_disk, pg_shadow_globe, pg_shadow_points</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_disk.html", "pg_shadow_disk.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_disk.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_disk.html#pg_shadow_disk", "pg_shadow_disk", 'routine in <a href="com/pg/pg_shadow_disk.html">pg_shadow_disk.pro</a>', "pg_shadow_disk.pro", "", "pg_shadow_disk", "<code class= source >	Computes image coordinates of given inertial vectors projected onto</code> <code class= source >	surface of the given disk with respect to the given observer.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the light descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  dkx<code class= source >Array (n_disks, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of DISK.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  nocullreveal<code class= source > Normally, disks whose opaque flag is set are ignored.</code> <code class= source >		 /reveal suppresses this behavior.</code>  clip<code class= source > If set shadow points are cropped to within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  allepsilonobject_ptd<code class= source >Array of POINT containing inertial vectors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/2002</code>  <code class= source >	Array (n_disks,n_objects) of POINT containing image</code> <code class= source >	points and the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Soon to be obsolete.  This program will be merged with pg_shadow_globe</code> <code class= source >	to make a more general program, which will replace pg_shadow.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_shadow, pg_shadow_globe, pg_shadow_points</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shadow_globe.html", "pg_shadow_globe.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shadow_globe.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shadow_globe.html#pg_shadow_globe", "pg_shadow_globe", 'routine in <a href="com/pg/pg_shadow_globe.html">pg_shadow_globe.pro</a>', "pg_shadow_globe.pro", "", "pg_shadow_globe", "<code class= source >	Computes image coordinates of the given inertial vectors projected onto</code> <code class= source >	surface of the given globe with respect to the given observer.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  od<code class= source >Array (n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of BODY.  These objects are used</code> <code class= source >		as the source from which points are projected.  If no observer</code> <code class= source >		descriptor is given, then the light descriptor in gd is used.</code> <code class= source >		Only one observer is allowed.</code>  gbx<code class= source >Array (n_globes, n_timesteps) of descriptors of objects</code> <code class= source >		which must be a subclass of GLOBE.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  nocullreveal<code class= source > Normally, disks whose opaque flag is set are ignored.</code> <code class= source >		 /reveal suppresses this behavior.</code>  clip<code class= source > If set shadow points are cropped to within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  nosolve<code class= source >If set, shadow points are not computed.</code>  object_ptd<code class= source >Array of POINT containing inertial vectors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 1/2002</code>  <code class= source >	Array (n_globes,n_objects) of POINT containing image</code> <code class= source >	points and the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Soon to be obsolete.  This program will be merged with pg_shadow_disk</code> <code class= source >	to make a more general program, which will replace pg_shadow.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_shadow, pg_shadow_disk, pg_shadow_points</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_shift.html", "pg_shift.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_shift.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_shift.html#pg_shift", "pg_shift", 'routine in <a href="com/pg/pg_shift.html">pg_shift.pro</a>', "pg_shift.pro", "", "pg_shift", "<code class= source >	Shifts the given image by a non-integer offset and adjusts the camera</code> <code class= source >	pointing accordingly.</code>  <code class= source >	The given data and camera descriptors are modified: the images are</code> <code class= source >	shifted and the camera descriptor optic axes are changed accordingly.</code> <code class= source > STATUS:</code> <code class= source >	xx</code>  ", "cd<code class= source >Array of camera descripors, one for each input image.</code>  gd<code class= source >Generic descriptor containing the camera and body</code> <code class= source >		descriptors or an array of generic descriptors, one for each</code> <code class= source >		input image.</code>  dd<code class= source >Array of data descriptors giving images to shift.</code>  dxy", "NV/PG", "<code class= source > 	Written by:	Spitale, 7/2008</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_sort_args.html", "pg_sort_args.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_sort_args.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_sort_args.html#pg_sort_args", "pg_sort_args", 'routine in <a href="com/pg/pg_sort_args.html">pg_sort_args.pro</a>', "pg_sort_args.pro", "", "pg_sort_args", "<code class= source >	Sorts arguments to pg_get_* programs.</code>  ", "ddodtimetrsfreearg1arg2@dat__keywords_tree.include", "NV/PG", "<code class= source > 	Written by:	Spitale, 7/2017</code>  <code class= source >	dd:	Data descriptor.  If none given, one is created using the</code> <code class= source >		DATA keywords (see below).</code> <code class= source >	od:	Observer descriptor.  If no dd given, then thi descriptor</code> <code class= source >		is used to determine the number of dd to create.</code> <code class= source >	time:	Observation time.  If no dd or od given, then this array</code> <code class= source >		is used to determine the number of dd to create.</code> <code class= source >	trs:	Transient arguments; Null string if not given.</code> <code class= source >	DATA Keywords</code> <code class= source >	-------------</code> <code class= source >	All DATA override keywords are accepted.  See dat__keywords.include.</code> <code class= source >	If the instrument keyword is no given, it is set to DEFAULT.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_spikes.html", "pg_spikes.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_spikes.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_spikes.html#pg_spikes", "pg_spikes", 'routine in <a href="com/pg/pg_spikes.html">pg_spikes.pro</a>', "pg_spikes.pro", "", "pg_spikes", "<code class= source >	Locates spurious features like cosmic-ray hits.</code>  <code class= source >	Clusters of hot pixels of size 'scale' are identified by looking</code> <code class= source >	for regions bounded by large gradients.  Each cluster is then</code> <code class= source >	examined for pixels whose values are larger than nsig standard</code> <code class= source >	deviations above the local mean.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_despike, pg_mask</code>  ", "nsig<code class= source >	Number of standard deviations above the local</code> <code class= source >			mean data value to flag for removal.  Default is 2.</code>  grad<code class= source >	Minimum data value gradient to use when searching</code> <code class= source >			for clusters of hot pixels.  Default is 5.</code>  maskumask<code class= source >	Byte image of the same size as the input image</code> <code class= source >			in which nonzero pixel values indicate locations</code> <code class= source >			where spikes should not be flagged.</code>  extend<code class= source >	Number of pixels away from masked pixels before</code> <code class= source >			locations may be flagged as spikes.</code>  scale<code class= source >	Typical size of objects to be flagged.  Default is 10.</code>  edge<code class= source >	Regions closer than this to the edge of the image</code> <code class= source >			will be ignored.  Default is 10.</code>  local<code class= source >	Multiplier that determines the width of the region</code> <code class= source >			over which the local mean and standard deviation are</code> <code class= source >			taken.  That width is local * scale.  Default is 5.</code>  nohotallpix<code class= source >	If set, all pixels in the spike region are returned</code> <code class= source >			instead of of the centroids.</code>  dd<code class= source >	Data descriptor containing the image to be despiked.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 4/2005</code>  <code class= source >	dd = dat_read(filename)</code> <code class= source >	spike_ptd = pg_spikes(dd)</code> <code class= source >	dd1 = pg_despike(dd, spike_ptd)</code> <code class= source >	POINT containing the detected spike points.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_station.html", "pg_station.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_station.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_station.html#pg_station", "pg_station", 'routine in <a href="com/pg/pg_station.html">pg_station.pro</a>', "pg_station.pro", "", "pg_station", "<code class= source >	Computes image points for given station descriptors.</code>  ", "cd<code class= source >Array (n_timesteps) of camera descriptors.</code>  std<code class= source >Array (n_objects, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of STATION.</code>  gbx<code class= source >Array (n_xd, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of GLOBE.</code>  dkx<code class= source >Array (n_xd, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of DISK.</code>  bx<code class= source >Array (n_xd, n_timesteps) of descriptors of objects</code> <code class= source >		that must be a subclass of BODY, instead of gbx or dkx.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  clip<code class= source > If set points are computed only within this many camera</code> <code class= source >		 fields of view.</code>  cull<code class= source > If set, POINT objects excluded by the clip keyword</code> <code class= source >		 are not returned.  Normally, empty POINT objects</code> <code class= source >		 are returned as placeholders.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 10/2012</code>  <code class= source >	Array (n_objects) of POINT containing image points and</code> <code class= source >	the corresponding inertial vectors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_stereo_split.html", "pg_stereo_split.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_stereo_split.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_stereo_split.html#pg_stereo_split", "pg_stereo_split", 'routine in <a href="com/pg/pg_stereo_split.html">pg_stereo_split.pro</a>', "pg_stereo_split.pro", "", "pg_stereo_split", "<code class= source >	Produces two camera descriptors whose positions are offset</code> <code class= source >	in the +/-x image directions for computing stereo overlays.</code>  ", "cd<code class= source >	Camera descriptor to be split.</code>  separation<code class= source >stereo separation for the new camera descriptors.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale; 7/29/2005</code>  <code class= source >	Array containing two camera descriptors.</code> <code class= source > STATUS:</code> <code class= source >	xx</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_str_limit_mag.html", "pg_str_limit_mag.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_str_limit_mag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_str_limit_mag.html#pg_str_limit_mag", "pg_str_limit_mag", 'routine in <a href="com/pg/pg_str_limit_mag.html">pg_str_limit_mag.pro</a>', "pg_str_limit_mag.pro", "", "pg_str_limit_mag", "<code class= source >	Removes stars whose visual magnitude falls outside the given minimum</code> <code class= source >	and maximum values.</code>  ", "max<code class= source >Maximum visual magnitude.</code>  min<code class= source >Minimum visual magnitude.</code>  sds", "NV/PG", "<code class= source > 	Written by:	Haemmerle, 1998</code>  <code class= source >	Array of star descriptors whose visual magnitudes fall within the</code> <code class= source >	specified range.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_strip.html", "pg_strip.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_strip.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_strip.html#pg_strip", "pg_strip", 'routine in <a href="com/pg/pg_strip.html">pg_strip.pro</a>', "pg_strip.pro", "", "pg_strip", "<code class= source >	Plots the portion of an image between two chosen points.</code>  ", "width<code class= source >	An odd integer giving the width in pixels of the</code> <code class= source >			extracted strip (default=5).  This width is rebinned</code> <code class= source >			to a single pixel for plotting.</code>  nw<code class= source >	When set, each plot is done in a new window.</code>  nomarks<code class= source >Suppresses the marks that show the locations of</code> <code class= source >			the chosen points, which are difficult to</code> <code class= source >			entirely erase.</code>  devicexs<code class= source >	Specifies the x-dimension of the window, in pixels.</code> <code class= source >			Default is 400.</code>  ys<code class= source >	Specifies the y-dimension of the window, in pixels.</code> <code class= source >			Default is 300.</code>  im<code class= source >	The two-dimensional array from which the</code> <code class= source >			plotted strip will be extracted.</code>  ", "COM/PG", "<code class= source >       Written by:     Tiscareno, 7/00</code>  <code class= source >       NONE</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_sub_body.html", "pg_sub_body.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_sub_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_sub_body.html#pg_sub_body", "pg_sub_body", 'routine in <a href="com/pg/pg_sub_body.html">pg_sub_body.pro</a>', "pg_sub_body.pro", "", "pg_sub_body", "<code class= source >	Computes surface coordinates of sub-body point.</code>  ", "gbxbxddgd", "NV/PG", "<code class= source > 	Written by:	Spitale, 11/2001</code>  <code class= source >	Array (n_objects,3) of surface coordinate vectors.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_threshold.html", "pg_threshold.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_threshold.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_threshold.html#pg_threshold", "pg_threshold", 'routine in <a href="com/pg/pg_threshold.html">pg_threshold.pro</a>', "pg_threshold.pro", "", "pg_threshold", "<code class= source >	Excludes points whose associated data lie outside of specified</code> <code class= source >	thresholds by setting the PTD_MASK_INVISIBLE.</code>  <code class= source >	The input argument object_ptd is modified.</code>  <code class= source >	xx</code>  <code class= source >	The thresholding is performed by cc_threshold.  See the documentation</code> <code class= source >	for that routine for details.</code>  ", "tag<code class= source >	Tag name for user data array to threshold.  Default</code> <code class= source >			is 'scan_cc'.</code>  min<code class= source >	Lower threshold - values less than this will be</code> <code class= source >			excluded.</code>  max<code class= source >	Upper threshold - values greater than this will be</code> <code class= source >			excluded.</code>  relative<code class= source >If set, the max and min arguments will be taken as</code> <code class= source >			fractions of the maximum value in the array.</code>  scan_ptd", "NV/PG", "<code class= source > 	Written by:	Spitale, 6/1998</code>  <code class= source >	xx</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source >	object_ptd:	Modified array of POINT.  PTD_MASK_INVISIBLE</code> <code class= source >			is set for all excluded points.</code>  ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_tiepoints.html", "pg_tiepoints.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_tiepoints.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_tiepoints.html#pg_tiepoints", "pg_tiepoints", 'routine in <a href="com/pg/pg_tiepoints.html">pg_tiepoints.pro</a>', "pg_tiepoints.pro", "", "pg_tiepoints", "<code class= source >       Computes tiepoint image offsets.</code>  ", "cd<code class= source >Camera descriptor.</code>  bx<code class= source >Body descriptor; can be GLOBE or RING.</code>  gbx<code class= source >Globe descriptor for each globe in image instead of</code> <code class= source >		specifying bx.</code>  dkx<code class= source >Disk descriptor for each globe in image instead of</code> <code class= source >		specifying bx.</code>  dd<code class= source >Data descriptor containing a generic descriptor to use</code> <code class= source >		if gd not given.</code>  gd<code class= source >Generic descriptor.  If given, the descriptor inputs</code> <code class= source >		are taken from this structure if not explicitly given.</code>  body_pts<code class= source >	Array of np column vectors giving the body-frame coordinates</code> <code class= source >		for each tie point.  If this keyword is given as an input,</code> <code class= source >		then no output is generated.</code>  dxyptd<code class= source >        POINT containing the image points.</code>  ", "NV/PG", "<code class= source >       Written by:     Spitale, 8/2006</code>  <code class= source >  1) Manually select a set of tiepoints in a set of images and fit</code> <code class= source >     a pointing offset:</code> <code class= source >	ndd = n_elements(dd)</code> <code class= source >	for i=0, ndd-1 do ptd[i] = pg_select_points(dd[i], /ptd)</code> <code class= source >	body_pts = 0</code> <code class= source >	for i=0, ndd-1 do $</code> <code class= source >	 begin &$</code> <code class= source >	  tie_ptd = pg_tiepoints(cd=cd[i], bx=pd[i], ptd[i], body_pts=body_pts) &$</code> <code class= source >	  tpcoeff = pg_ptscan_coeff(tie_ptd, fix=[2]) &$</code> <code class= source >	  dxy = pg_fit(tpcoeff) &$</code> <code class= source >	  pg_repoint, dxy, 0d, cd=cd[i] &$</code> <code class= source >	 end</code> <code class= source >     In the above example, the first image is used as a reference;</code> <code class= source >     because body_pts is initially undefined, those points are computed</code> <code class= source >     for the first image, but not subsequently.  Instead, the subsequent</code> <code class= source >     images will have a nonzero offset stored in the tie_ptd structure,</code> <code class= source >     which are then used by pg_ptscan_coeff to compute fit coefficients.</code> <code class= source > STATUS:</code> <code class= source >       Complete</code> ");
  
  

libdata[libdataItem++] = new Array("com/pg/pg_trim.html", "pg_trim.pro", '.pro file in <a href="com/pg/dir-overview.html">com/pg/ directory</a>', "pg_trim.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("com/pg/pg_trim.html#pg_trim", "pg_trim", 'routine in <a href="com/pg/pg_trim.html">pg_trim.pro</a>', "pg_trim.pro", "", "pg_trim", "<code class= source >	For each given object, excludes points contained in the given region</code> <code class= source >	by setting the PTD_MASK_INVISIBLE.</code>  ", "mask<code class= source >	Mask to use instead of PTD_MASK_INVISIBLE.</code>  off<code class= source >	If set, the masked flag bit will be turned off.</code>  dd<code class= source >	Data descriptor containing the image.</code>  object_ptd<code class= source >Array (n_objects) of POINT containing the</code> <code class= source >			image points to be trimmed.</code>  region<code class= source >	Array of subscripts of image points to be trimmed.</code>  ", "NV/PG", "<code class= source > 	Written by:	Spitale, 2/1998</code>  <code class= source >	object_ptd:	The input points are be modified on return.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/phase_correction.html", "phase_correction.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "phase_correction.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/phase_correction.html#phase_correction", "phase_correction", 'routine in <a href="obj/tools/phase_correction.html">phase_correction.pro</a>', "phase_correction.pro", "", "phase_correction", "<code class= source >	Assuming body gbx is a sphere, this routine computes the correction</code> <code class= source >	in pixels needed to obtain its true image center given a measurement</code> <code class= source >	of its center of light.</code>  ", "cd<code class= source >Any subclass of DISK.</code>  gbx<code class= source >Any subclass of GLOBE.</code>  ltd<code class= source >BODY descriptor representing the light source.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (2) giving the phase correction offset.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/pixel_grid.html", "pixel_grid.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "pixel_grid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/pixel_grid.html#pixel_grid", "pixel_grid", 'routine in <a href="obj/tools/pixel_grid.html">pixel_grid.pro</a>', "pixel_grid.pro", "", "pixel_grid", "<code class= source >	Generates grid lines aligned with the image window.</code>  ", "spacingnpwnum", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Angle in radians.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/plot_inertial.html", "plot_inertial.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "plot_inertial.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/plot_inertial.html#plot_inertial", "plot_inertial", 'routine in <a href="obj/tools/plot_inertial.html">plot_inertial.pro</a>', "plot_inertial.pro", "", "plot_inertial", "<code class= source >       Plots inertial vectors on a camera image.</code>  ", "colorthicklabelscd<code class= source >Camera descriptor.</code>  _v<code class= source >Inertial vectors giving origins of vectors to plot.  If only one</code> <code class= source >		vector, this will be used as the origin for all of the plotted</code> <code class= source >		vectors.</code>  r<code class= source >Inertial vectors giving the vectors to plot, starting at</code> <code class= source >		the given origins.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale; 7/2002</code>  <code class= source >       NONE</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_assign.html", "plt_assign.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_assign.html#plt_assign", "plt_assign", 'routine in <a href="obj/plt/plt_assign.html">plt_assign.pro</a>', "plt_assign.pro", "", "plt_assign", "<code class= source >	Replaces fields in a PLANET object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@plt__keywords_tree.include", "NV/OBJ/PLT", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_create_descriptors.html", "plt_create_descriptors.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_create_descriptors.html#plt_create_descriptors", "plt_create_descriptors", 'routine in <a href="obj/plt/plt_create_descriptors.html">plt_create_descriptors.pro</a>', "plt_create_descriptors.pro", "", "plt_create_descriptors", "<code class= source >	Init method for the PLANET class.</code>  ", "crd<code class= source >Core descriptor(s) to pass to cor_create_descriptors.</code>  bd<code class= source >Body descriptor(s) to pass to bod_create_descriptors.</code>  sld<code class= source >Solid descriptor(s) to pass to sld_create_descriptors.</code>  gbd<code class= source >Globe descriptor(s) to pass to glb_create_descriptors.</code>  pd<code class= source >Planet descriptor(s) to initialize, instead of creating new ones.</code>  n<code class= source >     Number of planet descriptors.</code>  @plt__keywords_tree.include", "NV/LIB/PLT", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (n) of planet descriptors.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_evolve.html", "plt_evolve.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_evolve.html#plt_evolve", "plt_evolve", 'routine in <a href="obj/plt/plt_evolve.html">plt_evolve.pro</a>', "plt_evolve.pro", "", "plt_evolve", "<code class= source >	Computes new planet descriptors at the given time offsets from the</code> <code class= source >	given planet descriptors using the taylor series expansion</code> <code class= source >	corresponding to the derivatives contained in the given planet</code> <code class= source >	descriptor.</code>  ", "nodv<code class= source > If set, derivatives will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  pddt<code class= source > Time offset.</code>  ", "NV/LIB/PLT", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (npd,ndt) of newly allocated descriptors, of class PLANET,</code> <code class= source >	evolved by time dt, where npd is the number of px, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_query.html", "plt_query.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_query.html#plt_query", "plt_query", 'routine in <a href="obj/plt/plt_query.html">plt_query.pro</a>', "plt_query.pro", "", "plt_query", "<code class= source >	Returns the fields associated with a PLANET object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@plt__keywords_tree.include", "NV/OBJ/PLT", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/plt/plt_replicate.html", "plt_replicate.pro", '.pro file in <a href="obj/plt/dir-overview.html">obj/plt/ directory</a>', "plt_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/plt/plt_replicate.html#plt_replicate", "plt_replicate", 'routine in <a href="obj/plt/plt_replicate.html">plt_replicate.pro</a>', "plt_replicate.pro", "", "plt_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "pd<code class= source > Planet descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/PLT", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_apply_condition.html", "pnt_apply_condition.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_apply_condition.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_apply_condition.html#pnt_apply_condition", "pnt_apply_condition", 'routine in <a href="obj/pnt/pnt_apply_condition.html">pnt_apply_condition.pro</a>', "pnt_apply_condition.pro", "", "pnt_apply_condition", "<code class= source >	Selects point in POINT structures based on a given condition structure.</code>  ", "ptd<code class= source >	Points object.</code>  condition<code class= source >Condition structure to compare against the flags</code> <code class= source >			contained in _ps.</code> <code class= source >			The condition structure is organized as follows:</code> <code class= source >			  field	   values</code> <code class= source >			  -----------------------------------------------------</code>  ", "NV/OBJ/PNT", "<code class= source >  	Spitale, 11/2015</code>  <code class= source >	Condition structure corresponding to the given keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO: pnt_points, pnt_vectors, pnt_data</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_assign.html", "pnt_assign.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_assign.html#pnt_assign", "pnt_assign", 'routine in <a href="obj/pnt/pnt_assign.html">pnt_assign.pro</a>', "pnt_assign.pro", "", "pnt_assign", "<code class= source >	Replaces fields in a POINT object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@pnt__keywords_tree.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		12/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_assoc_xd.html", "pnt_assoc_xd.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_assoc_xd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_assoc_xd.html#pnt_assoc_xd", "pnt_assoc_xd", 'routine in <a href="obj/pnt/pnt_assoc_xd.html">pnt_assoc_xd.pro</a>', "pnt_assoc_xd.pro", "", "pnt_assoc_xd", "<code class= source >	Returns the associated descriptor for a CORE object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >POINT object.</code>  ", "NV/SYS/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The associated descriptor for the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_assoc_xd</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_compress.html", "pnt_compress.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_compress.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_compress.html#pnt_compress", "pnt_compress", 'routine in <a href="obj/pnt/pnt_compress.html">pnt_compress.pro</a>', "pnt_compress.pro", "", "pnt_compress", "<code class= source >	Compresses many POINT objects into one.  Arrays are concatenated</code> <code class= source >	in the nv/np directions unless /nt is specified.  Point-by-point data</code> <code class= source >	arrays must be identical.</code>  ", "nt<code class= source >	If given, arrays are concatenated in the nt dimension.</code> <code class= source >			this requires that all input arrays have the same number</code> <code class= source >			of points (nv/np), and only one element in the nt</code> <code class= source >			direction.</code>  pptd<code class= source >	If given, this points object is used to store the</code> <code class= source >			result, rather than allocating a new one.</code>  ptd0", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_compress</code>  <code class= source >	POINT object containing the concatenated data.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_condition.html", "pnt_condition.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_condition.pro", "", "", "<code class= source >	Returns predefined condition structures for various common situations.</code>  ", "", "          -1", "<code class= source >  	Spitale, 11/2015</code>  ");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_create_descriptors.html", "pnt_create_descriptors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_create_descriptors.html#pnt_create_descriptors", "pnt_create_descriptors", 'routine in <a href="obj/pnt/pnt_create_descriptors.html">pnt_create_descriptors.pro</a>', "pnt_create_descriptors.pro", "", "pnt_create_descriptors", "<code class= source >	Creates and initializes a POINT object.</code>  ", "crdptdn@pnt__keywords_tree.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	Newly created and initialized POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_cull.html", "pnt_cull.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_cull.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_cull.html#pnt_cull", "pnt_cull", 'routine in <a href="obj/pnt/pnt_cull.html">pnt_cull.pro</a>', "pnt_cull.pro", "", "pnt_cull", "<code class= source >	Cleans out an array of POINT objects by removing POINT objects that are</code> <code class= source >	empty, or whose points all fail the specified conditions.</code>  ", "nofree<code class= source >	If set, invalid POINT object are not freed.</code>  condition_ptd<code class= source >Array of POINT objects.</code>  @pnt_condition_keywords.include", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_cull</code>  <code class= source >	Array POINT objects, or 0 if all were empty.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_data.html", "pnt_data.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_data.html#pnt_data", "pnt_data", 'routine in <a href="obj/pnt/pnt_data.html">pnt_data.pro</a>', "pnt_data.pro", "", "pnt_data", "<code class= source >	Returns the point-by-point data associated with a POINT object.</code>  ", "tags<code class= source >If given, data arrays are returned only for these tags,</code> <code class= source >		and are arranged in this order.</code>  sample<code class= source >	Sampling interval in the nv direction.  Default is 1.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code>  condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  noevent<code class= source >If set, no event is generated.</code>  ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The point-by-point data associated with the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_data</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_desc.html", "pnt_desc.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_desc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_desc.html#pnt_desc", "pnt_desc", 'routine in <a href="obj/pnt/pnt_desc.html">pnt_desc.pro</a>', "pnt_desc.pro", "", "pnt_desc", "<code class= source >	Returns the description associated with a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >POINT object.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The description associated with the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_desc</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_explode.html", "pnt_explode.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_explode.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_explode.html#pnt_explode", "pnt_explode", 'routine in <a href="obj/pnt/pnt_explode.html">pnt_explode.pro</a>', "pnt_explode.pro", "", "pnt_explode", "<code class= source >	Explodes a POINT object into single-point objects.</code>  ", "n<code class= source >If given, new objects will have nv = n instead of nv = 1.</code> <code class= source >		nv must be divisible by n.</code>  ptd<code class= source >	POINT object.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Adapted from pgs_explode:	Spitale, 11/2015</code>  <code class= source >	Array (nv/n x nt) of POINT objects, each containing a n points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_flags.html", "pnt_flags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_flags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_flags.html#pnt_flags", "pnt_flags", 'routine in <a href="obj/pnt/pnt_flags.html">pnt_flags.pro</a>', "pnt_flags.pro", "", "pnt_flags", "<code class= source >	Returns the flags associated with a POINT object.</code>  ", "sample<code class= source >	Sampling interval in the nv direction.  Default is 1.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code>  condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  noevent<code class= source >If set, no event is generated.</code>  ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The flags associated with the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_flags</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_input.html", "pnt_input.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_input.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_input.html#pnt_input", "pnt_input", 'routine in <a href="obj/pnt/pnt_input.html">pnt_input.pro</a>', "pnt_input.pro", "", "pnt_input", "<code class= source >	Returns the input description associated with a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >POINT object.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The input description associated with the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_input</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_nt.html", "pnt_nt.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_nt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_nt.html#pnt_nt", "pnt_nt", 'routine in <a href="obj/pnt/pnt_nt.html">pnt_nt.pro</a>', "pnt_nt.pro", "", "pnt_nt", "<code class= source >	Returns the nt dimension of a POINT object.</code>  ", "conditionnoevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >POINT object.</code>  @pnt_condition_keywords.include", "nt/SYS/PS", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The nt dimensions of the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_nv.html", "pnt_nv.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_nv.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_nv.html#pnt_nv", "pnt_nv", 'routine in <a href="obj/pnt/pnt_nv.html">pnt_nv.pro</a>', "pnt_nv.pro", "", "pnt_nv", "<code class= source >	Returns the nv dimension of a POINT object.</code>  ", "conditionnoevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >POINT object.</code>  @pnt_condition_keywords.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The nv dimensions of the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_offset.html", "pnt_offset.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_offset.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_offset.html#pnt_offset", "pnt_offset", 'routine in <a href="obj/pnt/pnt_offset.html">pnt_offset.pro</a>', "pnt_offset.pro", "", "pnt_offset", "<code class= source >	Offsets points in a POINT object.</code>  ", "noeventptd<code class= source >	POINT object.</code>  offset<code class= source >	Offset to apply.</code>  ", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_offset</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_points.html", "pnt_points.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_points.html#pnt_points", "pnt_points", 'routine in <a href="obj/pnt/pnt_points.html">pnt_points.pro</a>', "pnt_points.pro", "", "pnt_points", "<code class= source >	Returns the points associated with a POINT object.</code>  ", "segments<code class= source >Subscripts in the output array denoting segments in the</code> <code class= source >			(assumed) continuous curve due to the point selection</code> <code class= source >			conditions.</code>  sample<code class= source >	Sampling interval in the nv direction.  Default is 1.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  cat<code class= source >	If set, arrays from multiple input objects are</code> <code class= source >			concatenated.</code>  condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  noevent<code class= source >If set, no event is generated.</code>  ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The points associated with the POINT object, or zero.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_points</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_query.html", "pnt_query.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_query.html#pnt_query", "pnt_query", 'routine in <a href="obj/pnt/pnt_query.html">pnt_query.pro</a>', "pnt_query.pro", "", "pnt_query", "<code class= source >	Returns the fields associated with a POINT object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@pnt__keywords_tree.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 12/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_read.html", "pnt_read.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_read.pro", "", "", "<code class= source > 	Reads a POINT file.</code>  ", "", "          -1", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_read_ps</code>  ");
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_scale.html", "pnt_scale.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_scale.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_scale.html#pnt_scale", "pnt_scale", 'routine in <a href="obj/pnt/pnt_scale.html">pnt_scale.pro</a>', "pnt_scale.pro", "", "pnt_scale", "<code class= source >	Scales points in a POINT object.</code>  ", "noeventptd<code class= source >	POINT object.</code>  scale<code class= source >	Scale to apply.</code>  ", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_scale</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_assoc_xd.html", "pnt_set_assoc_xd.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_assoc_xd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_assoc_xd.html#pnt_set_assoc_xd", "pnt_set_assoc_xd", 'routine in <a href="obj/pnt/pnt_set_assoc_xd.html">pnt_set_assoc_xd.pro</a>', "pnt_set_assoc_xd.pro", "", "pnt_set_assoc_xd", "<code class= source >	Replaces the assoc_xd field in a CORE object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  assoc_xd<code class= source >New assoc_xd.</code>  ", "NV/SYS/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_data.html", "pnt_set_data.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_data.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_data.html#pnt_set_data", "pnt_set_data", 'routine in <a href="obj/pnt/pnt_set_data.html">pnt_set_data.pro</a>', "pnt_set_data.pro", "", "pnt_set_data", "<code class= source >	Replaces the point-by-point data in a POINT object.</code>  ", "tags<code class= source >If given, data arrays are replaced only for these tags, and in</code> <code class= source >		this order.</code>  noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  new_data", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_desc.html", "pnt_set_desc.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_desc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_desc.html#pnt_set_desc", "pnt_set_desc", 'routine in <a href="obj/pnt/pnt_set_desc.html">pnt_set_desc.pro</a>', "pnt_set_desc.pro", "", "pnt_set_desc", "<code class= source >	Replaces the description field in a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  desc<code class= source >	New description.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_flags.html", "pnt_set_flags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_flags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_flags.html#pnt_set_flags", "pnt_set_flags", 'routine in <a href="obj/pnt/pnt_set_flags.html">pnt_set_flags.pro</a>', "pnt_set_flags.pro", "", "pnt_set_flags", "<code class= source >	Replaces the flags in a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  flags<code class= source >	New flags array.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_input.html", "pnt_set_input.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_input.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_input.html#pnt_set_input", "pnt_set_input", 'routine in <a href="obj/pnt/pnt_set_input.html">pnt_set_input.pro</a>', "pnt_set_input.pro", "", "pnt_set_input", "<code class= source >	Replaces the input description field in a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  input", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_points.html", "pnt_set_points.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_points.html#pnt_set_points", "pnt_set_points", 'routine in <a href="obj/pnt/pnt_set_points.html">pnt_set_points.pro</a>', "pnt_set_points.pro", "", "pnt_set_points", "<code class= source >	Replaces the points in a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  points<code class= source >	New points array.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_tags.html", "pnt_set_tags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_tags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_tags.html#pnt_set_tags", "pnt_set_tags", 'routine in <a href="obj/pnt/pnt_set_tags.html">pnt_set_tags.pro</a>', "pnt_set_tags.pro", "", "pnt_set_tags", "<code class= source >	Replaces the tags in a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  tags<code class= source >	New tags array.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_set_vectors.html", "pnt_set_vectors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_set_vectors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_set_vectors.html#pnt_set_vectors", "pnt_set_vectors", 'routine in <a href="obj/pnt/pnt_set_vectors.html">pnt_set_vectors.pro</a>', "pnt_set_vectors.pro", "", "pnt_set_vectors", "<code class= source >	Replaces the vectors in a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >	POINT object.</code>  vectors<code class= source >New vectors array.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale		11/2015</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_tags.html", "pnt_tags.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_tags.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_tags.html#pnt_tags", "pnt_tags", 'routine in <a href="obj/pnt/pnt_tags.html">pnt_tags.pro</a>', "pnt_tags.pro", "", "pnt_tags", "<code class= source >	Returns the tags associated with a POINT object.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  ptd<code class= source >POINT object.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The tags associated with the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_tags</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_template.html", "pnt_template.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_template.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_template.html#pnt_template", "pnt_template", 'routine in <a href="obj/pnt/pnt_template.html">pnt_template.pro</a>', "pnt_template.pro", "", "pnt_template", "<code class= source >	Creates a new POINT using an existing one as a template.</code>  ", "ptd0<code class= source >	POINT object.</code>  ", "NV/OBJ/PNT", "<code class= source > 	Written:	Spitale, 11/2015</code>  <code class= source >	New POINT with array fields left blank.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_test.html", "pnt_test.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_test.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_test.html#pnt_test", "pnt_test", 'routine in <a href="obj/pnt/pnt_test.html">pnt_test.pro</a>', "pnt_test.pro", "", "pnt_test", "<code class= source >	Assesses the validity of a single POINT object.  This function</code> <code class= source >	differs from pnt_valid in that it simply returns true or false, rather</code> <code class= source >	than a list of validity flags.</code>  ", "generic<code class= source >If set, a generic input is test to determine whether</code> <code class= source >			it is a POINT object.  Its validity is not tested.</code>  noeventptd<code class= source >Array of POINT objects.</code>  ", "NV/OBJ/PNT", "<code class= source >  Spitale, 12/2015; 	Adapted from pgs_test</code>  <code class= source >	1 if the given POINT object is valid and contains points, 0 otherwise.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_test</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_threshold.html", "pnt_threshold.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_threshold.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_threshold.html#pnt_threshold", "pnt_threshold", 'routine in <a href="obj/pnt/pnt_threshold.html">pnt_threshold.pro</a>', "pnt_threshold.pro", "", "pnt_threshold", "<code class= source >	Flags points whose given indicator falls below or above a given</code> <code class= source >	threshold.</code>  ", "above<code class= source >If set, values above the theshold are allowed.</code>  below<code class= source >If set, values below the theshold are allowed.</code>  ptd<code class= source >	POINT object.</code>  indicators<code class= source >Values to be tested against the threshold.  One for</code> <code class= source >			each point in ptd.</code>  threshold<code class= source >Threshold value.</code>  ", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_threshold</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_uncompress.html", "pnt_uncompress.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_uncompress.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_uncompress.html#pnt_uncompress", "pnt_uncompress", 'routine in <a href="obj/pnt/pnt_uncompress.html">pnt_uncompress.pro</a>', "pnt_uncompress.pro", "", "pnt_uncompress", "<code class= source >	Explodes a compressed POINT object back into an array of POINT objects</code> <code class= source >	using the original POINT objects as a template.  The</code> <code class= source >	compressed POINT object is freed.</code>  ", "nn<code class= source >	If given, it is assumed that there are nn elements</code> <code class= source >			in the compressed array for each element in the</code> <code class= source >			original input arrays.</code>  pptd<code class= source >Compressed POINT object.</code>  ptd0", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_uncompress</code>  <code class= source >	Array of POINT objects containing the uncompressed data.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_valid.html", "pnt_valid.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_valid.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_valid.html#pnt_valid", "pnt_valid", 'routine in <a href="obj/pnt/pnt_valid.html">pnt_valid.pro</a>', "pnt_valid.pro", "", "pnt_valid", "<code class= source >	Assesses the validity of POINT objects.</code>  ", "noeventptd0", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_valid</code>  <code class= source >	Array of flags, one for each input PS.  1 indicates that the PS</code> <code class= source >	contains points.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_test</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_vectors.html", "pnt_vectors.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_vectors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_vectors.html#pnt_vectors", "pnt_vectors", 'routine in <a href="obj/pnt/pnt_vectors.html">pnt_vectors.pro</a>', "pnt_vectors.pro", "", "pnt_vectors", "<code class= source >	Returns the vectors associated with a POINT object.</code>  ", "sample<code class= source >	Sampling interval in the nv direction.  Default is 1.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code>  condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT objects, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  noevent<code class= source >If set, no event is generated.</code>  ptd0@pnt_condition_keywords.include", "NV/OBJ/PNT", "<code class= source > 	Written by:	Spitale, 11/2015</code>  <code class= source >	The vectors associated with the POINT object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code> <code class= source > SEE ALSO:</code> <code class= source >	pnt_set_vectors</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/pnt/pnt_write.html", "pnt_write.pro", '.pro file in <a href="obj/pnt/dir-overview.html">obj/pnt/ directory</a>', "pnt_write.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/pnt/pnt_write.html#pnt_write", "pnt_write", 'routine in <a href="obj/pnt/pnt_write.html">pnt_write.pro</a>', "pnt_write.pro", "", "pnt_write", "<code class= source > 	Writes a POINT object to a file.</code>  ", "bin<code class= source >If set, a binary POINT object file is written;</code> <code class= source > 		not currently implemented.</code>  noeventfilename<code class= source >Name of the file to write.</code>  ptd<code class= source >	POINT object to write.</code>  ", "NV/OBJ/PNT", "<code class= source >  Spitale, 11/2015; 	Adapted from pgs_write_ps</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/point_cloud.html", "point_cloud.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "point_cloud.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/point_cloud.html#point_cloud", "point_cloud", 'routine in <a href="obj/tools/composite/point_cloud.html">point_cloud.pro</a>', "point_cloud.pro", "", "point_cloud", "<code class= source >	Returns the sizes of the given bodies.</code>  ", "bx<code class= source >    BODY descriptor; nt.</code>  nv<code class= source >Number of points to generate.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	nt-element array giving random points within the body.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/project_map.html", "project_map.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "project_map.pro", "", "", "<code class= source >       Reprojects images.</code>  ", "", "          -1", "<code class= source >       Written by:     Spitale, 6/1998</code>  ");
  

libdata[libdataItem++] = new Array("obj/tools/radec_angle.html", "radec_angle.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_angle.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_angle.html#radec_angle", "radec_angle", 'routine in <a href="obj/tools/radec_angle.html">radec_angle.pro</a>', "radec_angle.pro", "", "radec_angle", "<code class= source >	Computes angles between vectors specified in the radec system.</code>  ", "radec1<code class= source >Array (nv,3,nt) giving the radec representation of the</code> <code class= source >		first vector.</code>  radec2<code class= source >Array (nv,3,nt) giving the radec representation of the</code> <code class= source >		second vector.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array (nv,nt) of angles between the input vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_image_bounds.html", "radec_image_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_image_bounds.html#radec_image_bounds", "radec_image_bounds", 'routine in <a href="obj/tools/radec_image_bounds.html">radec_image_bounds.pro</a>', "radec_image_bounds.pro", "", "radec_image_bounds", "<code class= source >	Determines radec coordinate ranges visible in an image described</code> <code class= source >	by a given camera descriptor.</code>  ", "slopborder_pts_imraminramaxdecmindecmaxcornersstatuscd<code class= source >Camera descripor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	ramin:	Minimum RA in image.</code> <code class= source >	ramax:	Maximum RA in image.</code> <code class= source >	decmin:	Minimum DEC in image.</code> <code class= source >	decmax:	Maximum DEC in image.</code> <code class= source >	border_pts_im:	Array (2,np) of points along the edge of the image.</code> <code class= source >	status:	-1 if no globe in the image, 0 otherwise.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/radec_to_image.html", "radec_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "radec_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/radec_to_image.html#radec_to_image", "radec_to_image", 'routine in <a href="obj/tools/composite/radec_to_image.html">radec_to_image.pro</a>', "radec_to_image.pro", "", "radec_to_image", "<code class= source >       Transforms points in polar ra/dec coords w.r.t the inertial frame</code> <code class= source >	to image coords.</code>  ", "body_ptscd<code class= source >Array of nt camera descriptors.</code>  p<code class= source >Array (nv x 3 x nt) of radec points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of image points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/radec_twist_to_cd.html", "radec_twist_to_cd.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "radec_twist_to_cd.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/radec_twist_to_cd.html#radec_twist_to_cd", "radec_twist_to_cd", 'routine in <a href="obj/tools/radec_twist_to_cd.html">radec_twist_to_cd.pro</a>', "radec_twist_to_cd.pro", "", "radec_twist_to_cd", "<code class= source >       Computes a camera orietation matrix from thegiven Euler angles.</code>  ", "cdra<code class= source >Right ascension relative to the inertial frame.</code>  dec<code class= source >Declination relative to the inertial frame.</code>  twist<code class= source >Twist angle relative to the inertial frame.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	cd:	Array (nt) of camera descriptors with new</code> <code class= source >		orientations.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/ray_points.html", "ray_points.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ray_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ray_points.html#ray_points", "ray_points", 'routine in <a href="obj/tools/ray_points.html">ray_points.pro</a>', "ray_points.pro", "", "ray_points", "<code class= source >       Computes points along rays.</code>  ", "cdr<code class= source >Array (nt) of inertial ray origins.</code>  v<code class= source >Array (nt) of inertial ray directions, of unit length.</code>  np<code class= source >Number of points to compute on each ray.</code>  dp<code class= source >Point spacing.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	If no camera descriptor is given, an array (np,3,nt) of inertial</code> <code class= source >	position vectors is returned.  If cd is given, an array (2,np,nt)</code> <code class= source >	of image points is returned.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/ray_sub_point_graphic.html", "ray_sub_point_graphic.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ray_sub_point_graphic.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ray_sub_point_graphic.html#ray_sub_point_graphic", "ray_sub_point_graphic", 'routine in <a href="obj/tools/ray_sub_point_graphic.html">ray_sub_point_graphic.pro</a>', "ray_sub_point_graphic.pro", "", "ray_sub_point_graphic", "<code class= source >	Iterates to find the point on the surface of the globe where the</code> <code class= source >	given ray is closest to the surface.</code>  ", "vvnormalpdv<code class= source >Array (nv,3) giving the ray origins in the BODY frame.</code>  r<code class= source >Array (nv,3) giving the ray directions in the BODY frame.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (nv,3) of closest approach poitns in the BODY frame.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/raytrace.html", "raytrace.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "raytrace.pro", "", "", "<code class= source >	Traces rays from a camera to a set of objects.</code>   ", "", "          -1", "<code class= source > 	Written by:	Spitale</code>  <code class= source > STATUS:</code> <code class= source >	Complete</code> ");
  

libdata[libdataItem++] = new Array("obj/tools/render.html", "render.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "render.pro", "", "", "<code class= source >	Performs rendering on an array of bodies.</code>   ", "", "          -1", "<code class= source > 	Written by:	Spitale</code>  <code class= source > STATUS:</code> <code class= source >	Complete</code> ");
  

libdata[libdataItem++] = new Array("obj/tools/reproject_image.html", "reproject_image.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "reproject_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/reproject_image.html#reproject_image", "reproject_image", 'routine in <a href="obj/tools/reproject_image.html">reproject_image.pro</a>', "reproject_image.pro", "", "reproject_image", "<code class= source >       xx</code>  ", "cd<code class= source >    Camera descriptor.</code>  new_cdsizeinterparg_interpimage<code class= source >    Image of body.</code>  pc_xsize<code class= source >    x size of map workspace</code>  pc_ysize<code class= source >    y size of map workspace</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale, 6/1998</code>  <code class= source >       The reprojected image.</code>  ");
  
  

libdata[libdataItem++] = new Array("grim/rim.html", "rim.pro", '.pro file in <a href="grim/dir-overview.html">grim/ directory</a>', "rim.pro", "", "", "<code class= source >	Prints the headers, or specific header values, for the specified files.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale, 8/2013</code>  ");
  

libdata[libdataItem++] = new Array("obj/tools/ringplane_radial_bounds.html", "ringplane_radial_bounds.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "ringplane_radial_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/ringplane_radial_bounds.html#ringplane_radial_bounds", "ringplane_radial_bounds", 'routine in <a href="obj/tools/ringplane_radial_bounds.html">ringplane_radial_bounds.pro</a>', "ringplane_radial_bounds.pro", "", "ringplane_radial_bounds", "<code class= source >	Finds ringplane radial bounds by projecting the camera FOV on</code> <code class= source >	the ringplane.</code>  ", "cd<code class= source >Camera descriptor.</code>  dkx<code class= source >Any subclass of DISK.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >       Array (2) giving the minimum and maximum disk radii visible</code> <code class= source >	to the camera.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_assign.html", "rng_assign.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_assign.html#rng_assign", "rng_assign", 'routine in <a href="obj/rng/rng_assign.html">rng_assign.pro</a>', "rng_assign.pro", "", "rng_assign", "<code class= source >	Replaces fields in a RING object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@rng__keywords_tree.include", "NV/OBJ/RNG", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_create_descriptors.html", "rng_create_descriptors.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_create_descriptors.html#rng_create_descriptors", "rng_create_descriptors", 'routine in <a href="obj/rng/rng_create_descriptors.html">rng_create_descriptors.pro</a>', "rng_create_descriptors.pro", "", "rng_create_descriptors", "<code class= source >	Init method for the RING class.</code>  ", "crd<code class= source >Core descriptor(s) to pass to cor_create_descriptors.</code>  bd<code class= source >Body descriptor(s) to pass to bod_create_descriptors.</code>  sld<code class= source >Solid descriptor(s) to pass to sld_create_descriptors.</code>  dkd<code class= source >Disk descriptor(s) to pass to dsk_create_descriptors.</code>  rd<code class= source >Ring descriptor(s) to initialize, instead of creating new</code> <code class= source >		ones.</code>  n<code class= source >     Number of ring descriptors.</code>  @rng__keywords_tree.include", "NV/LIB/RNG", "<code class= source >       Written by:     Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (n) of ring descriptors.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_desc.html", "rng_desc.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_desc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_desc.html#rng_desc", "rng_desc", 'routine in <a href="obj/rng/rng_desc.html">rng_desc.pro</a>', "rng_desc.pro", "", "rng_desc", "<code class= source >	Returns the description string for each given ring descriptor.</code>  ", "noeventrd<code class= source > Array (nt) of RING descriptors.</code>  ", "NV/LIB/RNG", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Description string associated with each given ring descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_evolve.html", "rng_evolve.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_evolve.html#rng_evolve", "rng_evolve", 'routine in <a href="obj/rng/rng_evolve.html">rng_evolve.pro</a>', "rng_evolve.pro", "", "rng_evolve", "<code class= source >	Computes new ring descriptors at the given time offsets from the</code> <code class= source >	given ring descriptors using the taylor series expansion</code> <code class= source >	corresponding to the derivatives contained in the given ring</code> <code class= source >	descriptor.</code>  ", "nodv<code class= source > If set, derivatives will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  rd<code class= source > Any subclass of RING.</code>  dt<code class= source > Time offset.</code>  ", "NV/LIB/RNG", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nrd,ndt) of newly allocated descriptors, of class RING,</code> <code class= source >	evolved by time dt, where nrd is the number of rd, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_query.html", "rng_query.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_query.html#rng_query", "rng_query", 'routine in <a href="obj/rng/rng_query.html">rng_query.pro</a>', "rng_query.pro", "", "rng_query", "<code class= source >	Returns the fields associated with a RING object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@rng__keywords_tree.include", "NV/OBJ/RNG", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_replicate.html", "rng_replicate.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_replicate.html#rng_replicate", "rng_replicate", 'routine in <a href="obj/rng/rng_replicate.html">rng_replicate.pro</a>', "rng_replicate.pro", "", "rng_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "rd<code class= source > Ring descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/RNG", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/rng/rng_set_desc.html", "rng_set_desc.pro", '.pro file in <a href="obj/rng/dir-overview.html">obj/rng/ directory</a>', "rng_set_desc.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/rng/rng_set_desc.html#rng_set_desc", "rng_set_desc", 'routine in <a href="obj/rng/rng_set_desc.html">rng_set_desc.pro</a>', "rng_set_desc.pro", "", "rng_set_desc", "<code class= source >	Replaces the description string in each given ring descriptor.</code>  ", "noeventrd<code class= source >Array (nt) of STATION descriptors.</code>  desc<code class= source >Array (nt) of description strings.</code>  ", "NV/LIB/RNG", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/set_image_origin.html", "set_image_origin.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "set_image_origin.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/set_image_origin.html#set_image_origin", "set_image_origin", 'routine in <a href="obj/tools/composite/set_image_origin.html">set_image_origin.pro</a>', "set_image_origin.pro", "", "set_image_origin", "<code class= source >	Sets the origin of a map or camera image.</code>  ", "cdorigin<code class= source >origin argument as in map_set_origin</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	NONE.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/set_image_size.html", "set_image_size.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "set_image_size.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/set_image_size.html#set_image_size", "set_image_size", 'routine in <a href="obj/tools/composite/set_image_size.html">set_image_size.pro</a>', "set_image_size.pro", "", "set_image_size", "<code class= source >	Sets the size of a map or camera image.</code>  ", "cdsize<code class= source >	 Size argument as in map_set_size</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >	NONE.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/set_primary.html", "set_primary.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "set_primary.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/set_primary.html#set_primary", "set_primary", 'routine in <a href="obj/tools/set_primary.html">set_primary.pro</a>', "set_primary.pro", "", "set_primary", "<code class= source >	Sets the primary descriptor in the generic descriptor of the given</code> <code class= source >	object.</code>  ", "xd<code class= source >Any object descritor.</code>  bx0<code class= source >Primary descriptor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale		7/2017</code>  <code class= source >       NONE</code> <code class= source > KEYOWRDS:</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_albedo.html", "sld_albedo.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_albedo.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_albedo.html#sld_albedo", "sld_albedo", 'routine in <a href="obj/sld/sld_albedo.html">sld_albedo.pro</a>', "sld_albedo.pro", "", "sld_albedo", "<code class= source >       Returns the bond albedo for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of albedos associated with each given solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_assign.html", "sld_assign.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_assign.html#sld_assign", "sld_assign", 'routine in <a href="obj/sld/sld_assign.html">sld_assign.pro</a>', "sld_assign.pro", "", "sld_assign", "<code class= source >	Replaces fields in a SOLID object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@sld__keywords_tree.include", "NV/OBJ/SLD", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_create_descriptors.html", "sld_create_descriptors.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_create_descriptors.html#sld_create_descriptors", "sld_create_descriptors", 'routine in <a href="obj/sld/sld_create_descriptors.html">sld_create_descriptors.pro</a>', "sld_create_descriptors.pro", "", "sld_create_descriptors", "<code class= source >	Init method for the SOLID class.</code>  ", "crdbdsldn<code class= source >Number of descriptors to create.</code>  @sld__keywords_tree.include", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Newly created or or freshly initialized solid descriptors, depending</code> <code class= source >	on the presence of the bd keyword.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_evolve.html", "sld_evolve.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_evolve.html#sld_evolve", "sld_evolve", 'routine in <a href="obj/sld/sld_evolve.html">sld_evolve.pro</a>', "sld_evolve.pro", "", "sld_evolve", "<code class= source >       Computes new solid descriptors at the given time offsets from</code> <code class= source >       the given solid descriptors using the taylor series expansion</code> <code class= source >       corresponding to the derivatives contained in the given solid</code> <code class= source >       descriptor.</code>  ", "nodv<code class= source > If set, velocities will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  sld<code class= source > Array (nsld) of any subclass of SOLID descriptors.</code>  dt<code class= source > Array (ndt) of time offsets.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (ngd,ndt) of newly allocated solid descriptors evolved</code> <code class= source >       by time dt, where ngd is the number of sld, and ndt is the</code> <code class= source >       number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_extn_fn.html", "sld_extn_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_extn_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_extn_fn.html#sld_extn_fn", "sld_extn_fn", 'routine in <a href="obj/sld/sld_extn_fn.html">sld_extn_fn.pro</a>', "sld_extn_fn.pro", "", "sld_extn_fn", "<code class= source >       Returns the name of the extinction function for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 9/2017</code>  <code class= source >       Array (nt) of extinction function names associated with each given</code> <code class= source >	solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_extn_parm.html", "sld_extn_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_extn_parm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_extn_parm.html#sld_extn_parm", "sld_extn_parm", 'routine in <a href="obj/sld/sld_extn_parm.html">sld_extn_parm.pro</a>', "sld_extn_parm.pro", "", "sld_extn_parm", "<code class= source >       Returns the extinction function parameters for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 9/2017</code>  <code class= source >       Array (npht,nt) of extinction function parameters associated with</code> <code class= source >	each given solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_gm.html", "sld_gm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_gm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_gm.html#sld_gm", "sld_gm", 'routine in <a href="obj/sld/sld_gm.html">sld_gm.pro</a>', "sld_gm.pro", "", "sld_gm", "<code class= source >       Returns the GM value for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of GM values associated with each given solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_mass.html", "sld_mass.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_mass.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_mass.html#sld_mass", "sld_mass", 'routine in <a href="obj/sld/sld_mass.html">sld_mass.pro</a>', "sld_mass.pro", "", "sld_mass", "<code class= source >       Returns the mass for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of mass values associated with each given solid</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_npht.html", "sld_npht.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_npht.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_npht.html#sld_npht", "sld_npht", 'routine in <a href="obj/sld/sld_npht.html">sld_npht.pro</a>', "sld_npht.pro", "", "sld_npht", "<code class= source >	Returns an integer indicating the maximum number of parameters</code> <code class= source >	allowed in the refl_parm and phase-parm fields of the solid</code> <code class= source >	descriptor.  This number can be adjusted using the environment</code> <code class= source >	variable 'SLD_NPHT'.  The default is 4.</code>  <code class= source >Environment variables: </code> <code class= source >	SLD_NPHT:	Sets the npht value.</code>  ", "", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code>  <code class= source >	Current npht value.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_opacity.html", "sld_opacity.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_opacity.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_opacity.html#sld_opacity", "sld_opacity", 'routine in <a href="obj/sld/sld_opacity.html">sld_opacity.pro</a>', "sld_opacity.pro", "", "sld_opacity", "<code class= source >	Returns the opacity for each given solid descriptor.</code>  ", "noeventsld", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Opacity value associated with each given solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase.html", "sld_phase.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_phase.html#sld_phase", "sld_phase", 'routine in <a href="obj/sld/sld_phase.html">sld_phase.pro</a>', "sld_phase.pro", "", "sld_phase", "<code class= source >	Computes a phase function.</code>  <code class= source >	The function indicated by the phase_fn field of the solid descriptor</code> <code class= source >	is called and its return value is passed through to the caller of</code> <code class= source >	sld_phase.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "sld<code class= source > Globe descriptor.</code>  mu<code class= source > Cosine of the emission angle.</code>  mu0<code class= source > Cosine of the incidence angle.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Phase function value for the given mu and mu0 parameters.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase_fn.html", "sld_phase_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_phase_fn.html#sld_phase_fn", "sld_phase_fn", 'routine in <a href="obj/sld/sld_phase_fn.html">sld_phase_fn.pro</a>', "sld_phase_fn.pro", "", "sld_phase_fn", "<code class= source >       Returns the name of the phase function for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of phase function names associated with each given solid</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_phase_parm.html", "sld_phase_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_phase_parm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_phase_parm.html#sld_phase_parm", "sld_phase_parm", 'routine in <a href="obj/sld/sld_phase_parm.html">sld_phase_parm.pro</a>', "sld_phase_parm.pro", "", "sld_phase_parm", "<code class= source >       Returns the phase function parameters for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (npht,nt) of phase function parameters associated with each</code> <code class= source >	given solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_query.html", "sld_query.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_query.html#sld_query", "sld_query", 'routine in <a href="obj/sld/sld_query.html">sld_query.pro</a>', "sld_query.pro", "", "sld_query", "<code class= source >	Returns the fields associated with a CAMERA object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@sld__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl.html", "sld_refl.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_refl.html#sld_refl", "sld_refl", 'routine in <a href="obj/sld/sld_refl.html">sld_refl.pro</a>', "sld_refl.pro", "", "sld_refl", "<code class= source >	Computes a reflection function.</code>  <code class= source >	The function indicated by the refl_fn field of the solid descriptor</code> <code class= source >	is called and its return value is passed through to the caller of</code> <code class= source >	sld_phase.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ", "sld<code class= source > Globe descriptor.</code>  mu<code class= source > Cosine of the emission angle.</code>  mu0<code class= source > Cosine of the incidence angle.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Refletion function value for the given mu and mu0 parameters.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl_fn.html", "sld_refl_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_refl_fn.html#sld_refl_fn", "sld_refl_fn", 'routine in <a href="obj/sld/sld_refl_fn.html">sld_refl_fn.pro</a>', "sld_refl_fn.pro", "", "sld_refl_fn", "<code class= source >       Returns the name of the reflection function for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (nt) of reflection function names associated with each given</code> <code class= source >	solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_refl_parm.html", "sld_refl_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_refl_parm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_refl_parm.html#sld_refl_parm", "sld_refl_parm", 'routine in <a href="obj/sld/sld_refl_parm.html">sld_refl_parm.pro</a>', "sld_refl_parm.pro", "", "sld_refl_parm", "<code class= source >       Returns the reflection function parameters for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       Array (npht,nt) of reflection function parameters associated with</code> <code class= source >	each given solid descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_albedo.html", "sld_set_albedo.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_albedo.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_albedo.html#sld_set_albedo", "sld_set_albedo", 'routine in <a href="obj/sld/sld_set_albedo.html">sld_set_albedo.pro</a>', "sld_set_albedo.pro", "", "sld_set_albedo", "<code class= source >       Replaces the bond albedo for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  albedo<code class= source > Array (nt) of new bond albedos.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_extn_fn.html", "sld_set_extn_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_extn_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_extn_fn.html#sld_set_extn_fn", "sld_set_extn_fn", 'routine in <a href="obj/sld/sld_set_extn_fn.html">sld_set_extn_fn.pro</a>', "sld_set_extn_fn.pro", "", "sld_set_extn_fn", "<code class= source >       Replaces the extinction function for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  extn_fn<code class= source >Array (nt) of new extinction functions.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 9/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_extn_parm.html", "sld_set_extn_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_extn_parm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_extn_parm.html#sld_set_extn_parm", "sld_set_extn_parm", 'routine in <a href="obj/sld/sld_set_extn_parm.html">sld_set_extn_parm.pro</a>', "sld_set_extn_parm.pro", "", "sld_set_extn_parm", "<code class= source >       Replaces the extinction function parameters for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source >	Array (nt) of any subclass of SOLID descriptors.</code>  extn_parm<code class= source >Array (nt) of new extinction function parameters.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 9/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_gm.html", "sld_set_gm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_gm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_gm.html#sld_set_gm", "sld_set_gm", 'routine in <a href="obj/sld/sld_set_gm.html">sld_set_gm.pro</a>', "sld_set_gm.pro", "", "sld_set_gm", "<code class= source >       Replaces the GM value for each given solid descriptor.</code>  ", "nosynchnoeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  gm<code class= source > Array (nt) of new GM values.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_mass.html", "sld_set_mass.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_mass.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_mass.html#sld_set_mass", "sld_set_mass", 'routine in <a href="obj/sld/sld_set_mass.html">sld_set_mass.pro</a>', "sld_set_mass.pro", "", "sld_set_mass", "<code class= source >       Replaces the mass for each given solid descriptor.</code>  ", "nosynchnoeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  mass", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_opacity.html", "sld_set_opacity.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_opacity.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_opacity.html#sld_set_opacity", "sld_set_opacity", 'routine in <a href="obj/sld/sld_set_opacity.html">sld_set_opacity.pro</a>', "sld_set_opacity.pro", "", "sld_set_opacity", "<code class= source >	Replaces the opacity of each given solid descriptor.</code>  ", "noeventsld<code class= source > Any subclass of SOLID.</code>  opacity<code class= source > New opacity value.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 7/2015</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_fn.html", "sld_set_phase_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_phase_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_fn.html#sld_set_phase_fn", "sld_set_phase_fn", 'routine in <a href="obj/sld/sld_set_phase_fn.html">sld_set_phase_fn.pro</a>', "sld_set_phase_fn.pro", "", "sld_set_phase_fn", "<code class= source >       Replaces the phase function for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  phase_fn<code class= source >Array (nt) of new phase functions.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_parm.html", "sld_set_phase_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_phase_parm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_phase_parm.html#sld_set_phase_parm", "sld_set_phase_parm", 'routine in <a href="obj/sld/sld_set_phase_parm.html">sld_set_phase_parm.pro</a>', "sld_set_phase_parm.pro", "", "sld_set_phase_parm", "<code class= source >       Replaces the phase function parameters for each given solid descriptor.</code>  ", "noeventsld<code class= source >	Array (nt) of any subclass of SOLID descriptors.</code>  phase_parm<code class= source >Array (nt) of new phase function parameters.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 3/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_fn.html", "sld_set_refl_fn.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_refl_fn.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_fn.html#sld_set_refl_fn", "sld_set_refl_fn", 'routine in <a href="obj/sld/sld_set_refl_fn.html">sld_set_refl_fn.pro</a>', "sld_set_refl_fn.pro", "", "sld_set_refl_fn", "<code class= source >       Replaces the reflection function for each given solid descriptor.</code>  ", "noeventsld<code class= source > Array (nt) of any subclass of SOLID descriptors.</code>  refl_fn<code class= source >Array (nt) of new reflection functions.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_parm.html", "sld_set_refl_parm.pro", '.pro file in <a href="obj/sld/dir-overview.html">obj/sld/ directory</a>', "sld_set_refl_parm.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/sld/sld_set_refl_parm.html#sld_set_refl_parm", "sld_set_refl_parm", 'routine in <a href="obj/sld/sld_set_refl_parm.html">sld_set_refl_parm.pro</a>', "sld_set_refl_parm.pro", "", "sld_set_refl_parm", "<code class= source >       Replaces the reflection function parameters for each given solid</code> <code class= source >	descriptor.</code>  ", "noeventsld<code class= source >	Array (nt) of any subclass of SOLID descriptors.</code>  refl_parm<code class= source >Array (nt) of new reflection function parameters.</code>  ", "NV/LIB/SLD", "<code class= source > 	Written by:	Spitale, 3/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab.html", "stellab.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab.html#stellab", "stellab", 'routine in <a href="obj/tools/stellab.html">stellab.pro</a>', "stellab.pro", "", "stellab", "<code class= source >	Corrects body positions for stellar aberration on objects for which the</code> <code class= source >	correction has not already been performed..</code>  ", "c<code class= source >	Speed of light.</code>  fastinvert<code class= source >	If set, the inverse correction is performed.</code>  obs_bx<code class= source >	Array (nt) of any subclass of BODY describing</code> <code class= source >			the observer.</code>  _targ_bx<code class= source >Array (nt) of any subclass of BODY describing</code> <code class= source >			the target.  The position of this body is modified.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab_pos.html", "stellab_pos.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab_pos.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab_pos.html#stellab_pos", "stellab_pos", 'routine in <a href="obj/tools/stellab_pos.html">stellab_pos.pro</a>', "stellab_pos.pro", "", "stellab_pos", "<code class= source >	Corrects positions for stellar aberration.</code>  ", "c<code class= source >Speed of light.</code>  axis<code class= source >Array (nv,3) of rotation axes corresponding to each</code> <code class= source >		correction.</code>  theta<code class= source >Array (nv) of rotation angles corresponding to each</code> <code class= source >		correction.</code>  fastpos<code class= source >Array (nv,3) of target inertial position vectors to be</code> <code class= source >		corrected.</code>  vel<code class= source >Array (nv,3) of observer inertial velocity vectors.</code> <code class= source >		Note observer is assumed to be at the origin.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (nv,3) of corrected position vectors.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/stellab_radec.html", "stellab_radec.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stellab_radec.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stellab_radec.html#stellab_radec", "stellab_radec", 'routine in <a href="obj/tools/stellab_radec.html">stellab_radec.pro</a>', "stellab_radec.pro", "", "stellab_radec", "<code class= source >	Corrects positions given in the radec system for stellar</code> <code class= source >	aberration.</code>  ", "c<code class= source >Speed of light.</code>  radec<code class= source >Array (nv,3) of target inertial position vectors to be</code> <code class= source >		corrected, given in the radec system.</code>  vel<code class= source >Array (nv,3) of observer inertial velocity vectors.</code> <code class= source >		Note observer is assumed to be at the origin.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (nv,3) of corrected position vectors in the radec system.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/stereo_split.html", "stereo_split.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "stereo_split.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/stereo_split.html#stereo_split", "stereo_split", 'routine in <a href="obj/tools/stereo_split.html">stereo_split.pro</a>', "stereo_split.pro", "", "stereo_split", "<code class= source >       Splits a given camera descriptor into a stereo pair.</code>  ", "sepcd<code class= source >Camera descriptor.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Array (2) giving the left and right camera descriptors.</code> <code class= source >	Each descriptor is cloned from the input descripor, and has</code> <code class= source >	been translated +/- sep/2 in the camara body 0-axis direction.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_assign.html", "stn_assign.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_assign.html#stn_assign", "stn_assign", 'routine in <a href="obj/stn/stn_assign.html">stn_assign.pro</a>', "stn_assign.pro", "", "stn_assign", "<code class= source >	Replaces fields in a STATION object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@stn__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_create_descriptors.html", "stn_create_descriptors.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_create_descriptors.html#stn_create_descriptors", "stn_create_descriptors", 'routine in <a href="obj/stn/stn_create_descriptors.html">stn_create_descriptors.pro</a>', "stn_create_descriptors.pro", "", "stn_create_descriptors", "<code class= source >	Init method for the STATION class.</code>  ", "crd<code class= source >Core descriptor(s) to pass to cor_create_descriptors.</code>  bd<code class= source >Body descriptor(s) to pass to bod_create_descriptors.</code>  std<code class= source >Station descriptor(s) to initialize, instead of creating new</code> <code class= source >		ones.</code>  n<code class= source >     Number of station descriptors.</code>  @stn__keywords_tree.include", "NV/LIB/STN", "<code class= source >       Written by:     Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (n) of station descriptors.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_evolve.html", "stn_evolve.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_evolve.html#stn_evolve", "stn_evolve", 'routine in <a href="obj/stn/stn_evolve.html">stn_evolve.pro</a>', "stn_evolve.pro", "", "stn_evolve", "<code class= source >	Computes new station descriptors at the given time offsets from the</code> <code class= source >	given station descriptors using the taylor series expansion</code> <code class= source >	corresponding to the derivatives contained in the given station</code> <code class= source >	descriptor.</code>  ", "nodv<code class= source > If set, derivatives will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  stddt<code class= source > Time offset.</code>  ", "NV/LIB/STN", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nstd,ndt) of newly allocated descriptors, of class STATION,</code> <code class= source >	evolved by time dt, where nstd is the number of stx, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_query.html", "stn_query.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_query.html#stn_query", "stn_query", 'routine in <a href="obj/stn/stn_query.html">stn_query.pro</a>', "stn_query.pro", "", "stn_query", "<code class= source >	Returns the fields associated with a STATION object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@stn__keywords_tree.include", "NV/OBJ/CAM", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_replicate.html", "stn_replicate.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_replicate.html#stn_replicate", "stn_replicate", 'routine in <a href="obj/stn/stn_replicate.html">stn_replicate.pro</a>', "stn_replicate.pro", "", "stn_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "std<code class= source > Station descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/STN", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_set_surface_pt.html", "stn_set_surface_pt.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_set_surface_pt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_set_surface_pt.html#stn_set_surface_pt", "stn_set_surface_pt", 'routine in <a href="obj/stn/stn_set_surface_pt.html">stn_set_surface_pt.pro</a>', "stn_set_surface_pt.pro", "", "stn_set_surface_pt", "<code class= source >	Replaces the surface_pt vector in each given station descriptor.</code>  ", "noeventstd<code class= source >Array (nt) of STATION descriptors.</code>  surface_pt<code class= source >Array (1,3,nt) of surface_pt vectors.</code>  ", "NV/LIB/STN", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/stn/stn_surface_pt.html", "stn_surface_pt.pro", '.pro file in <a href="obj/stn/dir-overview.html">obj/stn/ directory</a>', "stn_surface_pt.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/stn/stn_surface_pt.html#stn_surface_pt", "stn_surface_pt", 'routine in <a href="obj/stn/stn_surface_pt.html">stn_surface_pt.pro</a>', "stn_surface_pt.pro", "", "stn_surface_pt", "<code class= source >	Returns the surface_pt vector for each given station descriptor.</code>  ", "noeventstd<code class= source > Array (nt) of STATION descriptors.</code>  ", "NV/LIB/STN", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (1,3,nt) of surface_pt vectors associated with each given</code> <code class= source >	station descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_assign.html", "str_assign.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_assign.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_assign.html#str_assign", "str_assign", 'routine in <a href="obj/str/str_assign.html">str_assign.pro</a>', "str_assign.pro", "", "str_assign", "<code class= source >	Replaces fields in a STAR object.  This is a convenient way of</code> <code class= source >	setting multiple fields in one call, and only a single event is</code> <code class= source >	generated.</code>  ", "noevent<code class= source >If set, no event is generated.</code>  xd@str__keywords_tree.include", "NV/OBJ/STR", "<code class= source > 	Written by:	Spitale		2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_create_descriptors.html", "str_create_descriptors.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_create_descriptors.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_create_descriptors.html#str_create_descriptors", "str_create_descriptors", 'routine in <a href="obj/str/str_create_descriptors.html">str_create_descriptors.pro</a>', "str_create_descriptors.pro", "", "str_create_descriptors", "<code class= source >	Init method for the STAR class.</code>  ", "crd<code class= source >Core descriptor(s) to pass to cor_create_descriptors.</code>  bd<code class= source >Body descriptor(s) to pass to bod_create_descriptors.</code>  sld<code class= source >Solid descriptor(s) to pass to sld_create_descriptors.</code>  gbd<code class= source >Globe descriptor(s) to pass to glb_create_descriptors.</code>  sd<code class= source >Star descriptor(s) to initialize, instead of creating new ones.</code>  n<code class= source >     Number of star descriptors.</code>  @str__keywords_tree.include", "NV/LIB/STR", "<code class= source >       Written by:     Haemmerle, 5/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (n) of star descriptors.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_evolve.html", "str_evolve.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_evolve.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_evolve.html#str_evolve", "str_evolve", 'routine in <a href="obj/str/str_evolve.html">str_evolve.pro</a>', "str_evolve.pro", "", "str_evolve", "<code class= source >	Computes new star descriptors at the given time offsets from the</code> <code class= source >	given star descriptors using the taylor series expansion</code> <code class= source >	corresponding to the derivatives contained in the given star</code> <code class= source >	descriptor.</code>  ", "nodv<code class= source > If set, derivatives will not be evolved.</code>  copy<code class= source >If set, the evolved descriptor is copied into the input</code> <code class= source >		descriptor and it is freed.  The input descriptor is returned.</code>  sddt<code class= source > Time offset.</code>  ", "NV/LIB/STR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array (nsd,ndt) of newly allocated descriptors, of class STAR,</code> <code class= source >	evolved by time dt, where nsd is the number of sx, and ndt</code> <code class= source >	is the number of dt.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_get_flux.html", "str_get_flux.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_get_flux.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_get_flux.html#str_get_flux", "str_get_flux", 'routine in <a href="obj/str/str_get_flux.html">str_get_flux.pro</a>', "str_get_flux.pro", "", "str_get_flux", "<code class= source >       Calculates the flux (power/area) for each given star relative to</code> <code class= source >	a given observer.</code>  ", "od<code class= source >Observer descriptor.</code>  sd<code class= source >   Array (nt) of star descriptors.</code>  ", "NV/LIB/STR", "<code class= source >       Written by:     Spitale, 8/2017</code>  <code class= source >       An array (nt) of fluxes.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_get_mag.html", "str_get_mag.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_get_mag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_get_mag.html#str_get_mag", "str_get_mag", 'routine in <a href="obj/str/str_get_mag.html">str_get_mag.pro</a>', "str_get_mag.pro", "", "str_get_mag", "<code class= source >       Calculates the visual magnitude for each given star descriptor.</code>  <code class= source >       Calls str_body to get the position vector.  The position is assumed</code> <code class= source >       to be in meters and the Luminosity (sds.lum) is in J/sec.  Absolute</code> <code class= source >       visual magnitude is calculated by using the formula for the Sun.</code> <code class= source >       Mv = 4.83 - 2.5 log (L/Lsun)</code> <code class= source >       where Lsun = 3.826e+26 J/sec</code> <code class= source >       Visual magnitude is corrected by using the distance modulus.</code> <code class= source >       m = Mv + 5 log (dist/pc) - 5</code> <code class= source >       where pc = 3.085678e+16 m  (parsec)</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ", "od<code class= source >Observer descriptor.  If not given, the absolute magnitude is</code> <code class= source >		returned.</code>  sd<code class= source >   Array (nt) of star descriptors.</code>  ", "NV/LIB/STR", "<code class= source >       Written by:     Haemmerle, 5/1998</code> <code class= source >	Modified by:	Haemmerle, 12/2000</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code> <code class= source >       Modified by:    Haemmerle, 7/2017</code>  <code class= source >       An array (nt) of magnitues.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_limit_mag.html", "str_limit_mag.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_limit_mag.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_limit_mag.html#str_limit_mag", "str_limit_mag", 'routine in <a href="obj/str/str_limit_mag.html">str_limit_mag.pro</a>', "str_limit_mag.pro", "", "str_limit_mag", "<code class= source >       Returns subscripts of stars with magnitudes within the min, max range.</code>  ", "min<code class= source >   Minimum threshold for magnitude.</code>  max<code class= source >   Maximum threshold for magnitude.</code>  sd<code class= source >   Array of star descriptors.</code>  ", "NV/LIB/STR", "<code class= source >       Written by:     Haemmerle, 5/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array of subscripts into sd for stars fitting</code> <code class= source >	min &lt;=  magnitude &lt;= max.</code> <code class= source > SEE ALSO:</code> <code class= source >	pg_str_limit_mag</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_lum.html", "str_lum.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_lum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_lum.html#str_lum", "str_lum", 'routine in <a href="obj/str/str_lum.html">str_lum.pro</a>', "str_lum.pro", "", "str_lum", "<code class= source >       Returns a luminosity for each given star descriptor.</code>  ", "noeventsd<code class= source >   Array (nt) of star descriptors</code>  ", "NV/LIB/STR", "<code class= source >       Written by:     Haemmerle, 5/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (nt) of luminosities.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_query.html", "str_query.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_query.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_query.html#str_query", "str_query", 'routine in <a href="obj/str/str_query.html">str_query.pro</a>', "str_query.pro", "", "str_query", "<code class= source >	Returns the fields associated with a STAR object.  This is a</code> <code class= source >	convenient way of getting multiple fields in one call, and only a</code> <code class= source >	single event is generated.</code>  ", "condition<code class= source >Structure specifing a mask and a condition with which to</code> <code class= source >			match flag values.  The structure must contain the fields</code> <code class= source >			MASK and STATE.  MASK is a bitmask to test against</code> <code class= source >			the flags field of the POINT object, and STATE</code> <code class= source >			is either PS_TRUE and PS_FALSE.  Note that in this case,</code> <code class= source >			the values will be returned as a list, with no separation</code> <code class= source >			into nv and nt dimensions.</code>  cat<code class= source >	If set, arrays from mulitple input objets are</code> <code class= source >			concatenated.</code> <code class= source >	&lt;condition&gt;:	All of the predefined conditions (e.g. /visible) are</code> <code class= source >			accepted; see pnt_condition_keywords.include.</code>  noevent<code class= source >If set, no event is generated.</code>  xd@str__keywords_tree.include", "NV/OBJ/STR", "<code class= source > 	Written by:	Spitale, 2/2017</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_replicate.html", "str_replicate.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_replicate.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_replicate.html#str_replicate", "str_replicate", 'routine in <a href="obj/str/str_replicate.html">str_replicate.pro</a>', "str_replicate.pro", "", "str_replicate", "<code class= source >	Replicates the given descriptor, producing an array of the given</code> <code class= source >	dimensions containing cloned versions of the input descriptor.</code>  ", "sd<code class= source > Star descriptor.</code>  dim<code class= source > Dimensions of the result.</code>  ", "NV/LIB/STR", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >	Array of the given dimensions containing cloned versions of the input</code> <code class= source >	descriptor.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_set_lum.html", "str_set_lum.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_set_lum.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_set_lum.html#str_set_lum", "str_set_lum", 'routine in <a href="obj/str/str_set_lum.html">str_set_lum.pro</a>', "str_set_lum.pro", "", "str_set_lum", "<code class= source >	Replaces the luminosities for each given star descriptor.</code>  ", "noeventsd<code class= source > Array (nt) of any subclass of STAR.</code>  lum<code class= source > Array (nt) of new luminosity values.</code>  ", "NV/LIB/STR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_set_sp.html", "str_set_sp.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_set_sp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_set_sp.html#str_set_sp", "str_set_sp", 'routine in <a href="obj/str/str_set_sp.html">str_set_sp.pro</a>', "str_set_sp.pro", "", "str_set_sp", "<code class= source >	Replaces the spectra class for each given star descriptor.</code>  ", "noeventsd<code class= source > Array (nt) of any subclass of STAR.</code>  sp<code class= source > Array (nt) of new sp strings.</code>  ", "NV/LIB/STR", "<code class= source > 	Written by:	Spitale, 1/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/str/str_sp.html", "str_sp.pro", '.pro file in <a href="obj/str/dir-overview.html">obj/str/ directory</a>', "str_sp.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/str/str_sp.html#str_sp", "str_sp", 'routine in <a href="obj/str/str_sp.html">str_sp.pro</a>', "str_sp.pro", "", "str_sp", "<code class= source >       Returns a spectral type for each given star descriptor.</code>  ", "noeventsd<code class= source >   Array (t) of star descriptors</code>  ", "NV/LIB/STR", "<code class= source >       Written by:     Haemmerle, 5/1998</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  <code class= source >       An array (nt) of spectral types which is a three character string.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/sub_latlon.html", "sub_latlon.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "sub_latlon.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/sub_latlon.html#sub_latlon", "sub_latlon", 'routine in <a href="obj/tools/sub_latlon.html">sub_latlon.pro</a>', "sub_latlon.pro", "", "sub_latlon", "<code class= source >	Computes sub-observer latitude and longitude on a globe.</code>  ", "body_pt<code class= source >Array (nv,3,nt) giving the sub-observer point in</code> <code class= source >			BODY coordinates.</code>  surf_pt<code class= source >Array (nv,3,nt) giving the sub-observer point in</code> <code class= source >			SURFACE coordinates.</code>  graphic<code class= source >  If set, use planetographic coordinates.</code>  gbx<code class= source >Array (nt) of any subclass of GLOBE.</code>  v<code class= source >Array (nv,3,nt) giving the observer position in the BODY frame.</code>  sublatsublon", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	sublat:	Array (nv,nt) of latitude of sub-observer point on gbx.</code> <code class= source >	sublon:	Array (nv,nt) of longitude of sub-observer point on gbx.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_hide_points.html", "surface_hide_points.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_hide_points.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_hide_points.html#surface_hide_points", "surface_hide_points", 'routine in <a href="obj/tools/composite/surface_hide_points.html">surface_hide_points.pro</a>', "surface_hide_points.pro", "", "surface_hide_points", "<code class= source >	Hides points with respect to surface objects.</code>  ", "bx<code class= source >Array (nt) of any subclass of BODY descriptors with</code> <code class= source >		the expected surface parameters.</code>  v<code class= source >Array (nv,3,nt) giving viewer positions in the BODY frame.</code>  r<code class= source >Array (nv,3,nt) giving points to hide in the BODY frame.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source > 	Written by:	Spitale, 7/2016</code>  <code class= source >	Subscripts of the points in p that are hidden by the object.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_image_bounds.html", "surface_image_bounds.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_image_bounds.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_image_bounds.html#surface_image_bounds", "surface_image_bounds", 'routine in <a href="obj/tools/composite/surface_image_bounds.html">surface_image_bounds.pro</a>', "surface_image_bounds.pro", "", "surface_image_bounds", "<code class= source >	Computes latitude / longitude ranges visible in an image.</code>  ", "slop<code class= source >Amount, in pixels, by which to expand the image size</code> <code class= source >		considered in the calcultaion.</code>  border_pts_im<code class= source >Image points on the border of the image defined by cd.</code>  latmin<code class= source >Minimum latitude covered in image</code>  latmax<code class= source >Maximum latitude covered in image</code>  lonmin<code class= source >Minimum longitude covered in image</code>  lonmax<code class= source >Maximum longitude covered in image</code>  statuscd<code class= source >     Camera descriptor</code>  bx<code class= source >     Object descriptor (subclass of BODY)</code>  ", "NV/LIB/TOOLS/COMPOSITE", "");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_intersect.html", "surface_intersect.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_intersect.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_intersect.html#surface_intersect", "surface_intersect", 'routine in <a href="obj/tools/composite/surface_intersect.html">surface_intersect.pro</a>', "surface_intersect.pro", "", "surface_intersect", "<code class= source >	Computes the intersection of rays with surface objects.</code>  ", "hit<code class= source >Array giving the indices of rays that hit the object in</code> <code class= source >		the forward direction.</code>  back_pts<code class= source >		Array (nb,3,nt) of  back  points in order of distance from</code> <code class= source >		the observer.  If the observer is exterior, these are the</code> <code class= source >		intersections on the back side of the body, or those behind</code> <code class= source >		the observer; if the observer is interior, these intersections</code> <code class= source >		are behind the observer.</code>  bx<code class= source >	Array (nt) of any subclass of BODY descriptors with</code> <code class= source >			the expected surface parameters.</code>  view_pts<code class= source >Array (nv,3,nt) giving ray origins in the BODY frame.</code>  ray_pts<code class= source >Array (nv,3,nt) giving ray directions in the BODY frame.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source > 	Written by:	Spitale, 7/2015</code>  <code class= source >	Array (nv,3,nt) of points in the BODY frame corresponding to the</code> <code class= source >	first intersections with the ray.  Zero vector is returned for points</code> <code class= source >	with no solution.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/surface_normal.html", "surface_normal.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "surface_normal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/surface_normal.html#surface_normal", "surface_normal", 'routine in <a href="obj/tools/surface_normal.html">surface_normal.pro</a>', "surface_normal.pro", "", "surface_normal", "<code class= source >	Computes the normal at points on a surface.</code>  ", "frame_bd<code class= source > Frame descriptor, if required for bx.</code>  north<code class= source >    Passed to dsk_surface_normal.  Causes surface normal</code> <code class= source >	           to point north regardless of observer position.</code>  bx<code class= source >Array (nt) of any subclass of BODY descriptors with</code> <code class= source >		the expected surface parameters.</code>  v<code class= source >Array (nv,3,nt) giving observer positions in the BODY frame.</code>  r<code class= source >Array (nv,3,nt) giving surface positions in the BODY frame.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source > 	Written by:	Spitale, 7/2015</code>  <code class= source >	Array (nv, 3, nt) of surface unit normals in the BODY frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_normal.html", "surface_normal.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_normal.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_normal.html#surface_normal", "surface_normal", 'routine in <a href="obj/tools/composite/surface_normal.html">surface_normal.pro</a>', "surface_normal.pro", "", "surface_normal", "<code class= source >	Computes the normal at points on a surface.</code>  ", "north<code class= source >    Passed to dsk_surface_normal.  Causes surface normal</code> <code class= source >	           to point north regardless of observer position.</code>  bx<code class= source >Array (nt) of any subclass of BODY descriptors with</code> <code class= source >		the expected surface parameters.</code>  v<code class= source >Array (nv,3,nt) giving observer positions in the BODY frame.</code>  r<code class= source >Array (nv,3,nt) giving surface positions in the BODY frame.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source > 	Written by:	Spitale, 7/2015</code>  <code class= source >	Array (nv, 3, nt) of surface unit normals in the BODY frame.</code> <code class= source > STATUS:</code> <code class= source >	Complete</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_body.html", "surface_to_body.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_body.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_body.html#surface_to_body", "surface_to_body", 'routine in <a href="obj/tools/composite/surface_to_body.html">surface_to_body.pro</a>', "surface_to_body.pro", "", "surface_to_body", "<code class= source >       Transforms points in any surface coordinate system to body</code> <code class= source >	coordinates.</code>  ", "bx<code class= source >     Array of nt object descriptors (subclass of BODY).</code>  p", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (nv x 3 x nt) of body coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/surface_to_degrees.html", "surface_to_degrees.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "surface_to_degrees.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/surface_to_degrees.html#surface_to_degrees", "surface_to_degrees", 'routine in <a href="obj/tools/surface_to_degrees.html">surface_to_degrees.pro</a>', "surface_to_degrees.pro", "", "surface_to_degrees", "<code class= source >       Converts angular part of surface vectors from radians to degrees</code>  ", "v<code class= source >      An array of surface vectors (nv,3,nt).</code>  ", "NV/LIB/TOOLS", "<code class= source >       Array of vectors (nv,3,nt)</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_image.html", "surface_to_image.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_image.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_image.html#surface_to_image", "surface_to_image", 'routine in <a href="obj/tools/composite/surface_to_image.html">surface_to_image.pro</a>', "surface_to_image.pro", "", "surface_to_image", "<code class= source >       Transforms points in any surface coordinate system to image</code> <code class= source >	coordinates.</code>  ", "body_ptsvalidcd<code class= source >     Array of nt camera or map descriptors.</code>  bx<code class= source >     Array of nt object descriptors (subclass of BODY).</code>  p", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of image points.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_map.html", "surface_to_map.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "surface_to_map.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/surface_to_map.html#surface_to_map", "surface_to_map", 'routine in <a href="obj/tools/composite/surface_to_map.html">surface_to_map.pro</a>', "surface_to_map.pro", "", "surface_to_map", "<code class= source >       Transforms points in any surface coordinate system to map</code> <code class= source >	coordinates.</code>  ", "md<code class= source >     Array of nt map descriptors.</code>  bx<code class= source >     Array of nt object descriptors (subclass of BODY.</code>  surface_pts<code class= source >      Array (nv x 3 x nt) of surface points</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       Array (2 x nv x nt) of map coordinates.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/composite/ta_to_az.html", "ta_to_az.pro", '.pro file in <a href="obj/tools/composite/dir-overview.html">obj/tools/composite/ directory</a>', "ta_to_az.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/composite/ta_to_az.html#ta_to_az", "ta_to_az", 'routine in <a href="obj/tools/composite/ta_to_az.html">ta_to_az.pro</a>', "ta_to_az.pro", "", "ta_to_az", "<code class= source >	Computes azimuths relative to a given observer descriptor.</code>  ", "ta<code class= source >Longitude.</code>  dkx<code class= source >Disk descriptor.</code>  bx<code class= source >Object descriptor (subclass of BODY) describing the observer.</code>  ", "NV/LIB/TOOLS/COMPOSITE", "<code class= source >       An array of azimuths.</code> <code class= source > STATUS:</code> <code class= source >       Completed.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/tools/target_altaz.html", "target_altaz.pro", '.pro file in <a href="obj/tools/dir-overview.html">obj/tools/ directory</a>', "target_altaz.pro", "", "", "", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("obj/tools/target_altaz.html#target_altaz", "target_altaz", 'routine in <a href="obj/tools/target_altaz.html">target_altaz.pro</a>', "target_altaz.pro", "", "target_altaz", "<code class= source >	Computes altitude/azimuth of a target relative to a point on or near the</code> <code class= source >	surface of a globe.</code>  ", "bx<code class= source >Array (nt) of any subclass of BODY giving the target.</code>  pdlat<code class= source >Latitude of observer wrt gbx.</code>  lon<code class= source >Longitude of observer wrt gbx.</code>  alt<code class= source >Altitude of observer wrt gbx.</code>  ", "NV/LIB/TOOLS", "<code class= source >       Written by:     Spitale</code>  <code class= source >	Vector from observer to target in the altaz system.</code>  ");
  
  

libdata[libdataItem++] = new Array("obj/dat/tr_keyword_value.html", "tr_keyword_value.pro", '.pro file in <a href="obj/dat/dir-overview.html">obj/dat/ directory</a>', "tr_keyword_value.pro", "", "", "<code class= source >	Looks up a keyword in the data descriptor-stored keyword/value pairs.</code>  ", "", "          -1", "<code class= source > 	Written by:	Spitale</code> <code class= source > 	Adapted by:	Spitale, 5/2016</code>  ");
  

